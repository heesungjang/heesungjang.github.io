---
emoji: ✏️
title: Algorithm[소수]
date: '2022-04-04 00:00:00'
author: heesung jang
tags: 알고리즘 소수 prime
categories: algorithm
---

보통 소수 찾기 문제에서 소수의 정의를 같이 제공하기 때문에 반복문으로 충분히 풀이가 가능하다. 그치만 약수가 가지는 특징을 이용하면 성능 개선이 가능하다.

알고리즘 문제를 풀기 위해서 특정 문제에서만 사용되는 지엽적인 지식들은 모두 알고 있을 수 없지만 코딩 테스트에서 특정 자연수가 소수인지 판별하는 문제가 자주 출제되기 때문에 소수에 대한 성질은 짚고 넘어가고자 한다.

### 1️⃣ 소수란:

- **소수**란 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로 나누어 떨어지지 않는 자연수이다.
  e.g) **6**은 1, 2, 3, 6으로 나누어 떨어지므로 소수가 아니다.
  e.g) **7**은 1과 7을 제외하고는 나누어 떨어지지 않으므로 소수이다.

소수 정의에 주어진 조건만으로 반복문을 통해서 소수를 판별해보자.

#### 기본 풀이:

```python
def is_prime_number(n: int) -> bool:
    if n == 1:
        return False
    if n == 2:
        return True

    # 2부터 (n-1) 까지의 모든 수를 확인
    for i in range(2, n):
        # n이 해당 수로 나누어 떨어지면
        if n % i == 0:
            return False  # 소수가 아님

    return True  # 소수임
```

소수 판별을 위한 연산량을 생각해보자. 주어진 자연수 n이 10억이라고 한다면 해당 자연수가 소수인지 판별하기 위해서 2부터 10억 - 1까지 반복문 안에 로직을 실행한다. 즉, 2부터 n-1의 모든 i가 n의 약수인지를 확인하기 때문에 o(n)의 시간 복잡도를 가진다. n의 최대값이 10억이라면 해당 문제를 1초~2초의 시간 조건을 통과하기 힘들기 때문에 타임아웃에 걸릴것이다.

그렇다면 위 코드를 조금 더 개선할 수 있을까?

> 짝수들은 2를 제외하고 모두 합성수라는 사실을 이용해 개선 할 수 있다.

```python
def is_prime_number(n: int) -> bool:
    if n == 1:
        # 1은 소수가 아니다.
        return False
    elif n == 2:
        # 2는 소수이다.
        return True
    elif n % 2 == 0:
        👉 # 나머지 짝수는 소수가 아니다.
        return False

    # 2부터 (n-1) 까지의 모든 수를 확인
    for i in range(2, n):
        # n이 해당 수로 나누어 떨어지면
        if n % i == 0:
            return False  # 소수가 아님

    return True  # 소수임
```

위 코드에서는 짝수들은 2를 제외하고 모두 합성수라는 사실을 이용해 알고리즘의 성능을 개선했다. n이 짝수인 경우에 시간복잡도는 O(N)이다. 그렇지만 최악의 경우 즉, n의 값이 홀수라면 여전히 O(N)의 시간 복잡도가 걸린다.

<hr/>

### 2️⃣ 약수의 성질:

> 모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이루는 것을 알 수 있다

자연수N의 한 약수a를 생각해보자.N을a로 나눈 몫을b라고 하면 아래의 식이 성립한다.

```
𝑁 = 𝑎𝑏 (단, 𝑎 ≤ 𝑏 )
```

즉,한 자연수N에 대해 서로 곱하여N이 되는 약수 쌍a,b가 **항상**❗️ 존재한다 (편의상a는 b이하인 경우만 고려하자).

```
(𝑎≤𝑏)라는 조건 하에서 N에 대한 a의 최대 값은 𝑎≤ 𝑁이다.

그러므로,N이 소수가 아니라면 2≤𝑎≤ 𝑁 범위에 약수a가 반드시 존재한다.

대우명제>2≤𝑎≤ 𝑁 범위에 약수가 없다면N은 소수다.
```

해당 명제를 그림으로 보면 훨씬 이해하기 쉽다.

![](https://media.vlpt.us/images/heesungj7/post/fdc4ba75-7c1c-4ff5-8415-727943be6a3c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-04%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.02.09.png)

위 그림에 16를 대입해보자.

- 예들 들어 16의 약수는 1, 2, 4, 8, 16이다.
- 이때 2 X 8 = 16은 8 X 2 = 16과 대칭이다.
- 예를 들어 16이 2로 나누어떨어진다는 것은 8로도 나누어떨어진다는 것을 의미한다

![](https://media.vlpt.us/images/heesungj7/post/8d97df8b-62c4-4832-ae76-6d6481399d96/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-04%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.02.44.png)

❗️ 따라서 우리는 특정한 자연수의 모든 약수를 찾을 때 가운데 **약수(제곱근)까지만** 확인하면 된다.

#### 기본 풀이:

```python
def is_prime_number(n: int) -> bool:
    if n == 1:
        # 1은 소수가 아니다.
        return False
    elif n == 2:
        # 2는 소수이다.
        return True
    elif n % 2 == 0:
        # 나머지 짝수는 소수가 아니다.
        return False

    # 2부터 (n의 제곱근) 까지의 모든 수를 확인
    for i in range(2, int(math.sqrt(n)) + 1):
        # x가 해당 수로 나누어 떨어진다면
        if n % i == 0:
            # 소수가 아님
            return False

    return True  # 소수임
```

개선된 코드의 시간 복잡도는 제곱근까지 즉 약수들의 절반 길이만큼만 반복문을 실행하기 때문에 O(n^1/2))이다.

```toc

```
