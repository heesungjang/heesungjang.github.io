{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leetcode-20/",
    "result": {"data":{"cur":{"id":"08fd98ab-1a03-5af1-a296-d4fc8d35a4c6","html":"<p>문제: <a href=\"https://leetcode.com/problems/valid-parentheses/submissions/\">leetcode -20</a> (valid parentheses)</p>\n<p>이번 문제의 난이도는 easy이고 스택을 이용하는 대표적인 문제이다. 문제 풀이를 위해서 스택의 구현이 직접 필요하지 않으며 python 리스트로 충분히 구현이 가능하다. pop() 연산만이 필요하기 때문에 데크를 이용한 풀이와 시간적으로 차이가 없다.</p>\n<p>입력 값으로 괄호로 구성된 문자열이 주어진다. 주어진 문자열을 검사해서 모든 괄호들이 올바르게 닫혀 있는지 확인하여 bool 타입의 결과 값을 리턴 해줘야 한다. 여기서 올바르게 닫혀있는 괄호란 (){}이나 ({}) 같이 닫는 괄호가 나올 때 제일 최근에 있는 여는 괄호와 매칭된 형태이다.</p>\n<p>✅ 올바르게 닫힌 괄호 예시:</p>\n<ul>\n<li>()</li>\n<li>({})</li>\n<li>{{([])}}</li>\n</ul>\n<p>❌ 올바르게 닫히지 않은 예시:</p>\n<ul>\n<li>((</li>\n<li>((])</li>\n<li>]]</li>\n<li>({[)})</li>\n</ul>\n<h3 id=\"문제풀이\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\" aria-label=\"문제풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제풀이:</h3>\n<p>이 문제의 풀이는 간단하다.</p>\n<ol>\n<li>첫번째로 주어진 문자열을 반복문으로 왼쪽에서부터 오른쪽으로 이동한다.</li>\n<li>열린 괄호가 나오면 스택에 넣는다.</li>\n<li>만약 닫힌 괄호가 나오면 현재 <strong>stack의 top</strong>, 즉 가장 최신에 들어온 열린 괄호와 비교하여 서로가 상응하는 쌍인지 확인하다.</li>\n<li>비교할때 pop() 연사을 실행하기 때문에 중간에 break없이 모든 ilteration이 끝났다면 최종적으로 stack은 비어있게 된다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">is_valid</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n    stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    match <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"(\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\")\"</span><span class=\"token punctuation\">,</span>\n             <span class=\"token string\">\"{\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"}\"</span><span class=\"token punctuation\">,</span>\n             <span class=\"token string\">\"[\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"]\"</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> char <span class=\"token keyword\">in</span> s<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> char <span class=\"token keyword\">in</span> <span class=\"token string\">\"({[\"</span><span class=\"token punctuation\">:</span>\n            stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n            <span class=\"token keyword\">if</span> char <span class=\"token operator\">==</span> match<span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span></code></pre></div>\n<p>시간 복잡도: 문자열의 길이만큼 반복문을 돌기 때문에 O(n)의 시간 복잡도를 가진다.</p>\n<p>공간 복잡도: 열린 문자를 Stack에 담기 때문에 O(n)의 공간 복잡도를 가진다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\">문제풀이:</a></li>\n</ul>\n</div>","excerpt":"문제: leetcode -20 (valid parentheses) 이번 문제의 난이도는 easy이고 스택을 이용하는 대표적인 문제이다. 문제 풀이를 위해서 스택의 구현이 직접 필요하지 않으며 python 리스트로 충분히 구현이 가능하다. pop() 연산만이 필요하기 때문에 데크를 이용한 풀이와 시간적으로 차이가 없다. 입력 값으로 괄호로 구성된 문자열이 주어진다. 주어진 문자열을 검사해서 모든 괄호들이 올바르게 닫혀 있는지 확인하여 bool 타입의 결과 값을 리턴 해줘야 한다. 여기서 올바르게 닫혀있는 괄호란 (){}이나 ({}) 같이 닫는 괄호가 나올 때 제일 최근에 있는 여는 괄호와 매칭된 형태이다. ✅ 올바르게 닫힌 괄호 예시: () ({}) {{([])}} ❌ 올바르게 닫히지 않은 예시: (( ((]) ]] ({[)}) 문제풀이: 이 문제의 풀이는 간단하다. 첫번째로 주어진 문자열을 반복문으로 왼쪽에서부터 오른쪽으로 이동한다. 열린 괄호가 나오면 스택에 넣는다. 만약 닫힌 …","frontmatter":{"date":"March 21, 2021","title":"leetcode(20)- Valid parentheses","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-20/"}},"next":{"id":"8c65d29f-84d9-56f2-8510-ab52304106e9","html":"<p>문제: <a href=\"https://leetcode.com/problems/fibonacci-number/\">leetcode - 509</a> (피보나치 수열)</p>\n<p>일반적으로 F(n)로 표기하며 피보나치 숫자는 피보나치 수열 이라고 불리는 수열를 형성하며, 각 숫자는 0과 1에서 시작하는 앞의 두 숫자의 합이된다. 즉, 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 <strong>F(n) = F(n-1) + F(n-2)</strong> 가 적용되는 수 이다.</p>\n<p>예시:</p>\n<ul>\n<li>F(2) = F(0) + F(1) = 0 + 1 = 1</li>\n<li>F(3) = F(1) + F(2) = 1 + 1 = 2</li>\n<li>F(4) = F(2) + F(3) = 1 + 2 = 3</li>\n<li>F(5) = F(3) + F(4) = 2 + 3 = 5</li>\n</ul>\n<p>n=5일경우 피보나치 수열을 나열해보면 [0, 1, 1, 2, 4, 5] 형태로 나열된다.</p>\n<p>사실 이 문제는 필요한 식을 제공하기 때문에 피보나치 수열을 알고있지 않더라도 풀이가 가능하다.</p>\n<hr/>\n<h3 id=\"1️⃣-문제풀이-1-recursion\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-1-recursion\" aria-label=\"1️⃣ 문제풀이 1 recursion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ 문제풀이 1 (recursion)</h3>\n<p>피보나치 수열 문제는 재귀함수를 소개하는 입문 영상에서 많이 다뤄지는 대표적인 문제이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">non_memo_fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">raise</span> ValueError<span class=\"token punctuation\">(</span><span class=\"token string\">\"n must be a positive integer\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">elif</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> non_memo_fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> non_memo_fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>우선, 재귀적으로 문제를 풀기 위해서 재귀 종료 조건이 되는 베이스 케이스를 생각해보자.</p>\n<p>2개의 베이스 케이스가 필요할 것이다. 첫번째로 nth 값이 0 인지, 다른 하나는 전달된 nth 번호가 1인지 여부이다. 피보나치 수열의 전제 조건이 <strong>F(0) = 0, F(1) = 1일 때</strong>, 1 이상의 n에 대하여 <strong>F(n) = F(n-1) + F(n-2)</strong> 가 성립되므로 n이 0일때 0을 리턴, n이 1이하일 때 1을 리턴하는 함수의 종료 지점(탈출 조건)이 생긴다.</p>\n<p>그 이외에는 리턴 값으로 Fibonacci(n-1) + Fibonacci(n-2)를 갖는다. 재귀적으로 자기 자신을 호출하며 종료 지점에 이르기까지 콜 스택에 호출된 함수가 쌓이게되고 종료 지점에 이르러 다시 오는 방식으로 작동한다.</p>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/5ee550c7-e37e-462e-89cc-89ffe6c88ae6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.04.58.png\" alt=\"\"></p>\n<p>이 문제는 재귀 함수를 사용하면 쉽고 직관적으로 풀이가 가능하지만 효율성이 떨어지는 연산이다.</p>\n<p>시간 복잡도를 살펴보자.</p>\n<p>2번씩 트리의 높이 n만큼 반복하여 함수를 호출하기 때문에 해당 풀이는 O(n^2)의 시간 복잡도를 가지며 콜 스택에 n만큼의 호출 함수가 쌓이기 때문에 O(n)의 공간 복잡도를 가진다 (❗️실행이 완료된 함수는 콜 스택에서 제거되기 때문에 n만큼만 쌓인다). 즉, 자기 자신을 2번씩 재호출하게 되므로, 흡사 binary tree 같은 형태를 가지며 입력 값이 증가함에 따라 함수 호출 횟수를 기하급수적으로 증식시키게 된다.</p>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/7ef1b34a-ff5f-46a4-b98f-c1f903c187a6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.15.34.png\" alt=\"\"></p>\n<p>재귀함수의 호출을 보여주는 recursion tree를 보면 이미 한번 계산된 함수가 여러번 반복해서 호출되는 것을 확인 할 수 있다. n=4일때 fib(2)는 총 2번, fib(1)은 3번 fib(0)은 총 2번 호출된다. 만약 n의 값이 4가 아니라 40이라고 한다면 훨씬 더 많은 비효율적인 반복 함수 호출이 발생할 것이다.</p>\n<p>이를 해결해주는 기법이 여러가지 존재하는데 memorization 기법으로 이미 연산이 끝난 함수의 반복 호출을 제거하면 O(n)의 시간 복잡도로 연산이 가능하다.</p>\n<h3 id=\"2️⃣-문제풀이-2-recursion-with-memorization\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-2-recursion-with-memorization\" aria-label=\"2️⃣ 문제풀이 2 recursion with memorization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ 문제풀이 2 (recursion with memorization)</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">memo_fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> memorization<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> memorization <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        memorization <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> n <span class=\"token keyword\">in</span> memorization<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;&lt;</span> ⭐️\n        <span class=\"token keyword\">return</span> memorization<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        memorization<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> memo_fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> memorization<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> memo_fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> memorization<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> memorization<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>함수의 파라미터 값으로 memorization라는 파라미터가 하나 추가됬다. 이미 연산을 마친 함수와 해당 연산으로 나온 값을 저장하는 역할을 한다. ⭐️로 표시한 부분에서 호출된 함수의 연산 값이 저장소에 있는지 확인하고 이미 계산한값은 메모해둔곳에서 가져와서 (<strong>상수 시간의 연산</strong>) 사용한다. 메모를 위해서 O(n)만큼의 공간 복잡도를 추가해야 하지만, 이미 계산한 값을 또 재귀 호출로 계산할 필요가 없으므로 O(n) 의 시간복잡도 연산을 끝낼 수 있다.</p>\n<h3 id=\"3️⃣-문제풀이-3-iterative-approach\" style=\"position:relative;\"><a href=\"#3%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-3-iterative-approach\" aria-label=\"3️⃣ 문제풀이 3 iterative approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3️⃣ 문제풀이 3 (iterative approach)</h3>\n<p>재귀 함수로 풀이한 문제는 당연히 반복문으로 치환이 가능하다. 사실 대부분의 경우 반복문이 효율적인 측면에서 재귀함수 보다 더 좋고 선언적 프로그래밍에 익숙하지 않다면 몇줄에 코드가 더 늘어나도 명령형 프로그래밍의 반복문 작성이 보다 직관적이다. 실제로 재귀 함수는 코드만 봐서는 해당 로직이 반복되는지 알기 어렵다. 반면 for문 또는 while문 같이 명령형 프로그래밍의 반복문은 “나 지금 반복하고 있다”를 코드를 읽으면 바로 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"> <span class=\"token keyword\">def</span> <span class=\"token function\">liter_fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token keyword\">or</span> n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n\n    last_two <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    counter <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n\n    <span class=\"token keyword\">while</span> counter <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">:</span>\n        next_fib <span class=\"token operator\">=</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        last_two<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        last_two<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> next_fib\n        counter <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">return</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">if</span> n <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token keyword\">else</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>위 코드는 last_two라는 배열에 n-2와 n-1만 저장한다.</p>\n<p>last_two[0] = n - 2\nlast_two[1] = n - 1</p>\n<p>입력 값 n만큼 while문을 돌면서 (n - 2) + (n -1)의 값을 계산하고 새로운 n-1과 n-2를 업데이트한다. 반복문이 끝나면 마지만 연산 값인 last_two[1]를 반환한다. nth 값을 구하기 위해서 n의 길이 만큼만 반복하면 되기 때문에 O(n)의 시간 복잡도를 가지고 last_two라는 배열에 현재 계산중인 n-1, n-2 두개의 값만 저장하고 있으면 되기 때문에 O(1)의 공간 복잡도를 가진다. 재귀 풀이에 비해 모든 측면에서 훨씬 효율적이다. 또한 개인적으로 해당 코드가 보다 직관적이고 이해하기 쉽다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-1-recursion\">1️⃣ 문제풀이 1 (recursion)</a></li>\n<li><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-2-recursion-with-memorization\">2️⃣ 문제풀이 2 (recursion with memorization)</a></li>\n<li><a href=\"#3%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-3-iterative-approach\">3️⃣ 문제풀이 3 (iterative approach)</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 21, 2021","title":"leetcode(509)- Fibonacci number","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-509/"}},"prev":{"id":"7f463590-1002-53cd-83f3-7cf324d82ed7","html":"<p>asdfasdf</p>","frontmatter":{"date":"March 21, 2021","title":"test123","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/test/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leetcode-20/","nextSlug":"/leetcode-509/","prevSlug":"/test/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}