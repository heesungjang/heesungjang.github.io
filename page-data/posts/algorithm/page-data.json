{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/algorithm",
    "result": {"pageContext":{"currentCategory":"algorithm","categories":["All","algorithm","DataStructure"],"edges":[{"node":{"id":"2ee7b41e-a815-5c88-9f47-b2918012f09b","excerpt":"문제: leetcode - 83 (Remove Duplicates from Sorted List) Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 1️⃣ 문제풀이: 정렬된 단일연결리스트를 순회하며 중복(동일값) 여부를 확인하여 제거한다. 반복문과 포인터를 이용하여 LinkedList를 순회하면서 현재노드와 다음 노드의 값이 같은경우 현재노드의 다음노드를 다다음노드로 연결한다. 중복이 발생하는 마지막 노드까지 이동하여 해당 노드의 next 노드 즉, 중복이 아닌 새롭게 시작되는 값을 가진 노드를 현재 head 다음 노드로 연결해준다. 아닐 경우 포인터를 앞으로 한칸 이동시켜 head 노드를 이동시켜준다. 1️⃣ 문제풀이:","fields":{"slug":"/leetcode-83/"},"frontmatter":{"categories":"algorithm","title":"leetcode(83)- Remove Duplicates from Sorted List","date":"March 25, 2022"}},"next":{"fields":{"slug":"/leetcode-88/"}},"previous":null},{"node":{"id":"8b82364b-2829-556f-8cd7-348af94b4575","excerpt":"문제: leetcode - 88 (Merge sorted array) 오름차순으로 정렬된 정수들로 이루어진 2개의 배열 nums1과 nums2가 입력값으로 주어진다. 그냥보면 병합정렬 문제이다. 특이한점이 있다면 return 값으로 병합된 배열을 반환하지 않고 초기에 주어진 nums1에 직접 병합을 해야한다. 예시:  1️⃣ 문제해설 1: 처음에 지문을 읽고는 뭐지..?라는 생각이 들었다. 첫번째로 nums1을 보면 정렬된 정수들뒤로 nums2의 길이만큼 0으로 공간이 초기화되어 있고 배열 내 병합할 원소의 개수를 의미하는 m, n이 주어진다. 결론부터 말하면 sorting 없이 포인터를 지정해서 배열의 병합이 가능하다. 해당 문제풀이는 discussion에서 다른 사람의 코드를 가져왔다. 문제해설2에서 다루겠다. 정렬을 신경쓰지 않고, nums2에 있는 모든 요소들을 nums1에 넣어준다. list.sort()로 오름차 정렬을 시켜준다. 시간 복잡도: 파이썬의 sort() 함수가 O…","fields":{"slug":"/leetcode-88/"},"frontmatter":{"categories":"algorithm","title":"leetcode(88)- Merge sorted array","date":"March 23, 2022"}},"next":{"fields":{"slug":"/leecode-151/"}},"previous":{"fields":{"slug":"/leetcode-83/"}}},{"node":{"id":"613d8fb0-b581-5f32-899d-e58f0f08d9f2","excerpt":"문제: leetcode - 151 (Reverse Words in a String) 🎉 기분이 좋은 밤이다. 블로그에 현재까지 정리한 문제풀이는 지금 작성하고 있는 리트코드 151번 문제를 포함해서 3개밖에 되지 않지만 벌써 3주째 하루에 한 문제씩 알고리즘 문제를 풀고있다. 아직까지 Hard level의 문제는 시도조차 하지 않고 있고 easy 또는 Medium level의 문제 위주로 풀고있다. 1️⃣ 문제풀이1: 파이썬의 내장함수인 strip() 사용해서 좌우 여백을 제거한다.. 여백이 제거된 문자열을 반복문으로 이동하면서 공백이 나오기전까지 모든 문자들을 temp_string에 임시로 저장한다. 공백이 나오면 새로운 단어가 시작되는 구간이기 때문에 현재 temp_string에 저장된 문자열을 words에 추가하고 temp_string을 다시 초기화 해준다. 마지막 단어 다음에는 공백이 존재하지 않기 때문에 반복문이 끝나면 temp_string에 저장된 마지막 문자열을 words…","fields":{"slug":"/leecode-151/"},"frontmatter":{"categories":"algorithm","title":"leetcode(151)- Reverse Words in a String","date":"March 22, 2022"}},"next":{"fields":{"slug":"/leetcode-509/"}},"previous":{"fields":{"slug":"/leetcode-88/"}}},{"node":{"id":"8c65d29f-84d9-56f2-8510-ab52304106e9","excerpt":"문제: leetcode - 509 (피보나치 수열) 일반적으로 F(n)로 표기하며 피보나치 숫자는 피보나치 수열 이라고 불리는 수열를 형성하며, 각 숫자는 0과 1에서 시작하는 앞의 두 숫자의 합이된다. 즉, 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 이다. 예시: F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 n=5일경우 피보나치 수열을 나열해보면 [0, 1, 1, 2, 4, 5] 형태로 나열된다. 사실 이 문제는 필요한 식을 제공하기 때문에 피보나치 수열을 알고있지 않더라도 풀이가 가능하다. 1️⃣ 문제풀이 1 (recursion) 피보나치 수열 문제는 재귀함수를 소개하는 입문 영상에서 많이 다뤄지는 대표적인 문제이다…","fields":{"slug":"/leetcode-509/"},"frontmatter":{"categories":"algorithm","title":"leetcode(509)- Fibonacci number","date":"March 21, 2022"}},"next":{"fields":{"slug":"/leetcode-20/"}},"previous":{"fields":{"slug":"/leecode-151/"}}},{"node":{"id":"08fd98ab-1a03-5af1-a296-d4fc8d35a4c6","excerpt":"문제: leetcode -20 (valid parentheses) 이번 문제의 난이도는 easy이고 스택을 이용하는 대표적인 문제이다. 문제 풀이를 위해서 스택의 구현이 직접 필요하지 않으며 python 리스트로 충분히 구현이 가능하다. pop() 연산만이 필요하기 때문에 데크를 이용한 풀이와 시간적으로 차이가 없다. 입력 값으로 괄호로 구성된 문자열이 주어진다. 주어진 문자열을 검사해서 모든 괄호들이 올바르게 닫혀 있는지 확인하여 bool 타입의 결과 값을 리턴 해줘야 한다. 여기서 올바르게 닫혀있는 괄호란 (){}이나 ({}) 같이 닫는 괄호가 나올 때 제일 최근에 있는 여는 괄호와 매칭된 형태이다. ✅ 올바르게 닫힌 괄호 예시: () ({}) {{([])}} ❌ 올바르게 닫히지 않은 예시: (( ((]) ]] ({[)}) 문제풀이: 이 문제의 풀이는 간단하다. 첫번째로 주어진 문자열을 반복문으로 왼쪽에서부터 오른쪽으로 이동한다. 열린 괄호가 나오면 스택에 넣는다. 만약 닫힌 …","fields":{"slug":"/leetcode-20/"},"frontmatter":{"categories":"algorithm","title":"leetcode(20)- Valid parentheses","date":"March 21, 2022"}},"next":{"fields":{"slug":"/algo-hash-table/"}},"previous":{"fields":{"slug":"/leetcode-509/"}}},{"node":{"id":"5225a0a2-941e-53ab-975f-368d705f85f7","excerpt":"보초법 (sentinel method) 여러가지 배열 검색 방법들중 선형검색은 배열의 처음부터 마지막 또는 찾고자 하는 데이터가 나올때까지 순차적으로 모든 데이터를 비교하는 방법이다. 간단한 코드 예제 위 선형 검색은 루프가 반복할 때마다 2가지 종료 조건을 체크한다. 단순한 판단이지만 이 과정을 계속 반복하면 종류 조건을 검사하는 cost를 무시할 수 없다. 선형 검색의 종류 조건 i == len(l)가 성립하면 (실패) a[i] == value가 성립하면 (성공) 이과정을 줄여주는 것이 보초법(sentinel method)이다.  검색하고자 하는 키값을 배열의 맨 끝에 넣어준다. 이때 저정하는 값을 보초라고 한다. 위 그림에서 볼 수 있듯이, 기존 데이터에 찾고자하는 키 값이 존재하지 않아도, 보초를 통해 검색할 값을 찾았나?라는 질문에 True를 반환하게된다. 이렇게 if 조건을 하나 단축할 수 있으며, return에서 찾은 데이터의 인덱스가 배열의 길이와 같은지 검사만 해주…","fields":{"slug":"/algo-sentinel-search/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[sentinel-linear-search]","date":"June 21, 2021"}},"next":{"fields":{"slug":"/algo-stack-queue/"}},"previous":{"fields":{"slug":"/algo-hash-table/"}}},{"node":{"id":"b5bd90f1-3369-5815-9656-beaa957871a8","excerpt":"1. 이진 탐색 배열 구조의 자료에서 특정 값을 찾는 방법은 크게 두가지가 있을 수 있다. 순차 탐색 이진탐색 순차 탐색에서는 배열의 시작부터 순차적으로 이동하며 찾고자 하는 특정 값을 모든 배열의 원소들과 비교하며 값을 찾을 때까지 반복한다. 이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘이다. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 출처(https://cjh5414.github.io/binary-search/) 순차 탐색과 이진탐색을 비교해보자. 순차 탐색 array 를 따라가면서 target 이 존재한다면 True 를 반환하고,\n끝까지 없다면 False 를 반환한다. 이진 탐색  1. 이진 탐색 출처(https://cjh5414.github.io/binary-search/) 순차 탐색…","fields":{"slug":"/algo-binary-search/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[binary-search]","date":"June 16, 2021"}},"next":{"fields":{"slug":"/algo-linked-list/"}},"previous":{"fields":{"slug":"/algo-stack-queue/"}}},{"node":{"id":"38302fb5-353b-571c-a9e5-ea8276f3a8d9","excerpt":"알고리즘 공부를 시작하면서 점점 작아지는 내 모습이 안쓰러울 정도이다…처음 개발 공부를 시작할때 들었던 막막함과는 또 다른 느낌이다. 마치 끝이 보이지 않는 어두캄캄한 길을 걸어가는 느낌..다른 사람들은 당연하다고 생각하는 소스코드도 왜이렇게 이해하기가 힘든지..여튼 쉽지않은 하루를 보내고있다. ✏️ 정렬 오늘은 정렬의 여러가지 방법들을 정리하면서 배운 내용들을 다시 한번 돌아보려고 한다. 1. bubble (버블정렬) - O(n²) 버블 정렬에서는 리스트의 원소들을 처음부터 순차적으로 이동하며 인접한 두 원소의 값을 검사하고 작은 값, 또는 큰 값의 위치를 교환하며 정렬해 나가는 방법이다. 1회차의 검사가 완료되면 가장큰 원소가 자료의 맨 마지막 위치로 이동하게 되므로 2회차 검사에서는 마지막 위치의 온소는 제외하고 반목문을 실행한다. 버블 정렬의 장/단점 코드 구현이 쉽다. 최악의 경우 첫번째 위치의 원소가 마지막 위치까지 이동하기 위해서는 배열을 모든 원소들과 검사하고 교환되어…","fields":{"slug":"/algo-sort/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[sorting]","date":"June 14, 2021"}},"next":{"fields":{"slug":"/algo-reverse-string/"}},"previous":{"fields":{"slug":"/algo-linked-list/"}}},{"node":{"id":"70b98f14-868a-5312-90ee-c447c191bd90","excerpt":"1. 문제 0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자를 모두 0, 혹은 모두 1로 같게 만들어야 한다. 할 수 있는 행동은 연속된 하나의 숫자를 잡고 모두 뒤집는 것 이다. 뒤는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다. 주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오. 예제: 예를 들어 S=0001100 일 때, 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다. 접근법: 00011000에서 연속된 하나의 숫자, 즉 연속된 문자열들을 하나의 집합으로 구분하여 생각하자. 예를들어, 00011000은 000 11 000 이렇게 구간별로 나눌 수 있다. 따라서 이 경우에 1이 나오는 구간의 문자열들을…","fields":{"slug":"/algo-reverse-string/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[reverse-zeros-ones]","date":"June 14, 2021"}},"next":{"fields":{"slug":"/algo-prime-number/"}},"previous":{"fields":{"slug":"/algo-sort/"}}},{"node":{"id":"3ea323c0-1f6c-5f8e-aa01-aa2cee893b9a","excerpt":"1.문제 정수를 입력 했을 때, 그 정수 이하의 소수를 모두 반환하시오. 소수는 자신보다 작은 두 개의 자연수를 곱하여 만들 수 없는 1보다 큰 자연수이다. Input = 20 접근법: 소수는 자기와 1외에는 나눌 수 없다. 소수는 2부터 n - 1까지 어떤 소수로도 나누어 떨어지지 않는다.\n(소수인지 확인하고자 하는 수가 n 일때, n이 2와3으로 나누어 떨어지지 않는다면 2x2인 4와 2x3인 6으로도 나누어 떨어지지 않는다.) n의 제좁근 이하의 어떤 소수로도 나누어 떨어지지 않는다. 풀이법: python code: 접근법: 풀이법: python code:","fields":{"slug":"/algo-prime-number/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[prime-numbers]","date":"June 14, 2021"}},"next":{"fields":{"slug":"/algoexpert-non-constructible/"}},"previous":{"fields":{"slug":"/algo-reverse-string/"}}},{"node":{"id":"5397f91a-ba80-55c1-b57b-b84378ced340","excerpt":"문제: Elements of Programming Interviews in python, page 189 Given an array of positive integers (representing coins), find the smallest value that cannot be constructed from those integers. 0이아닌 정수들로 이루어진 배열이 주어진다. 이때 배열 요소들의 합으로 구할 수 없는 수들 중 가장 작은 수를 반환해야 한다. Exmaple 1️⃣ 문제풀이: 배열의 원소들을 오름차순으로 정렬하는것이 중요하다. 오름차순으로 정렬된 정수들의 누적 합계를 구하면 특정 위치에서 구성 가능한 가장 높은 값을 알 수 있다.\n👉 예들들면) sum of [1, 2 ] = 3 이며 조합 가능한 수는 [1, 2, 3]이다. sum of [1, 2, 4] = 7 이며 조합 가능한 수는 [1, 2, 3, 4, 5, 6, 7]이다. sum of [1, 2, 4, 5] = 1…","fields":{"slug":"/algoexpert-non-constructible/"},"frontmatter":{"categories":"algorithm","title":"algoexpert-non-constructible-value","date":"March 24, 2021"}},"next":null,"previous":{"fields":{"slug":"/algo-prime-number/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}