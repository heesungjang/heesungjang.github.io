{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/algorithm",
    "result": {"pageContext":{"currentCategory":"algorithm","categories":["All","algorithm","회고","etc"],"edges":[{"node":{"id":"61b41ba9-fb72-5c22-b074-c31fb247a465","excerpt":"문제:leetcode-46[Permutation] Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. 정수로 이루어진 배열을 입력 값으로 받고 해당 정수를로 조합 가능한 모든 순열을 만드는 문제이다.\n\n순열의 수를 추출하는 건 고등학교 수학 시간에 배웠으며 이산수학에도 등장하는 수식으로 어렵지 않게 계산할 수 있다. 이 예제값의 순열의 수 수식은 이 되고, 분모는 (3-3) !=1 이므로 분자의 팩토리얼factorial만 계산하면 순열의 수는 3!=3×2×1=6이 된다. 하지만 수학식에 대입해서 가능한 경우의 수를 계산하는게 아니라 가능한 모든 조합을 모두 출력하는건 쉽지 않다. 이 문제는 그래프로 접근해야 한다. 위 그림처럼 순열이란 결국 모든 가능한 경우를 그래프 형태로 나열한 결과라고 할 수 있다. 문제풀이: 위 그…","fields":{"slug":"/leetcode-46/"},"frontmatter":{"categories":"algorithm","title":"leetcode(46) - permutation","date":"April 25, 2022"}},"next":{"fields":{"slug":"/leetcode-17/"}},"previous":null},{"node":{"id":"d24cfc06-0f1c-5edd-a57c-7b66ef03226e","excerpt":"문제:leetcode-17(Letter Combinations of a Phone Number) Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 2에서 9까지 숫자가 주어졌을 때 전화 번호로 조합 가능한 모든 문자를 출력하는 문제이다. 대표적인 백트래킹 문제이다. 코드가 짧고 문제를 이해하는데 크게 어려움이 없어서 구현도 쉬울것으로 예상했지만 여러가지 답안지를 보고 이해하는데도 오랜 시간이 걸렸다. 일단 문제 접근 방식은 아래와 같다…","fields":{"slug":"/leetcode-17/"},"frontmatter":{"categories":"algorithm","title":"leetcode(17)- Letter Combinations of a Phone Number","date":"April 23, 2022"}},"next":{"fields":{"slug":"/leetcode-200/"}},"previous":{"fields":{"slug":"/leetcode-46/"}}},{"node":{"id":"2b9832da-cb9c-5a82-a5a2-934fa732b495","excerpt":"문제:leetcode-200(Number of Islands) Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 1을 섬으로, 0을 물로 가정한 2D 그리드 맵이 주어졌을 때, 섬의 개수를 계산하는 문제이다. 1로 표시된 섬은 서로 인접 노드로 연결되어 있다면 하나의 섬으로 처리해야 한다. 👉풀이 접근: 행열 2D 그리드에서 섬은 “1”로 표기되어 있다. 행열을 순회하면서 방문한 위치의 표기가 “1”이라면 섬의…","fields":{"slug":"/leetcode-200/"},"frontmatter":{"categories":"algorithm","title":"leetcode(200)- Number of Islands","date":"April 22, 2022"}},"next":{"fields":{"slug":"/leetcode-739/"}},"previous":{"fields":{"slug":"/leetcode-17/"}}},{"node":{"id":"5f63c36b-7378-5958-9ccb-cbf8312f08c7","excerpt":"문제: leetcode-739(Daily temperatures) Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead. 매일의 온도를 리스트 T로 입력받은 뒤 현재보다 더 따뜻한 날이 올 때까지 며칠이 걸리는지를 구하는 문제다. enumerate를 이용해서 특정 날짜의 인덱스와 온도값을 기억한다 T의 인덱스를 계속해서 스택에 쌓아두면서 현재 온도가 스택에 쌓아둔 마지막 날의 온도보다 높다면 스택을 pop해주고 정답에 i와 pop한…","fields":{"slug":"/leetcode-739/"},"frontmatter":{"categories":"algorithm","title":"leetcode(739)- Daily temperatures","date":"April 19, 2022"}},"next":{"fields":{"slug":"/leetcode-316/"}},"previous":{"fields":{"slug":"/leetcode-200/"}}},{"node":{"id":"9bce0b48-0595-5fc1-af50-a7953428ad3e","excerpt":"문제: remove duplicate letters Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. 코드 구현 자체는 어렵지 않지만, 문자열을 제거하고 순서에 맞게 나열하는 로직을 생각해 내는 건 쉽지 않아 보인다. 두고두고 충분히 습득될 때까지 여러 번 풀어봐야 할 문제이다. 입력값 문자열에서 중복된 문자를 제거하고 **“the smallest in lexicographical order”**으로 중복 제거된 문자열을 반환해야 한다. Lexciographical order란? lexicographical order에 대해 먼저 정확한 이해가 필요해 보인다. 단순히 사전식 정렬, 사전식 오름…","fields":{"slug":"/leetcode-316/"},"frontmatter":{"categories":"algorithm","title":"leetcode(316) - remove-duplicate-letters","date":"April 19, 2022"}},"next":{"fields":{"slug":"/leetcode-2/"}},"previous":{"fields":{"slug":"/leetcode-739/"}}},{"node":{"id":"0a0b817b-b952-5bd9-ac39-518bed8080d8","excerpt":"문제: add-two-numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 미디엄 문제이기는 하지만 풀이가 어렵지는 않은 문제다. 두개의 정수가 역순으로 연결리스트로 주어진다. 역순으로 주어지기 때문에 덧셈 로직을 구현하기 쉽다. 연결 리스트에 역순으로 값이 들어있기 때문에 첫 head 노트부터 덧셈을 하면 우리가 두 수를 더할 때 일의 자리부터 더해서 자릿수…","fields":{"slug":"/leetcode-2/"},"frontmatter":{"categories":"algorithm","title":"leetcode(2) - add-two-number","date":"April 18, 2022"}},"next":{"fields":{"slug":"/leetcode-21/"}},"previous":{"fields":{"slug":"/leetcode-316/"}}},{"node":{"id":"26bc00d2-bf96-5292-ae73-0d3993737640","excerpt":"문제: Merge Two Sorted Lists You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 문제 요약: 각각 정렬되어 있는 리스트 노드 2개를 합쳐서 1개의 정렬된 리스트 노드 출력한다. 유의 사항: 각 리스트 노드가 비어있을 수도 있다. 그러면 빈 리스트 노드를 출력한다. 찾아보면 재귀적으로 list1과 list2의 값을 비교 연산하고 스왑하는 풀이도 있지만 (“파이썬 알고리즘 인터뷰”) 노드들이 스왑되는 과정이 직관적으로 와닿지 않는다. list1과 list2를 순차적으로 비교하면서 작은 노드순으로 dummy n…","fields":{"slug":"/leetcode-21/"},"frontmatter":{"categories":"algorithm","title":"leetcode(21)- Merge Two Sorted Lists","date":"April 16, 2022"}},"next":{"fields":{"slug":"/leetcode-234/"}},"previous":{"fields":{"slug":"/leetcode-2/"}}},{"node":{"id":"0af9277d-8b5a-58b9-88f9-d56644b440df","excerpt":"문제:Palindrome Linked List 입력값으로 들어오는 연결리스트가 팬인 그럼 구조인지 확인하는 문제이다. 어렵지 않은 문제이고 두 번째 풀어보는 문제이지만 slow/fast runner 구현이 정확히 기억나지 않아 일단 deque로 풀고 “파이선 알고리즘 인터뷰”의 runner 풀이를 다시 공부했다. deque를 이용한 문제 풀이는 간단하다. 연결 리스트를 순차적으로 deque에 넣고 popleft()와 pop() 연산을 반복하면서 양 끝에 값을 비교하면 된다.  런너(runner) 기법을 활용하면 해당 연결 리스트 속성을 이용해서 풀 수 있다. 위 그림처럼 slow와 fast 포인터를 시작 head에 위치 시키고 각각 한 칸, 두 칸씩 이동 시키면 빠른 런너가 끝에 다다들 때 느린 런너가 정확히 중간 지점에 도달하게 된다. ❗️이때 느린 런너는 연결 리스트를 이동하면서 지나온 노드들의 값으로 역순 연결 리스트를 생성한다. 이렇게 생성된 역순 연결 리스트는 만약 해당 연…","fields":{"slug":"/leetcode-234/"},"frontmatter":{"categories":"algorithm","title":"leetcode(234)- Palindrome Linked List","date":"April 15, 2022"}},"next":{"fields":{"slug":"/algo-quick-sort/"}},"previous":{"fields":{"slug":"/leetcode-21/"}}},{"node":{"id":"903364a3-94cb-50b0-b846-a38e34810127","excerpt":"퀵 정렬은 병합 정렬과 마찬가지로 분할 정복 알고리즘이다. 병합 정렬과 다른점은 항상 배열의 중앙을 기준을 분활 정복을 하는것이 아닌 **pivot(피벗)**이라는 기준을 만들고 피벗보다 작으면 왼쪽, 크면 오른쪽과 같은 방식으로 partitioning(파티셔닝) 하면서 쪼개 나간다.  피벗을 정하는 기준과 방법이 여럿 있지만 N.로무토가 구현한 파티션 계획에서 소개된 방법으로 항상 맨 오른쪽의 피벗을 택하는 단순한 방식이 가장 간결하고 이해하기 쉽다. 퀵 정렬의 메인 함수는 간단하다. 파티션 함수로 배열을 pivot 기준으로 나누고 재귀 호출하는 전형적인 분할 정복 구조이다. 파티션 함수를 로무토 파티션 계획 방법으로 구현하면 위 코드와 같다. 맨 오른쪽 피벗으로 정하고, 피벗을 기준으로 정렬과 상관없이 단순히 피벗보다 작은 수와, 큰 수들로 배열을 나눈다. for문으로 파티션 함수에 들어온 배열을 순회하면서 right 포인터 값이 피벗보다 작다면 left 포인터 값과 스왑하는 …","fields":{"slug":"/algo-quick-sort/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[퀵 정렬]","date":"April 15, 2022"}},"next":{"fields":{"slug":"/leetcode-53/"}},"previous":{"fields":{"slug":"/leetcode-234/"}}},{"node":{"id":"99b34f9a-06f5-56e1-9c08-5ebafac7db0e","excerpt":"문제:Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. 브루트포스로 O(n^2)을 풀이가 가능한 문제이지만 최대 부분 합을 구하는 유명한 카데인 Kadane’s 알고리즘 풀이가 있다. O(n)에 풀이가 가능하다. 카데인 알고리즘이란? [ 1, -3, -1, 2] 와 같은 수의 나열 “수열”이 주어졌을 때 각 수들을 더했을때 가장 큰 합을 가지는 연속적인 서브 배열을 찾는 알고리즘이다. 카데인 알고리즘은 “이미 구했던 값은 다시 재사용”하는 접근법을 이용하며, Brute Force의 A[0]~A[N-1]의 접근 방법이 아닌 A[N-1]~A[0] 접근 아이디어를 사용한다.  위 그림을…","fields":{"slug":"/leetcode-53/"},"frontmatter":{"categories":"algorithm","title":"leetcode(53)- maximum sub-array[카데안 알고리즘]","date":"April 12, 2022"}},"next":{"fields":{"slug":"/leetcode-15/"}},"previous":{"fields":{"slug":"/algo-quick-sort/"}}},{"node":{"id":"a23481e9-33f4-5e36-b83f-24b95b874ebf","excerpt":"문제: leetcode - 15 (3sum) Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. 배열을 입력받아 합으로 0을 만들 수 있는 3개의 배열 원소를 찾아 반환하는 문제이다. 3개의 원소를 찾아야 하고 브루트 포스로 방식으로 풀이했을 경우 시간 복잡도가 O(n^3)로 당연히 시간 초과가 날 것이다. two sum 또는 two sum2에 사용했던 투 포인터 기법을 응용하면 이 문제도 나름 쉽게 풀이가 가능하다. n개의 숫자리스트가 주어졌을 때 세 수의 합이 0이 되는 세 수를 구해야 한다. 투 포인터 기법을 사용할 것이기 때문에 입력…","fields":{"slug":"/leetcode-15/"},"frontmatter":{"categories":"algorithm","title":"leetcode(15) - 3 sum","date":"April 11, 2022"}},"next":{"fields":{"slug":"/leecode-238/"}},"previous":{"fields":{"slug":"/leetcode-53/"}}},{"node":{"id":"2b33df80-e8f7-51e2-a78a-b4ca45ae9caa","excerpt":"문제: leetcode - 238 (Product of Array Except Self) Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. 이번 문제는 해설을 찾아보지 않았으면 풀이 방법을 생각해내지 못했을 것이다. O(n)의 시간 복잡도 제약이 있기 때문에 브루트포스 방식으로는 풀이가 불가능하며 나눗셈 operator를 사용하지 않고 풀어야 하기 때문에 구해야하는 값은…","fields":{"slug":"/leecode-238/"},"frontmatter":{"categories":"algorithm","title":"leetcode(238) - Product of Array Except Self","date":"April 11, 2022"}},"next":{"fields":{"slug":"/leetcode-819/"}},"previous":{"fields":{"slug":"/leetcode-15/"}}},{"node":{"id":"9c9d5e7a-135d-581e-b38e-dbfa4ba2b797","excerpt":"문제: leetcode - 819 (Most Common Word\n) 코로나 격리중..뭐 할까 고민하다 항해에서 보내준 ‘파이썬 알고리즘 인터뷰’ 완독을 목표로 시작한 리트코드 문제풀기, 아직까지는 문제들이 쉬워서 그런지 재밌다 😅. 이번 문제도 난이도가 높지않지만 파이썬 컴프리헨션과 Counter 클래스를 활용해 볼 수 있는 좋은 문제였다. 알고리즘 준비를 파이썬으로 하겠다고 마음먹고 파이썬 공부를 시작한지 얼마 지나지 않았지만 벌써 푹 빠져버렸다. 문제 해설: Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique. The words in paragra…","fields":{"slug":"/leetcode-819/"},"frontmatter":{"categories":"algorithm","title":"leetcode(819)- Most Common Word","date":"April 10, 2022"}},"next":{"fields":{"slug":"/leetcode-937/"}},"previous":{"fields":{"slug":"/leecode-238/"}}},{"node":{"id":"816ea2bf-180d-51a9-a63b-41dfbb2ea767","excerpt":"문제: leetcode - 937 (Reorder Data in Log Files) You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier. There are two types of logs: Letter-logs: All words (except the identifier) consist of lowercase English - - letters. Digit-logs: All words (except the identifier) consist of digits. Reorder these logs so that: The letter-logs come before all digit-logs. The letter-logs are sorted lexicographically by their contents. If their conte…","fields":{"slug":"/leetcode-937/"},"frontmatter":{"categories":"algorithm","title":"leetcode(937)- Reorder Data in Log Files","date":"April 10, 2022"}},"next":{"fields":{"slug":"/leetcode-49/"}},"previous":{"fields":{"slug":"/leetcode-819/"}}},{"node":{"id":"5d2e21b6-cee2-5699-ad27-e9d7d20ffe25","excerpt":"문제: leetcode - 49 (Group Anagrams) Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 아나그램이란?\n일종의 언어유희로 문자를 재배열하여 다른 뜻을 가진 단어로 바꾸는 것을 말한다. 우리말에도 애너그램을 찾아 볼 수 있다. 예로는 “문적박대”를 “대박전문”으로 바꿔 부르는 단어 등을 들 수 있다. 입력 값으로 주어진 문자들을 정렬하여 비교하면 쉽게 풀이가 가능하다. 애너그램이라는 관계가 각은 알파벳들로 이루어저 있기 때문에 구성하고 있는 알파벳만 같다면 알파벳 구…","fields":{"slug":"/leetcode-49/"},"frontmatter":{"categories":"algorithm","title":"leetcode(49) - Group Anagrams","date":"April 10, 2022"}},"next":{"fields":{"slug":"/leetcode-912/"}},"previous":{"fields":{"slug":"/leetcode-937/"}}},{"node":{"id":"24901e94-bbc5-5310-ba1f-c035cbdada67","excerpt":"1️⃣ 병합 정렬 (merge sort) 병합 정렬은 대표적인 분할 정복(Divide and Conquer) 알고리즘이다. 최선과 최악 모두 **O(n log n)**의 시간 복잡도를 가지는 알고리즘으로 대부분의 경우 퀵 정렬보다는 느리지만 일정한 실행 속도와 안정 **정렬(stable sort)**이기 때문에 여전히 상용 라이브러리에 많이 쓰이고 있다.  병합 정렬의 과정을 도식화한 표를 살펴보자. 분활 정복으로 일정하게 정렬이 이뤄지는 병합 정렬의 특징을 잘 파악할 수 있다. ➗ [38, 27, 43, 3, 9, 82, 10]인 입력값은 —> [38, 27, 43, 3]과 [9, 82, 10]로 두 부분으로 분활, —> 다시 [38, 27], [43, 3], [9, 82], [10] 네부분으로 분활 등의 방식으로 각가 더 이상 쪼갤 수 없을 때까지 계속해서 분활한 후, 분활이 끝나면 정렬하면서 정복해 나간다. 2️⃣ 예시 문제: 문제: leetcode - 912 (sort array)…","fields":{"slug":"/leetcode-912/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[병합정렬]-[leet code 191]","date":"April 09, 2022"}},"next":{"fields":{"slug":"/leecode-125/"}},"previous":{"fields":{"slug":"/leetcode-49/"}}},{"node":{"id":"df4b3ca4-c53a-5a43-bd3d-de3ad2f3106a","excerpt":"문제: leetcode - 125 (Valid Palindrome) A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. 입력으로 주어지는 문자열이 팰린드롬인지 확인하고 True 또는 False를 반환하는 문제이다. 여러가지 방식으로 풀이를 작성하고 제출한 결과 투 포인터를 사용한 풀이가 가장 빠르게 나왔다. 1️⃣ 문제풀이(list): 가장 느림. pop(0)가 O(n)이라 결국 O(n^2)이기 때문에 …","fields":{"slug":"/leecode-125/"},"frontmatter":{"categories":"algorithm","title":"leetcode(125)- valid palindrome","date":"April 09, 2022"}},"next":{"fields":{"slug":"/leetcode-344/"}},"previous":{"fields":{"slug":"/leetcode-912/"}}},{"node":{"id":"363d1ae1-fe29-5f0a-a2d6-0c8364927c01","excerpt":"문제: leetcode - 344 (Valid Palindrome) 주어지는 문자 배열을 리턴 없이 리스트 내부를 직접 조작하여 원소들을 뒤집는 문제이다. pythonic하게 문제를 푼다면 아래와 같이 한줄로 풀이가 가능하다. 투 포인터 방식도 제출해서 시간을 비교해봤지만 크게 차이는 없다.  1️⃣ 문제풀이: 2️⃣ 문제풀이: 1️⃣ 문제풀이: 2️⃣ 문제풀이:","fields":{"slug":"/leetcode-344/"},"frontmatter":{"categories":"algorithm","title":"leetcode(344)- reverse string","date":"April 08, 2022"}},"next":{"fields":{"slug":"/회고-자바스크립트-공부/"}},"previous":{"fields":{"slug":"/leecode-125/"}}},{"node":{"id":"2e023ceb-d13f-595e-884f-8ed4534cc0ac","excerpt":"🛁 버블 정렬 구현하기 버블 정렬은 기본적으로 O(N^2)의 시간 복잡도를 가지는 알고리즘이다. 실제 코딩 테스트에서 O(N^2) 알고리즘을 사용하거나 구현할 일은 없겠지만 기본적인 정렬 알고리즘들을 정리하고 개념을 익혀 놓는게 좋을 것 같다. 알고리즘 구현 자체는 크게 어려운 부분이 없다. 버블 정렬은 이름과 같이 물속에서 거품이 올라오는 모양과 비슷하다고 해서 버블 정렬이라고 한다. 배열을 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽 방향으로 이동하면서 이웃한 앞뒤 원소의 값을 비교하고 앞 원소의 값이 더 크다면 두 원소의 자리를 교환(swap)하는 작업을 반복한다.  알고리즘 데이터의 수를 N이라고 하자. 버블 정렬 알고리즘은 아래의 과정을 N번 반복할 것이다. 배열의 0번 칸의 숫자가 1번칸의 숫자 보다 크다면 두 값의 위치를 교환한다. 배열의 1번 칸의 숫자가 2번칸의 숫자 보다 크다면 두 값의 위치를 교환한다. … 배열의 N-2번 칸의 숫자가 N-1 칸의 숫자 보다 크다면 두 …","fields":{"slug":"/algo-bubble-sort/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[버블정렬]","date":"April 05, 2022"}},"next":{"fields":{"slug":"/algo-prime-number/"}},"previous":{"fields":{"slug":"/회고-자바스크립트-공부/"}}},{"node":{"id":"3ea323c0-1f6c-5f8e-aa01-aa2cee893b9a","excerpt":"보통 소수 찾기 문제에서 소수의 정의를 같이 제공하기 때문에 반복문으로 충분히 풀이가 가능하다. 그치만 약수가 가지는 특징을 이용하면 성능 개선이 가능하다. 알고리즘 문제를 풀기 위해서 특정 문제에서만 사용되는 지엽적인 지식들은 모두 알고 있을 수 없지만 코딩 테스트에서 특정 자연수가 소수인지 판별하는 문제가 자주 출제되기 때문에 소수에 대한 성질은 짚고 넘어가고자 한다. 1️⃣ 소수란: 소수란 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로 나누어 떨어지지 않는 자연수이다.\ne.g) 6은 1, 2, 3, 6으로 나누어 떨어지므로 소수가 아니다.\ne.g) 7은 1과 7을 제외하고는 나누어 떨어지지 않으므로 소수이다. 소수 정의에 주어진 조건만으로 반복문을 통해서 소수를 판별해보자. 기본 풀이: 소수 판별을 위한 연산량을 생각해보자. 주어진 자연수 n이 10억이라고 한다면 해당 자연수가 소수인지 판별하기 위해서 2부터 10억 - 1까지 반복문 안에 로직을 실행한다. 즉, 2부…","fields":{"slug":"/algo-prime-number/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[소수]","date":"April 04, 2022"}},"next":{"fields":{"slug":"/algo-avoid-float-number/"}},"previous":{"fields":{"slug":"/algo-bubble-sort/"}}},{"node":{"id":"390e96e0-3bd7-5724-a676-285b515886f7","excerpt":"파이썬에서 0.1 + 0.2의 값은 얼마일까? 🤔 0.3이 나올 것 같지만 실제 계산 값은 0.30000000000000004가이 나온다. 파이썬은 실수를 부동 소수점 방식으로 표현하기 때문에 실수를 정확히 표현하는 것이 가능하지 않다. 만약 두 실수가 같은지 판단할 때 다음과 같이 0.1 + 0.2와 0.3은 같지 않다고 나온다. 이렇게 실수를 근삿값으로 표현하면서 발생하는 문제를 부동소수점 반올림 **오차(rounding error)**가 발생하기 때문에 실수를 비교할 때는 연산한 값과 비교할 값의 차이를 구한 뒤 특정 오차 범위 안에서 같은지 확인해야 한다. 파이썬 3.5이상부터는 두 실수가 같은지 판단할 때 math.isclose 함수를 사용 할 수 있다. ❗️ 알고리즘 문제를 풀 때도 실수를 비교하는 조건 연산이 있다면 실수 계산을 피할 수 있는지 고려해보는 것이 좋다. 예시: 위 예시는 데이터는 -100,000 이상 100,000 이하의 정수를도 이루어진 배열이 주어진다.…","fields":{"slug":"/algo-avoid-float-number/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[실수 연산을 피하자]","date":"April 01, 2022"}},"next":{"fields":{"slug":"/algo-selection-sort/"}},"previous":{"fields":{"slug":"/algo-prime-number/"}}},{"node":{"id":"be99792c-2788-5798-9815-55e4eb4ae781","excerpt":"👉 선택 정렬 구현하기 ♻️ 반복하는 과정: 주어진 범위에서 최소 값의 위치를 찾는다. 최소 값을 해당 범위의 가장 앞 숫자와 자리를 바꾼다. 이후, 해당 범위의 가장 앞 자리를 제외한 나머지 범위에 대해 위의 과정을 반복한다. 입력으로 주어진 원본 배열 A와 이를 오름차순으로 정렬한 배열 B가 있다고 하자. 원소의 순서가 다를 뿐 두 배열은 집합적으로는 같은 집합이다.  즉, 특정 인덱스 k에 대하여 배열 B의 원소 b[k]는 오름차순으로 (k+1)번째로 작은 값 이다.  위에 정렬 과정은 아래와 같이 집합으로 표현이 가능하다. 𝑏0=𝑀𝑖𝑛𝐴 =𝑀𝑖𝑛(𝐵)\n𝑏1 =𝑀𝑖𝑛 𝐴−{𝑏0} =𝑀𝑖𝑛(𝐵−{𝑏0})\n𝑏2 =𝑀𝑖𝑛 𝐴−{𝑏0,𝑏1} =𝑀𝑖𝑛(𝐵−{𝑏0,𝑏1}) b0의 값은 배열 A에서 가장 작은 값이된다. b1의 값은 b0을 뺀 배열 A에서 가장 작은 값이된다.\n… 이렇게 작은 숫자부터 차례로 나열하면, 오름차순으로 배열이 정렬된다. 예제 코드: 👉 선택 정렬 구현하기 예제 …","fields":{"slug":"/algo-selection-sort/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[선택 정렬]","date":"March 29, 2022"}},"next":{"fields":{"slug":"/leetcode-322/"}},"previous":{"fields":{"slug":"/algo-avoid-float-number/"}}},{"node":{"id":"4e0d5e1b-9044-5dc7-94ca-9650368e76dd","excerpt":"문제: leetcode - 322 (Binary Search) You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. 어느 파이썬 알고리즘 책에서는 해당 문제를 소개하면서 “거스름돈” 문제를 대표적인 그리디 알고리즘이라고 설명한다. 맞다. 그치만 반만 맞다. 그리디하게 해당 문제를 풀…","fields":{"slug":"/leetcode-322/"},"frontmatter":{"categories":"algorithm","title":"leetcode(322)- Coin change","date":"March 28, 2022"}},"next":{"fields":{"slug":"/leetcode-704/"}},"previous":{"fields":{"slug":"/algo-selection-sort/"}}},{"node":{"id":"42f94a9b-9d06-5a6a-8566-857441429a96","excerpt":"문제: leetcode - 704 (Binary Search) Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. 기본적인 이진탐색 문제이다. 정렬된 배열에 중간 값을 찾아서 찾고자 하는 값(target)과 비교한다. 중간 값보다 검색 값이 크다면 중간값 기준 배열의 오른쪽 구간을 대상으로 탐색한다. (mid < key) 중간 값보다 검색 값이 작다면 중간값 기준 배열의 왼쪽 구간을 대상으로 탐색한다. (mid > key) 1️⃣ 문제풀이1(반복문): 2️⃣ 문제풀이2(재귀)): 1️⃣ …","fields":{"slug":"/leetcode-704/"},"frontmatter":{"categories":"algorithm","title":"leetcode(704)- Binary search","date":"March 26, 2022"}},"next":{"fields":{"slug":"/etc-open-source/"}},"previous":{"fields":{"slug":"/leetcode-322/"}}},{"node":{"id":"2ee7b41e-a815-5c88-9f47-b2918012f09b","excerpt":"문제: leetcode - 83 (Remove Duplicates from Sorted List) Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 1️⃣ 문제풀이: 정렬된 단일연결리스트를 순회하며 중복(동일값) 여부를 확인하여 제거한다. 반복문과 포인터를 이용하여 LinkedList를 순회하면서 현재노드와 다음 노드의 값이 같은경우 현재노드의 다음노드를 다다음노드로 연결한다. 중복이 발생하는 마지막 노드까지 이동하여 해당 노드의 next 노드 즉, 중복이 아닌 새롭게 시작되는 값을 가진 노드를 현재 head 다음 노드로 연결해준다. 아닐 경우 포인터를 앞으로 한칸 이동시켜 head 노드를 이동시켜준다. 1️⃣ 문제풀이:","fields":{"slug":"/leetcode-83/"},"frontmatter":{"categories":"algorithm","title":"leetcode(83)- Remove Duplicates from Sorted List","date":"March 25, 2022"}},"next":{"fields":{"slug":"/leetcode-88/"}},"previous":{"fields":{"slug":"/etc-open-source/"}}},{"node":{"id":"8b82364b-2829-556f-8cd7-348af94b4575","excerpt":"문제: leetcode - 88 (Merge sorted array) 오름차순으로 정렬된 정수들로 이루어진 2개의 배열 nums1과 nums2가 입력값으로 주어진다. 그냥보면 병합정렬 문제이다. 특이한점이 있다면 return 값으로 병합된 배열을 반환하지 않고 초기에 주어진 nums1에 직접 병합을 해야한다. 예시:  1️⃣ 문제해설 1: 처음에 지문을 읽고는 뭐지..?라는 생각이 들었다. 첫번째로 nums1을 보면 정렬된 정수들뒤로 nums2의 길이만큼 0으로 공간이 초기화되어 있고 배열 내 병합할 원소의 개수를 의미하는 m, n이 주어진다. 결론부터 말하면 sorting 없이 포인터를 지정해서 배열의 병합이 가능하다. 해당 문제풀이는 discussion에서 다른 사람의 코드를 가져왔다. 문제해설2에서 다루겠다. 정렬을 신경쓰지 않고, nums2에 있는 모든 요소들을 nums1에 넣어준다. list.sort()로 오름차 정렬을 시켜준다. 시간 복잡도: 파이썬의 sort() 함수가 O…","fields":{"slug":"/leetcode-88/"},"frontmatter":{"categories":"algorithm","title":"leetcode(88)- Merge sorted array","date":"March 23, 2022"}},"next":{"fields":{"slug":"/leecode-151/"}},"previous":{"fields":{"slug":"/leetcode-83/"}}},{"node":{"id":"613d8fb0-b581-5f32-899d-e58f0f08d9f2","excerpt":"문제: leetcode - 151 (Reverse Words in a String) 🎉 기분이 좋은 밤이다. 블로그에 현재까지 정리한 문제풀이는 지금 작성하고 있는 리트코드 151번 문제를 포함해서 3개밖에 되지 않지만 벌써 3주째 하루에 한 문제씩 알고리즘 문제를 풀고있다. 아직까지 Hard level의 문제는 시도조차 하지 않고 있고 easy 또는 Medium level의 문제 위주로 풀고있다. 1️⃣ 문제풀이1: 파이썬의 내장함수인 strip() 사용해서 좌우 여백을 제거한다.. 여백이 제거된 문자열을 반복문으로 이동하면서 공백이 나오기전까지 모든 문자들을 temp_string에 임시로 저장한다. 공백이 나오면 새로운 단어가 시작되는 구간이기 때문에 현재 temp_string에 저장된 문자열을 words에 추가하고 temp_string을 다시 초기화 해준다. 마지막 단어 다음에는 공백이 존재하지 않기 때문에 반복문이 끝나면 temp_string에 저장된 마지막 문자열을 words…","fields":{"slug":"/leecode-151/"},"frontmatter":{"categories":"algorithm","title":"leetcode(151)- Reverse Words in a String","date":"March 22, 2022"}},"next":{"fields":{"slug":"/leetcode-509/"}},"previous":{"fields":{"slug":"/leetcode-88/"}}},{"node":{"id":"8c65d29f-84d9-56f2-8510-ab52304106e9","excerpt":"문제: leetcode - 509 (피보나치 수열) 일반적으로 F(n)로 표기하며 피보나치 숫자는 피보나치 수열 이라고 불리는 수열를 형성하며, 각 숫자는 0과 1에서 시작하는 앞의 두 숫자의 합이된다. 즉, 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 이다. 예시: F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 n=5일경우 피보나치 수열을 나열해보면 [0, 1, 1, 2, 4, 5] 형태로 나열된다. 사실 이 문제는 필요한 식을 제공하기 때문에 피보나치 수열을 알고있지 않더라도 풀이가 가능하다. 1️⃣ 문제풀이 1 (recursion) 피보나치 수열 문제는 재귀함수를 소개하는 입문 영상에서 많이 다뤄지는 대표적인 문제이다…","fields":{"slug":"/leetcode-509/"},"frontmatter":{"categories":"algorithm","title":"leetcode(509)- Fibonacci number","date":"March 21, 2022"}},"next":{"fields":{"slug":"/leetcode-20/"}},"previous":{"fields":{"slug":"/leecode-151/"}}},{"node":{"id":"08fd98ab-1a03-5af1-a296-d4fc8d35a4c6","excerpt":"문제: leetcode -20 (valid parentheses) 이번 문제의 난이도는 easy이고 스택을 이용하는 대표적인 문제이다. 문제 풀이를 위해서 스택의 구현이 직접 필요하지 않으며 python 리스트로 충분히 구현이 가능하다. pop() 연산만이 필요하기 때문에 데크를 이용한 풀이와 시간적으로 차이가 없다. 입력 값으로 괄호로 구성된 문자열이 주어진다. 주어진 문자열을 검사해서 모든 괄호들이 올바르게 닫혀 있는지 확인하여 bool 타입의 결과 값을 리턴 해줘야 한다. 여기서 올바르게 닫혀있는 괄호란 (){}이나 ({}) 같이 닫는 괄호가 나올 때 제일 최근에 있는 여는 괄호와 매칭된 형태이다. ✅ 올바르게 닫힌 괄호 예시: () ({}) {{([])}} ❌ 올바르게 닫히지 않은 예시: (( ((]) ]] ({[)}) 문제풀이: 이 문제의 풀이는 간단하다. 첫번째로 주어진 문자열을 반복문으로 왼쪽에서부터 오른쪽으로 이동한다. 열린 괄호가 나오면 스택에 넣는다. 만약 닫힌 …","fields":{"slug":"/leetcode-20/"},"frontmatter":{"categories":"algorithm","title":"leetcode(20)- Valid parentheses","date":"March 21, 2022"}},"next":{"fields":{"slug":"/algo-hash-table/"}},"previous":{"fields":{"slug":"/leetcode-509/"}}},{"node":{"id":"b73e5d13-5030-5ce7-b1d2-5a706e1aae45","excerpt":"#️⃣ 해시 👨‍🏫 해쉬 테이블(Hash Table)은 “키” 와 “데이터”를 저장함으로써 즉각적으로 데이터를 받아오고 업데이트하고 싶을 때 사용하는 빠른 검색과 저장이 특징인 자료구조이다. 해시 테이블의 형태의 자료구조는 여러 언어에서 이미 우리가 많이 사용하고 있다. 자바스크립트의 오브젝트 또는 파이썬의 딕셔너리를 해시 테이블과 같다고 보면 된다 (사실 완저히 같다고 할 수는 없지만 현재로서는 이렇게 이해하는게 가장 좋을거 같다). “데이터를 빠르게 검색할 수 있다”라는 해시 테이블의 장점은 우리가 딕셔너리에서 또는 자바스크립트 오브젝트에서 index가 아닌 key 값으로 특정 데이터에 접근할 때를 생각하면 된다. 예를 들어서 위에 예시로 작성한 dict 오브젝트에 2개의 데이터 쌍이 아닌 100개의 key value 쌍의 데이터가 있다고 생각해보자. 아무리 많은 데이터가 있어도 key 값만 가지고 있다면 바로 원하는 데이터에 접근할 수 있고 따라서 해시테이블의 평균 시간복잡도는 O(…","fields":{"slug":"/algo-hash-table/"},"frontmatter":{"categories":"algorithm","title":"Hash table","date":"November 09, 2021"}},"next":{"fields":{"slug":"/algo-sentinel-search/"}},"previous":{"fields":{"slug":"/leetcode-20/"}}},{"node":{"id":"5225a0a2-941e-53ab-975f-368d705f85f7","excerpt":"보초법 (sentinel method) 여러가지 배열 검색 방법들중 선형검색은 배열의 처음부터 마지막 또는 찾고자 하는 데이터가 나올때까지 순차적으로 모든 데이터를 비교하는 방법이다. 간단한 코드 예제 위 선형 검색은 루프가 반복할 때마다 2가지 종료 조건을 체크한다. 단순한 판단이지만 이 과정을 계속 반복하면 종류 조건을 검사하는 cost를 무시할 수 없다. 선형 검색의 종류 조건 i == len(l)가 성립하면 (실패) a[i] == value가 성립하면 (성공) 이과정을 줄여주는 것이 보초법(sentinel method)이다.  검색하고자 하는 키값을 배열의 맨 끝에 넣어준다. 이때 저정하는 값을 보초라고 한다. 위 그림에서 볼 수 있듯이, 기존 데이터에 찾고자하는 키 값이 존재하지 않아도, 보초를 통해 검색할 값을 찾았나?라는 질문에 True를 반환하게된다. 이렇게 if 조건을 하나 단축할 수 있으며, return에서 찾은 데이터의 인덱스가 배열의 길이와 같은지 검사만 해주…","fields":{"slug":"/algo-sentinel-search/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[sentinel-linear-search]","date":"June 21, 2021"}},"next":{"fields":{"slug":"/algo-stack-queue/"}},"previous":{"fields":{"slug":"/algo-hash-table/"}}},{"node":{"id":"6caa77ca-b476-51ff-9633-b8ecf898d197","excerpt":"✏️ 스택 (stack) 스택은 후입선출 구조 (LIFO, Last In First Out) 구조라고 해서 한쪽 끝으로만 자료를 넣고 뺄 수 있는 자료 구조이다. 스택이 사용되는 예시 컴퓨터의 되돌리기(Ctrl + Z) 기능: 직전에 했던 행동을 되돌고 싶을 때 사용하는 기능으로, 이를 위해서는 내가 했던 행동들을 순서대로 기억해야 하므로 스택을 사용한다. 📌 특징 스택은 위의 사진처럼 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을수 있으며 데이터 접근 또한 데이터가 삽입된 top을 통해서만 접근이 가능하다. 스택의 가장 상위에 위치하는 자료는 가장 최근에 들어온 자료이며, 새로 삽입되는 자료는 top이 가리키는 자료의 위에 쌓이게 된다. 스택에서 자료를 삭제할 때도 top을 통해서만 가능하다. 스택에서 top을 통해 삽입하는 연산을 **‘push’ , top을 통한 삭제하는 연산을 ‘pop’**이라고 한다. 스택 자료구조의 기능들을 코드로 직접 구현해보자. 1. Push: 맨 …","fields":{"slug":"/algo-stack-queue/"},"frontmatter":{"categories":"algorithm","title":"Stack & Queue","date":"June 20, 2021"}},"next":{"fields":{"slug":"/algo-binary-search/"}},"previous":{"fields":{"slug":"/algo-sentinel-search/"}}},{"node":{"id":"b5bd90f1-3369-5815-9656-beaa957871a8","excerpt":"1. 이진 탐색 배열 구조의 자료에서 특정 값을 찾는 방법은 크게 두가지가 있을 수 있다. 순차 탐색 이진탐색 순차 탐색에서는 배열의 시작부터 순차적으로 이동하며 찾고자 하는 특정 값을 모든 배열의 원소들과 비교하며 값을 찾을 때까지 반복한다. 이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘이다. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 출처(https://cjh5414.github.io/binary-search/) 순차 탐색과 이진탐색을 비교해보자. 순차 탐색 array 를 따라가면서 target 이 존재한다면 True 를 반환하고,\n끝까지 없다면 False 를 반환한다. 이진 탐색  1. 이진 탐색 출처(https://cjh5414.github.io/binary-search/) 순차 탐색…","fields":{"slug":"/algo-binary-search/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[이진탐색]","date":"June 16, 2021"}},"next":{"fields":{"slug":"/algo-linked-list/"}},"previous":{"fields":{"slug":"/algo-stack-queue/"}}},{"node":{"id":"92358c06-06d0-5609-90b0-6e7f475873a3","excerpt":"링크드 리스트란?  링크드 리스트는 기존 배열 구조와 마찬가지로 선형 데이터 자료구조를 가진다. 배열에서는 담고있는 데이터 자체가 연속적으로 저장되어 있다면, 링크드리스트는 노드들이 포인터를 통해 연결 관계를 유지하는 리스트이며, 노드는 데이터를 저장하는 부분, 다음 노드를 가르키는 부분으로 구성되어있다. 링크리스트 장/단점: 장점 삽입과 삭제가 O(1)에 이루어진다. 삽입과 삭제를 할 때마다 동적으로 링크드 리스트의 크기가 결정되므로 전통적인 배열(Array)에 비해 처음부터 큰 공간을 할당할 필요가 없어진다. 메모리 관리가 용이하다. 단점 Random Access, 즉 배열처럼 index를 통해 탐색이 불가능하다. 탐색이 O(N)이 걸린다. (Head부터 Tail까지 모두 탐색 시) 사실상 삽입과 삭제가 왼쪽에서(Head에서) 이루어지지 않을 경우, 결국 탐색을 먼저 해야 하기 때문에 삽입과 삭제 모두 적게는 O(k)부터 최악의 경우 O(N)까지 걸릴 가능성이 있다. (출처: …","fields":{"slug":"/algo-linked-list/"},"frontmatter":{"categories":"algorithm","title":"Linked list","date":"June 15, 2021"}},"next":{"fields":{"slug":"/algo-sort/"}},"previous":{"fields":{"slug":"/algo-binary-search/"}}},{"node":{"id":"38302fb5-353b-571c-a9e5-ea8276f3a8d9","excerpt":"알고리즘 공부를 시작하면서 점점 작아지는 내 모습이 안쓰러울 정도이다…처음 개발 공부를 시작할때 들었던 막막함과는 또 다른 느낌이다. 마치 끝이 보이지 않는 어두캄캄한 길을 걸어가는 느낌..다른 사람들은 당연하다고 생각하는 소스코드도 왜이렇게 이해하기가 힘든지..여튼 쉽지않은 하루를 보내고있다. ✏️ 정렬 오늘은 정렬의 여러가지 방법들을 정리하면서 배운 내용들을 다시 한번 돌아보려고 한다. 1. bubble (버블정렬) - O(n²) 버블 정렬에서는 리스트의 원소들을 처음부터 순차적으로 이동하며 인접한 두 원소의 값을 검사하고 작은 값, 또는 큰 값의 위치를 교환하며 정렬해 나가는 방법이다. 1회차의 검사가 완료되면 가장큰 원소가 자료의 맨 마지막 위치로 이동하게 되므로 2회차 검사에서는 마지막 위치의 온소는 제외하고 반목문을 실행한다. 버블 정렬의 장/단점 코드 구현이 쉽다. 최악의 경우 첫번째 위치의 원소가 마지막 위치까지 이동하기 위해서는 배열을 모든 원소들과 검사하고 교환되어…","fields":{"slug":"/algo-sort/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[정렬기초]","date":"June 14, 2021"}},"next":{"fields":{"slug":"/algo-reverse-string/"}},"previous":{"fields":{"slug":"/algo-linked-list/"}}},{"node":{"id":"70b98f14-868a-5312-90ee-c447c191bd90","excerpt":"1. 문제 0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자를 모두 0, 혹은 모두 1로 같게 만들어야 한다. 할 수 있는 행동은 연속된 하나의 숫자를 잡고 모두 뒤집는 것 이다. 뒤는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다. 주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오. 예제: 예를 들어 S=0001100 일 때, 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다. 접근법: 00011000에서 연속된 하나의 숫자, 즉 연속된 문자열들을 하나의 집합으로 구분하여 생각하자. 예를들어, 00011000은 000 11 000 이렇게 구간별로 나눌 수 있다. 따라서 이 경우에 1이 나오는 구간의 문자열들을…","fields":{"slug":"/algo-reverse-string/"},"frontmatter":{"categories":"algorithm","title":"Algorithm[reverse-zeros-ones]","date":"June 14, 2021"}},"next":{"fields":{"slug":"/algoexpert-non-constructible/"}},"previous":{"fields":{"slug":"/algo-sort/"}}},{"node":{"id":"5397f91a-ba80-55c1-b57b-b84378ced340","excerpt":"문제: Elements of Programming Interviews in python, page 189 Given an array of positive integers (representing coins), find the smallest value that cannot be constructed from those integers. 0이아닌 정수들로 이루어진 배열이 주어진다. 이때 배열 요소들의 합으로 구할 수 없는 수들 중 가장 작은 수를 반환해야 한다. Exmaple 1️⃣ 문제풀이: 배열의 원소들을 오름차순으로 정렬하는것이 중요하다. 오름차순으로 정렬된 정수들의 누적 합계를 구하면 특정 위치에서 구성 가능한 가장 높은 값을 알 수 있다.\n👉 예들들면) sum of [1, 2 ] = 3 이며 조합 가능한 수는 [1, 2, 3]이다. sum of [1, 2, 4] = 7 이며 조합 가능한 수는 [1, 2, 3, 4, 5, 6, 7]이다. sum of [1, 2, 4, 5] = 1…","fields":{"slug":"/algoexpert-non-constructible/"},"frontmatter":{"categories":"algorithm","title":"algoexpert-non-constructible-value","date":"March 24, 2021"}},"next":null,"previous":{"fields":{"slug":"/algo-reverse-string/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}