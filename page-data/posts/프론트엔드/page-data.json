{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/프론트엔드",
    "result": {"pageContext":{"currentCategory":"프론트엔드","categories":["All","프론트엔드","자료구조","알고리즘","자바스크립트"],"edges":[{"node":{"id":"08f07edf-0a24-5cfe-8ef3-1b8df19fd525","excerpt":"클라이언트에서 외부 데이터가 필요할때 즉, 서버에 api 요청을 보내야할때 axios를 계속해서 사용 해 왔다. 그러다 얼마 전 회사에서 신규 프로젝트를 next로 개발하게 되었는데 graphql 서버와 통신하기 때문에 해당 프로젝트에서는 자연스럽게 apollo-client를 사용했지만 next 공부를 위해서 공식 문서를 둘러보다 SWR에 대해서 알게 되었다. 요즘 리액트 진영에서 핫한? 프레임워크 이기때문에 Next.js가 클라이언트 및 서버 측 렌더링을 모두 지원하는 것을 알고 있을 것이다. Next에서는 데이터를 가져오는 여러 가지 방법을 제공하는데 그중 하나가 next가 직접 개발한 SWR이다. 이며 SWR을 사용하면 컴포넌트는 지속적이며 자동으로 데이터 업데이트 스트림을 받게 되고 그로인해 UI는 항상 빠르고 반응한다고 소개한다. 이번 글에서는 기본적인 SWR 개념 및 사용법과 SWR이 제공하는 caching, pagination, revalidation 등의 기능을 살펴…","fields":{"slug":"/Swr/"},"frontmatter":{"categories":"프론트엔드","title":"Next에서 데이터 호출하기","date":"November 20, 2021"}},"next":{"fields":{"slug":"/hash-table/"}},"previous":null},{"node":{"id":"e36af930-c6cd-5d7d-a08a-38702d56e39d","excerpt":"⚠️ 작성이 완료되지 않은 글입니다.  “You can throw paint against the wall and eventually you might get most of the wall, but until you go up to the wall with a brush, you’ll never get the corners. 🖌️ ” Whate is testing? 소프트웨어 관점에서의 테스트는 애플리케이션이 개발자가 설계한 요구 사항에 맞게 작동하는지 검증하는 과정이다. 테스트는 모든 개발이 끝났을때와 같이 특정 개발 단계에서 이루어지는 것이 아니며 모든 개발 과정의 각 단계에서 꾸준이 이뤄진다. 프로토타입핑 단계에서 UX를 미리 검증하거나 API 통신중에 요청 또는 응답의 값을 확인하는 것, 마크업이 끝난 후 디자인 시안과 비교해보는 것 등이 모두 테스트에 해당한다. 테스트 과정은 전체적인 작업 흐름의 속도를 올려 개발을 빠르게 진행하기 위해, 그리고 새로운 변경 사항이 발생했을때…","fields":{"slug":"/javascriptTesting/"},"frontmatter":{"categories":"프론트엔드","title":"Static vs Unit vs Integration vs E2E","date":"October 15, 2021"}},"next":{"fields":{"slug":"/lazy-state-initialization/"}},"previous":{"fields":{"slug":"/hash-table/"}}},{"node":{"id":"95069640-4401-5162-80c7-2e449c925977","excerpt":"Lazy initialization 🥱 <지연 초기 state> 리액트에서 특정 함수나 실행 시간이 오래 걸리는 값 비싼 연산이 필요할때 useCallback이나 useMemo로 최적화를 한다. 이번 블로그에서는 useState을 사용해서 초기 상태(state) 값을 할당할때 값 비싼 연산이 필요한 함수를 이런식으로 바로 파라미터로 전달하면 발생하는 문제점과 해결 방법을 정리해보자. 예시🕵️‍♀️  사용자가 Input창에 이름을 입력하면 입력 값을 name 값에 업데이트하고 Hello {name}으로 사용자가 입력한 이름을 화면에 그려주는 간단한 컴포넌트이다. 새로고침 이후에도 사용자가 마지막으로 입력한 값을 화면에 그려주기 위해서 useEffect의 의존 값을 name을 설정하고 name 값의 변화를 감지하면 localStorage에 저장하고 컴포넌트가 리랜더링되면 useState에서 getLocalStorageValue() 함수를 통해서 로컬스토리지 값을 초기 name 값으로 설정한다…","fields":{"slug":"/lazy-state-initialization/"},"frontmatter":{"categories":"프론트엔드","title":"useState 지연 초기 state(lazy state initialization)","date":"October 08, 2021"}},"next":{"fields":{"slug":"/react-and-dom-api/"}},"previous":{"fields":{"slug":"/javascriptTesting/"}}},{"node":{"id":"9c01a101-356d-5b3c-b596-bdc489812583","excerpt":"다들 처음 프로그래밍 언어 또는 웹 개발을 공부를 시작하면서 그 유명한 **“hello, world”**를 터미널 또는 브라우저에 찍어본 경험이 있을꺼다. DOM과 HTML을 어느정도는 알고있다면 “Hello, World”를 브라우저 화면에 쉽게 출력할 수 있을꺼라 생각한다. 또한 스크립트 태그 안에서 자바스크립트 코드를 통해 DOM 조작을하고 웹 페이지와 상호작용을 할 수 있다. 다양한 웹 프레임워크가 나오기 이전에는 서버에서 HTML을 생성하고 브라우저와 상호작용을 하기 위해 HTML 위에 자바스크립트 코드를 추가했다. 하지만 이러한 방식은 웹 페이지가 복잡해지고 개발적으로 요구사항이 까다로워지면서 유지보수나 성능 측면에서 문제가 발생하기 시작했고 이를 해결하기 위해 우리가 알고있는 vue나 react같은 다양한 웹 프레임워크가 등장했다. 만약 지금 리액트를 사용하지 않고 서비스를 만들어여 한다면…🥲 그만큼 리액트가 좋다 😅 그래서 뭐 DOM이 왜? 리액트는 세계에서 가장 널리…","fields":{"slug":"/react-and-dom-api/"},"frontmatter":{"categories":"프론트엔드","title":"react 컴포넌트와 DOM api","date":"October 07, 2021"}},"next":{"fields":{"slug":"/react-key-props/"}},"previous":{"fields":{"slug":"/lazy-state-initialization/"}}},{"node":{"id":"fee095e6-46de-5368-80fd-1ffeb245e06a","excerpt":"리액트 개발을 해봤다면 배열을 렌더링 할때 위와 같은 ❌ 경고 메세지를 한번쯤 봤을거다. 이번 시간에는 리액트 Element에 왜 key props가 필요하고 어떤 점을 주의해야 하는지 알아보자. 🤔 조정(Reconciliation) 리액트 문서를 먼저 살펴보자: Key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕습니다. key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 합니다. 리액트 공식 가이드에 따르면 key props가 컴포넌트의 변화가 생겼을때 어떤 항복을 변경, 추가, 삭제할지 돕는다고 한다. 컴포넌트의 상태 값이 변경되면 렌더링 함수는 이전 요소와 현재 요소의 트리를 반환한다. React는 가장 최근의 변경 사항으로 UI를 효율적으로 업데이트하기 위해 어떤 차이가 있는지 파악해야 하고, 이 두 트리를 일치시키는 프로세스를 **조정(Reconciliation)**이라고 한다. 이때 변경 사항만 기존 render…","fields":{"slug":"/react-key-props/"},"frontmatter":{"categories":"프론트엔드","title":"리액트 key props 자세히 알아보기","date":"September 23, 2021"}},"next":{"fields":{"slug":"/jsx-and-react-component/"}},"previous":{"fields":{"slug":"/react-and-dom-api/"}}},{"node":{"id":"86255346-ebbd-513f-a534-e8e6bd4f6694","excerpt":"참고: Kent C Dodds - What is JSX? 📚 JSX “This funny tag syntax is neither a string nor HTML” - 리액트 공식 문서 JSX는 Raw React API보다 직관적이며 코드를 읽을 때 이해하기 쉽게 만들어주는 syntactic sugar이다. 그치만 JSX은 그 자체로 자바스크립트는 아니기 때문에 브라우저가 이를 이해하기 위해서는 babel과 같은 코드 컴파일러가 필요하다. 실제 바벨 사이트에 들어가보면 내가 작성한 JSX 코드가 어떻게 컴파일되어 브라우저가 이해하는 형식으로 변한하는지 확인할 수 있다. 리액트 알아보기[1]에서 기존 DOM 생성을 React API를 사용해서 변경했던 코드를 JSX 문법으로 변환해보자. 📚 리액트 커스텀 컴포넌트 일반 자바스크립트에서 함수를 만들어 재사용 가능한 코드를 만드는 것과 같이 JSX또한 함수를 통해 재사용 가능한 JSX 코드를 작성할 수 있고 이를 리액트에서는 Compone…","fields":{"slug":"/jsx-and-react-component/"},"frontmatter":{"categories":"프론트엔드","title":"jsx와 리액트 컴포넌트","date":"September 20, 2021"}},"next":{"fields":{"slug":"/graphql-query-at-front/"}},"previous":{"fields":{"slug":"/react-key-props/"}}},{"node":{"id":"be0aaee8-99de-566b-8abf-e13159633d54","excerpt":"GraphQL이 도대체 뭐야? GraphQL 얘기를 주변에서 너무 많이 들었다. 프로젝트 발표에서도 면접에서도 GraphQL 관련 질문을 받았는데..그동안 계속된 프로젝트로 새로운 기술을 배울 시간이 없었는데 도대체 GraphQL 뭔지 공부 해봐야겠다. GraphQL docs에서 제공한는 튜토이얼을 따라하기 전에 개념부터 잡고가야겠다는 생각을 했는데 마침!! kakao tech에서 정리해놓은 블로그 글을 찾았다. 카카오 테크 참고 링크 GraphQL(이하 gql)은 페이스북에서만든 쿼리 언어이고 아직 세상에 나온지 얼마되지 않은 새로운 친구이지만 2016년부터 가파르게 사용자가 늘어나고 있다고 한다. 위에서도 언급했듯이 gql은 sql과 마찬가지로 데이터를 효율적으로 요청하기 위해 사용되는 언어이지만 구조적을 큰 차이가 있고 사용 목적 또한 다르다. sql문이 데이터베이스에서 데이터를 효율적을 가져오기 위해서 사용된다면 gql은 웹 클라이언트가 서버로부터 효율적을 데이터를 받아오기…","fields":{"slug":"/graphql-query-at-front/"},"frontmatter":{"categories":"프론트엔드","title":"Graphql은 REST API의 어떤점을 해결해주나?","date":"September 17, 2021"}},"next":{"fields":{"slug":"/createAsyncThunk/"}},"previous":{"fields":{"slug":"/jsx-and-react-component/"}}},{"node":{"id":"18b3b1ec-aa5b-53f9-bc6e-2d0892e570ad","excerpt":"🤔 리덕스는 어떻게 관리할까? 리덕스는 어떻게 관리할까? 프로젝트를 시작하면서 고민을 많이했다. 이전 프로젝트를 할때는 redux의 action과 reducer를 직접 만들어주는 방식으로 vanilla redux로 작업을했다. 마지막 6주 협업을 진행하게 되면서 분명 프로젝트의 규모가 커질것이라고 생각했고 redux-createAsyncThunk를 사용해서 비동기 미들웨어와 리듀서들을 조금더 효율적이고 간결하게 관리하기로 했다. Create Async Thunk redux 에서 비동기 처리를 할경우 보통 thunk, saga, redux-observable 등의 미들웨어를 사용하여 한개의 비동기 액션에 대해 pending(비동기 호출 전), success(비동기 호출 성공), failure(비동기 호출 실패) 의 상태를 생성하여 처리하는 경우가 많다. 이때 각 상태를 만드는것은 각자 유틸 패키지를 받거나 직접 구현하여서 사용하였는데 이를 redux-toolkit 에서 createA…","fields":{"slug":"/createAsyncThunk/"},"frontmatter":{"categories":"프론트엔드","title":"리덕스 createAsyncThunk로 비동기 처리하기","date":"July 12, 2021"}},"next":{"fields":{"slug":"/sentinel method/"}},"previous":{"fields":{"slug":"/graphql-query-at-front/"}}},{"node":{"id":"ae311174-ce0e-5eac-a6ea-e11be304518d","excerpt":"> “왜 redux가 꼭 필요한가..?” 🤔 문득 이런 생각이 들었다. 항상 프로젝트를 진행할때 redux를 써야할까? 라는 의문을 가지면서도 이미 redux를 통해 전역으로 state를 관리하는데 익숙해져서 (툴킷이 너무 편해서..) 그냥 너무나 자연스럽게 리덕스를 사용해왔다. 이번 기회에 정확히 redux가 어떤 이점이 있는지 또 로컬에서 상태 값을 관리할때와 어떤 차이가 있는지 정리 해보자. State(상태) 일단 react에서 상태란 어떤걸 의미하는가? 리액트 컴포넌트에서 동적인 값을 상태(state) 라고 부른다. 사용자 인터랙션을 통해 컴포넌트의 상태값이 동적으로 바뀔 경우에는 상태를 관리하는 것이 필요하다. 16.7버전 리액트 이전에는 클래스 컴포넌트에서 this를 binding해서 상태값을 관리했다면 React hooks의 내장 함수인 useState() 가 나오면서 이를 통해 함수형 컴포넌트에서도 상태를 관리할 수 있다. 리액트 컴포넌트 또한 함수이며 jsx를 리턴…","fields":{"slug":"/useStateOrRedux/"},"frontmatter":{"categories":"프론트엔드","title":"useState? redux?","date":"June 10, 2021"}},"next":{"fields":{"slug":"/contextApi/"}},"previous":{"fields":{"slug":"/list-prime-number/"}}},{"node":{"id":"a7a0e416-fffe-5e35-a4f3-dd1f5224839d","excerpt":"이미 알고있는 내용 📌 React의 useState 훅으로 지역 상태를 관리 할 수 있다. props 다른 곳에서 사용하고 싶다면 props로 전달해야지만 자식 컴포넌트에서 상태 값에 접근이 가능하다. props로 여러 컴포넌트에게 상태 값을 내려 주기에는 한계가 있다. 📌 Redux store를 통해 전역적으로 컴포넌트가 상태 값에 접근이 가능하다. 🤔 contextAPI는 무엇? Redux와 비슷한듯 다른 contextAPI를 정리해보자 contextAPI 특징 React의 내장 기능으로 redux와는 다르게 리액트에서만 사용할 수 있다. Provider로 최상위 컴포넌트를 감싸 상태 값을 내려주는 형식이다. 🤔 contextAPI 사용법 1. Context를 만들자 redux를 사용할때 slice별로 누어서 사용했던것과 비슷한 개념인거 같다. initState에 초기 상태값을 객체 형태로 전달한다. 2. Action을 만들어준다 액션을 지정하여 타입 별로 다른 로직을 진행시킬…","fields":{"slug":"/contextApi/"},"frontmatter":{"categories":"프론트엔드","title":"리액트 contextAPI","date":"May 19, 2021"}},"next":{"fields":{"slug":"/referenceAndPrimitive/"}},"previous":{"fields":{"slug":"/useStateOrRedux/"}}},{"node":{"id":"6b16833d-d2a5-5bdc-88f6-f843e5e0cdd3","excerpt":"✏️ propTypes를 통한 props 검증 리액트에서는 부모 컴포넌트에서 자식 컴포넌트로 props를 통해 데이터를 전달한다. 이 과정에서 를 사용하면 전달되는 props의 타입(type)을 미리 지정하여 원치않는 데이터의 값이나 타입이 전달되는것을 보다 쉽게 디버깅할 수 있게 해준다. 예제 코드에서는 name과 favoriteNumber로 부모에서 자식 컴포넌트로 전달되는 props를 검증한다. 는 문자열 전달받는다고 미리 설정해줬다. 만약 부모 컴포넌트에서 name으로 문자열이 아닌 숫자 또는 객체 형태의 데이터를 넘겨주게 되면 console통해 경고 메세지를 전달해준다. 📌 propTypes를 반드시 사용해야 할까? propTypes를 반드시 사용할 필요하는 없다. proptypes로 props의 타입들을 미리 설정하고 검증할 수 있지만 console에 경고를 보여줄뿐 타입 에러로 어플리케이션이 멈추지는 않는다. 하지만 React를 사용한 프로젝트의 규모가 커지고 다른 개발…","fields":{"slug":"/PropTypes/"},"frontmatter":{"categories":"프론트엔드","title":"prop-types","date":"May 05, 2021"}},"next":null,"previous":{"fields":{"slug":"/referenceAndPrimitive/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}