{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"8b82364b-2829-556f-8cd7-348af94b4575","excerpt":"문제: leetcode - 88 (Merge sorted array) 오름차순으로 정렬된 정수들로 이루어진 2개의 배열 nums1과 nums2가 입력값으로 주어진다. 그냥보면 병합정렬 문제이다. 특이한점이 있다면 return 값으로 병합된 배열을 반환하지 않고 초기에 주어진 nums1에 직접 병합을 해야한다. 예시:  1️⃣ 문제해설 1: 처음에 지문을 읽고는 뭐지..?라는 생각이 들었다. 첫번째로 nums1을 보면 정렬된 정수들뒤로 nums2의 길이만큼 0으로 공간이 초기화되어 있고 배열 내 병합할 원소의 개수를 의미하는 m, n이 주어진다. 결론부터 말하면 sorting 없이 포인터를 지정해서 배열의 병합이 가능하다. 해당 문제풀이는 discussion에서 다른 사람의 코드를 가져왔다. 문제해설2에서 다루겠다. 정렬을 신경쓰지 않고, nums2에 있는 모든 요소들을 nums1에 넣어준다. list.sort()로 오름차 정렬을 시켜준다. 시간 복잡도: 파이썬의 sort() 함수가 O…","fields":{"slug":"/leetcode-88/"},"frontmatter":{"categories":"algorithm","title":"leetcode(88)- Merge sorted array","date":"March 23, 2021"}},"next":{"fields":{"slug":"/leecode-151/"}},"previous":null},{"node":{"id":"613d8fb0-b581-5f32-899d-e58f0f08d9f2","excerpt":"문제: leetcode - 151 (Reverse Words in a String) 🎉 기분이 좋은 밤이다. 블로그에 현재까지 정리한 문제풀이는 지금 작성하고 있는 리트코드 151번 문제를 포함해서 3개밖에 되지 않지만 벌써 3주째 하루에 한 문제씩 알고리즘 문제를 풀고있다. 아직까지 Hard level의 문제는 시도조차 하지 않고 있고 easy 또는 Medium level의 문제 위주로 풀고있다. Easy 문제는 그럭저럭 다른 사람이 작성한 해답을 보지 않고 풀이를 완성하는 횟수가 증가하고 있지만 Medium level의 문제만 나오면 아직까지 책이나 리트코드 disccusion에 다른 사람들이 작성한 풀이를 참고해서 해결하고 있다. 아니 오늘 저녁까지는 그랬다. 내가 느끼기에도 이번 문제는 Medium level이라고 하기에는 다른 문제들에 비해 쉬웠다. 그치만..!! 그치만 처음으로 답지 없이 미디엄 레벨 문제를 풀었다. 다른 사람들이 보면 “뭐 이 쉬운문제 하나 풀었다고”라…","fields":{"slug":"/leecode-151/"},"frontmatter":{"categories":"algorithm","title":"leetcode(151)- Reverse Words in a String","date":"March 22, 2021"}},"next":{"fields":{"slug":"/leetcode-509/"}},"previous":{"fields":{"slug":"/leetcode-88/"}}},{"node":{"id":"8c65d29f-84d9-56f2-8510-ab52304106e9","excerpt":"문제: leetcode - 509 (피보나치 수열) 일반적으로 F(n)로 표기하며 피보나치 숫자는 피보나치 수열 이라고 불리는 수열를 형성하며, 각 숫자는 0과 1에서 시작하는 앞의 두 숫자의 합이된다. 즉, 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 이다. 예시: F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 n=5일경우 피보나치 수열을 나열해보면 [0, 1, 1, 2, 4, 5] 형태로 나열된다. 사실 이 문제는 필요한 식을 제공하기 때문에 피보나치 수열을 알고있지 않더라도 풀이가 가능하다. 1️⃣ 문제풀이 1 (recursion) 피보나치 수열 문제는 재귀함수를 소개하는 입문 영상에서 많이 다뤄지는 대표적인 문제이다…","fields":{"slug":"/leetcode-509/"},"frontmatter":{"categories":"algorithm","title":"leetcode(509)- Fibonacci number","date":"March 21, 2021"}},"next":{"fields":{"slug":"/leetcode-20/"}},"previous":{"fields":{"slug":"/leecode-151/"}}},{"node":{"id":"08fd98ab-1a03-5af1-a296-d4fc8d35a4c6","excerpt":"문제: leetcode -20 (valid parentheses) 이번 문제의 난이도는 easy이고 스택을 이용하는 대표적인 문제이다. 문제 풀이를 위해서 스택의 구현이 직접 필요하지 않으며 python 리스트로 충분히 구현이 가능하다. pop() 연산만이 필요하기 때문에 데크를 이용한 풀이와 시간적으로 차이가 없다. 입력 값으로 괄호로 구성된 문자열이 주어진다. 주어진 문자열을 검사해서 모든 괄호들이 올바르게 닫혀 있는지 확인하여 bool 타입의 결과 값을 리턴 해줘야 한다. 여기서 올바르게 닫혀있는 괄호란 (){}이나 ({}) 같이 닫는 괄호가 나올 때 제일 최근에 있는 여는 괄호와 매칭된 형태이다. ✅ 올바르게 닫힌 괄호 예시: () ({}) {{([])}} ❌ 올바르게 닫히지 않은 예시: (( ((]) ]] ({[)}) 문제풀이: 이 문제의 풀이는 간단하다. 첫번째로 주어진 문자열을 반복문으로 왼쪽에서부터 오른쪽으로 이동한다. 열린 괄호가 나오면 스택에 넣는다. 만약 닫힌 …","fields":{"slug":"/leetcode-20/"},"frontmatter":{"categories":"algorithm","title":"leetcode(20)- Valid parentheses","date":"March 21, 2021"}},"next":null,"previous":{"fields":{"slug":"/leetcode-509/"}}}],"categories":["All","algorithm"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}