{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leetcode-53/",
    "result": {"data":{"cur":{"id":"99b34f9a-06f5-56e1-9c08-5ebafac7db0e","html":"<p><a href=\"https://leetcode.com/problems/maximum-subarray/\">문제:Maximum Subarray</a></p>\n<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>\n<p>A subarray is a contiguous part of an array.</p>\n<p>브루트포스로 O(n^2)을 풀이가 가능한 문제이지만 최대 부분 합을 구하는 유명한 카데인 Kadane’s 알고리즘 풀이가 있다. O(n)에 풀이가 가능하다.</p>\n<h4 id=\"카데인-알고리즘이란\" style=\"position:relative;\"><a href=\"#%EC%B9%B4%EB%8D%B0%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\" aria-label=\"카데인 알고리즘이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>카데인 알고리즘이란?</h4>\n<p>[ 1, -3, -1, 2] 와 같은 수의 나열 “수열”이 주어졌을 때 각 수들을 더했을때 가장 큰 합을 가지는 연속적인 서브 배열을 찾는 알고리즘이다.</p>\n<p>카데인 알고리즘은 “이미 구했던 값은 다시 재사용”하는 접근법을 이용하며, Brute Force의 A[0]~A[N-1]의 접근 방법이 아닌 A[N-1]~A[0] 접근 아이디어를 사용한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/3f2f1778-4683-4eda-a147-7ddb622b3d7e/image.png\" alt=\"\"></p>\n<p>위 그림을 보면 A[5]의 curr_max 구하려면, A[4]의 curr_max + A[5]를 해주면 되는걸 확인할 수 있다.</p>\n<blockquote>\n<p>각 A[4] Sum 배열 값에 A[5]를 더해주면 A[5] Sum에 대한 값들이 나온다.</p>\n</blockquote>\n<p>이러한 방법은 A[5]의 모든 부분 합을 처음부터 다시 계산하지 않더라고 A[5]에 부분 합을 구할 수 있음을 뜻한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curr_max[i] = max(A[i] + curr_max[i-1], A[i])</code></pre></div>\n<ul>\n<li>위 공식은 부분 집합의 최대 합을 구하는 목적이기 때문에,</li>\n<li>A[i]+curr_max[i-1]과 A[i] 중 무엇이 더 큰지 비교합니다. (A[i]가 더 크다면 이 전에 구했던 부분 집합은 필요 없기 때문)</li>\n<li>이렇게 구한 curr_max 배열에서 가장 큰 값을 구하면 Maximum Subarray Problem의 최대 부분 배열 합을 구할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">max_sub_array</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    curr_sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    max_sum <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">:</span>\n        curr_sum <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> curr_sum <span class=\"token operator\">+</span> num<span class=\"token punctuation\">)</span>\n        max_sum <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>curr_sum<span class=\"token punctuation\">,</span> max_sum<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> max_sum</code></pre></div>","excerpt":"문제:Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. 브루트포스로 O(n^2)을 풀이가 가능한 문제이지만 최대 부분 합을 구하는 유명한 카데인 Kadane’s 알고리즘 풀이가 있다. O(n)에 풀이가 가능하다. 카데인 알고리즘이란? [ 1, -3, -1, 2] 와 같은 수의 나열 “수열”이 주어졌을 때 각 수들을 더했을때 가장 큰 합을 가지는 연속적인 서브 배열을 찾는 알고리즘이다. 카데인 알고리즘은 “이미 구했던 값은 다시 재사용”하는 접근법을 이용하며, Brute Force의 A[0]~A[N-1]의 접근 방법이 아닌 A[N-1]~A[0] 접근 아이디어를 사용한다.  위 그림을…","frontmatter":{"date":"April 12, 2022","title":"leetcode(53)- maximum sub-array[카데안 알고리즘]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-53/"}},"next":{"id":"2b33df80-e8f7-51e2-a78a-b4ca45ae9caa","html":"<p>문제: <a href=\"https://leetcode.com/problems/product-of-array-except-self/\">leetcode - 238</a> (Product of Array Except Self)</p>\n<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p>\n<p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p>\n<p>You must write an algorithm that runs in O(n) time and without using the division operation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]</code></pre></div>\n<p>이번 문제는 해설을 찾아보지 않았으면 풀이 방법을 생각해내지 못했을 것이다.</p>\n<p>O(n)의 시간 복잡도 제약이 있기 때문에 브루트포스 방식으로는 풀이가 불가능하며 나눗셈 operator를 사용하지 않고 풀어야 하기 때문에 구해야하는 값은 간단하지만 문제 난이도는 높은 편인 것 같다.</p>\n<p>👉 여러가지 풀이를 찾아보고 ‘파이썬 알고리즘 인터뷰’ 해설도 참고했지만 <a href=\"https://www.youtube.com/watch?v=bNvIQI2wAjk\">neetcode - 238</a> 채널 해설이 자세하고 이해하기 쉬웠다.</p>\n<p>해당 영상에서는 O(N) + O(N) + O(N)인 공간 복잡도 성능을 O(N) + O(N)로 개선하기 위해서 로직이 추가되는 부분이 있는데 결국 빅오 계산에서는 O(N)이기 때문에 해당 로직은 추가하지 않았다. 그 편이 코드도 간결하고 그래서 알고리즘을 이해하기 편했다.</p>\n<h4 id=\"풀이-접근-방식\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\" aria-label=\"풀이 접근 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이 접근 방식</h4>\n<p>일단 접근법은 아래와 같다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/2e34c455-1a99-42bd-9588-7053d21929ea/image.jpeg\" alt=\"\"></p>\n<p>👉 만약 1번 인덱스 즉, 배열에서 2가 위치한 자리에서 2를 제외한 나머지 값들의 곱은 <strong>2를 기준으로 왼쪽에 있는 원소들과 오른쪽에 위치한 원소들의 곱이다</strong>.</p>\n<ul>\n<li>2를 기준으로 왼쪽에는 1이 있고</li>\n<li>2를 기준으로 오른쪽에는 3, 4가 있다.</li>\n</ul>\n<p>👉 이번에는 2번 인덱스 위치 즉, 배열에서 3을 제외한 나머지 값들의 합을 구해보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/93566e35-27ae-4d2a-a47a-8457573a03ba/image.jpeg\" alt=\"\"></p>\n<ul>\n<li>3을 기준으로 왼쪽에 1,2가 있고</li>\n<li>3을 기준으로 오른쪽에 4가 있다.</li>\n</ul>\n<blockquote>\n<p>⭐️</p>\n</blockquote>\n<ol>\n<li>왼쪽 원소들의 곱과 오른쪽 원소들의 곱을 구해</li>\n<li>두 값을 곱하면 특정 인덱스 위치에서 해당 값을 제외한 모든 원소들을 곱한 값이 나온다는 걸 알 수 있다.</li>\n</ol>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/22778f23-8f3a-4f87-b7a0-4a23ff3dfc98/image.jpeg\" alt=\"\"></p>\n<h4 id=\"문제풀이\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\" aria-label=\"문제풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제풀이:</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">product_except_self</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token comment\"># 나중에 left와 right을 곱한 값을 넣어줄 리스트를 초기화</span>\n    products <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># prefix = left = 인덱스 위치 전에 나오는 원소들의 곱</span>\n    prefix <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># suffix = right = 인덱스 위치 후에 나오는 원소들의 곱</span>\n    suffix <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 반복문으로 각 인덱스마다 그 전 위치까지 모든 원소들의 곱을 구한다.</span>\n    curr_prefix_products <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        prefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> curr_prefix_products\n        curr_prefix_products <span class=\"token operator\">*=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 반복문으로 각 인덱스마다 해당 인덱스 위치 이후에 나오는 모든 원소들의 곱을 곱해서 구한다.</span>\n    curr_suffix_products <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">reversed</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>suffix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        suffix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> curr_suffix_products\n        curr_suffix_products <span class=\"token operator\">*=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># prefix와 suffix를 곱한 값을 products에 넣어준다.</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>products<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        products<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> prefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> suffix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">return</span> products\n</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\">풀이 접근 방식</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\">문제풀이:</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 11, 2022","title":"leetcode(238) - Product of Array Except Self","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leecode-238/"}},"prev":{"id":"903364a3-94cb-50b0-b846-a38e34810127","html":"<p>퀵 정렬은 병합 정렬과 마찬가지로 분할 정복 알고리즘이다. 병합 정렬과 다른점은 항상 배열의 중앙을 기준을 분활 정복을 하는것이 아닌 **pivot(피벗)**이라는 기준을 만들고 피벗보다 작으면 왼쪽, 크면 오른쪽과 같은 방식으로 <strong>partitioning(파티셔닝)</strong> 하면서 쪼개 나간다.</p>\n<p><img src=\"https://www.tutorialspoint.com/data_structures_algorithms/images/quick_sort_partition_animation.gif\" alt=\"\"></p>\n<p>피벗을 정하는 기준과 방법이 여럿 있지만 N.로무토가 구현한 파티션 계획에서 소개된 방법으로 <strong>항상 맨 오른쪽의 피벗</strong>을 택하는 단순한 방식이 가장 간결하고 이해하기 쉽다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> low <span class=\"token operator\">&lt;</span> high<span class=\"token punctuation\">:</span>\n    \t<span class=\"token comment\"># 파티션 함수</span>\n        pivot <span class=\"token operator\">=</span> partition<span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span>\n\n        quick_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        quick_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span></code></pre></div>\n<p>퀵 정렬의 메인 함수는 간단하다. 파티션 함수로 배열을 pivot 기준으로 나누고 재귀 호출하는 전형적인 분할 정복 구조이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 파티션 함수</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># pivot 설정 - 오른쪽 끝 마지막 인덱스 선택 (로무토 파티션 계획)</span>\n        pivot <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>high<span class=\"token punctuation\">]</span>\n        left <span class=\"token operator\">=</span> low\n        <span class=\"token keyword\">for</span> right <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span>\n                left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n        nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>high<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>high<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span>\n\n        <span class=\"token keyword\">return</span> left\n\n    <span class=\"token keyword\">if</span> low <span class=\"token operator\">&lt;</span> high<span class=\"token punctuation\">:</span>\n        pivot <span class=\"token operator\">=</span> partition<span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span>\n\n        quick_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        quick_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span></code></pre></div>\n<p>파티션 함수를 로무토 파티션 계획 방법으로 구현하면 위 코드와 같다. 맨 오른쪽 피벗으로 정하고, 피벗을 기준으로 정렬과 상관없이 단순히 피벗보다 작은 수와, 큰 수들로 배열을 나눈다.</p>\n<p>for문으로 파티션 함수에 들어온 배열을 순회하면서 right 포인터 값이 피벗보다 작다면 left 포인터 값과 스왑하는 형태이다. 이 부분은 코드나 설명을 읽기보다 아래와 같이 직접 포인터를 이동시켜보면 보다 쉽게 이해가 가능하다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/8949c50b-8955-4e5e-8573-af3a9c0d54d5/image.jpeg\" alt=\"\"></p>\n<p>그림에서 보듯이 오른쪽 right 포인터가 이동하면서 피벗의 값이 오른쪽 값보다 더 클 때, 왼쪽과 오른쪽의 스왑이 진행된다. 스왑 이후에는 왼쪽 left 포인터가 함께 이동 한다.</p>\n<p>퀵 정렬의 평균 시간 복잡도는 O(n log n)으 빠르다. 하지만 최악의 경우, 예들들어 이미 정렬된 배열이 입력값으로 들어온다면 O(n^2)이 된다. 항상 일정한 성능을 보이는 병합 정렬과 달리, 퀵 정렬은 이처럼 입력값에 따라 성능 편차가 심한 편이다.</p>","frontmatter":{"date":"April 15, 2022","title":"Algorithm[퀵 정렬]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/algo-quick-sort/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leetcode-53/","nextSlug":"/leecode-238/","prevSlug":"/algo-quick-sort/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}