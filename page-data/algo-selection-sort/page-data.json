{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/algo-selection-sort/",
    "result": {"data":{"cur":{"id":"be99792c-2788-5798-9815-55e4eb4ae781","html":"<h3 id=\"-선택-정렬-구현하기\" style=\"position:relative;\"><a href=\"#-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\" 선택 정렬 구현하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👉 선택 정렬 구현하기</h3>\n<p>♻️ 반복하는 과정:</p>\n<ol>\n<li>주어진 범위에서 <em><strong>최소 값의 위치를 찾는다.</strong></em></li>\n<li>최소 값을 해당 <strong><em>범위의 가장 앞 숫자와 자리를 바꾼다.</em></strong></li>\n<li>이후, 해당 범위의 가장 앞 자리를 제외한 나머지 범위에 대해 위의 <strong><em>과정을 반복한다.</em></strong></li>\n</ol>\n<p>입력으로 주어진 원본 배열 A와 이를 오름차순으로 정렬한 배열 B가 있다고 하자. 원소의 순서가 다를 뿐 두 배열은 집합적으로는 같은 집합이다.</p>\n<p><img src=\"https://media.vlpt.us/images/heesungj7/post/989d375d-da3d-48f3-9658-952774dada11/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.12.54.png\" alt=\"\"></p>\n<p>즉, 특정 인덱스 k에 대하여 배열 B의 원소 b[k]는 오름차순으로 (k+1)번째로 작은 값 이다.</p>\n<p><img src=\"https://media.vlpt.us/images/heesungj7/post/bc96f8ab-5883-4318-b09d-e18bd4b2f1e5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.17.07.png\" alt=\"\"></p>\n<p>위에 정렬 과정은 아래와 같이 집합으로 표현이 가능하다.</p>\n<blockquote>\n<p>𝑏0=𝑀𝑖𝑛𝐴 =𝑀𝑖𝑛(𝐵)\n𝑏1 =𝑀𝑖𝑛 𝐴−{𝑏0} =𝑀𝑖𝑛(𝐵−{𝑏0})\n𝑏2 =𝑀𝑖𝑛 𝐴−{𝑏0,𝑏1} =𝑀𝑖𝑛(𝐵−{𝑏0,𝑏1})</p>\n</blockquote>\n<ol>\n<li>b0의 값은 배열 A에서 가장 작은 값이된다.</li>\n<li>b1의 값은 b0을 뺀 배열 A에서 가장 작은 값이된다.\n…</li>\n</ol>\n<p>이렇게 작은 숫자부터 차례로 나열하면, 오름차순으로 배열이 정렬된다.</p>\n<h3 id=\"예제-코드\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%A0%9C-%EC%BD%94%EB%93%9C\" aria-label=\"예제 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예제 코드:</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">selection_sort</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n    n <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token builtin\">min</span> <span class=\"token operator\">=</span> i\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> data<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> data<span class=\"token punctuation\">[</span><span class=\"token builtin\">min</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">return</span> data</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\">👉 선택 정렬 구현하기</a></li>\n<li><a href=\"#%EC%98%88%EC%A0%9C-%EC%BD%94%EB%93%9C\">예제 코드:</a></li>\n</ul>\n</div>","excerpt":"👉 선택 정렬 구현하기 ♻️ 반복하는 과정: 주어진 범위에서 최소 값의 위치를 찾는다. 최소 값을 해당 범위의 가장 앞 숫자와 자리를 바꾼다. 이후, 해당 범위의 가장 앞 자리를 제외한 나머지 범위에 대해 위의 과정을 반복한다. 입력으로 주어진 원본 배열 A와 이를 오름차순으로 정렬한 배열 B가 있다고 하자. 원소의 순서가 다를 뿐 두 배열은 집합적으로는 같은 집합이다.  즉, 특정 인덱스 k에 대하여 배열 B의 원소 b[k]는 오름차순으로 (k+1)번째로 작은 값 이다.  위에 정렬 과정은 아래와 같이 집합으로 표현이 가능하다. 𝑏0=𝑀𝑖𝑛𝐴 =𝑀𝑖𝑛(𝐵)\n𝑏1 =𝑀𝑖𝑛 𝐴−{𝑏0} =𝑀𝑖𝑛(𝐵−{𝑏0})\n𝑏2 =𝑀𝑖𝑛 𝐴−{𝑏0,𝑏1} =𝑀𝑖𝑛(𝐵−{𝑏0,𝑏1}) b0의 값은 배열 A에서 가장 작은 값이된다. b1의 값은 b0을 뺀 배열 A에서 가장 작은 값이된다.\n… 이렇게 작은 숫자부터 차례로 나열하면, 오름차순으로 배열이 정렬된다. 예제 코드: 👉 선택 정렬 구현하기 예제 …","frontmatter":{"date":"March 29, 2022","title":"Algorithm[선택 정렬]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/algo-selection-sort/"}},"next":{"id":"4e0d5e1b-9044-5dc7-94ca-9650368e76dd","html":"<p>문제: <a href=\"https://leetcode.com/problems/coin-change/submissions/\">leetcode - 322</a> (Binary Search)</p>\n<p>You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.</p>\n<p>Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>\n<p>You may assume that you have an infinite number of each kind of coin.</p>\n<p>어느 파이썬 알고리즘 책에서는 해당 문제를 소개하면서 “거스름돈” 문제를 대표적인 그리디 알고리즘이라고 설명한다. 맞다. 그치만 반만 맞다. 그리디하게 해당 문제를 풀어보면 가장 큰 화폐 단위부터 거슬러 준다면 최적의(가장 적은 동전으로) 거스름돈을 찾을 수 있을 것 같다. leetcode에 같은 문제가 있어서 직접 풀어본 결과, 그리디하게 접근하면 해당 문제를 풀 수 없었다.</p>\n<h3 id=\"1️⃣-문제풀이1greedy\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B41greedy\" aria-label=\"1️⃣ 문제풀이1greedy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ 문제풀이1(greedy):</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">coin_change</span><span class=\"token punctuation\">(</span>coins<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> amount<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    coins<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span> x<span class=\"token punctuation\">,</span> reverse<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span>\n\n    count <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> coin <span class=\"token keyword\">in</span> coins<span class=\"token punctuation\">:</span>\n        count <span class=\"token operator\">+=</span> amount <span class=\"token operator\">//</span> coin\n        amount <span class=\"token operator\">%=</span> coin\n\n    <span class=\"token keyword\">return</span> count</code></pre></div>\n<p>대부분에 경우 위에 그리디 문제풀이로 정답을 찾을 수 있다.</p>\n<p>👉 Example 1: coins = [1,2,5], amount = 11</p>\n<ol>\n<li>주어진 코인 배열을 오름차순으로 정렬한다.\n<ul>\n<li>coins = [5, 2, 1]</li>\n</ul>\n</li>\n<li>가장 큰 화폐부터 해당 화폐가 amount값에 몇번 들어가는지 구한다.\n<ul>\n<li>11 = (5*5)+1 —> 11 // 5 = 2</li>\n<li>count = 2(5화폐 2개)</li>\n</ul>\n</li>\n<li>남은 amount 값 작은 화폐로 채운다\n<ul>\n<li>1 = (1*1) —> 1 //1 = 1</li>\n<li>count = 2(5화폐 2개) + 1(1화폐 1개)</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"but\" style=\"position:relative;\"><a href=\"#but\" aria-label=\"but permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BUT</h5>\n<h4 id=\"but-1\" style=\"position:relative;\"><a href=\"#but-1\" aria-label=\"but 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BUT</h4>\n<h3 id=\"but-2\" style=\"position:relative;\"><a href=\"#but-2\" aria-label=\"but 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BUT</h3>\n<p>주어진 화폐들이 [9,6,5,1]인 경우를 생각해보자.\n👉 Eample 2: coins=[9,6,5,1], amount=11.</p>\n<ol>\n<li>가장 큰 9를 빼면 11-9 = 2가 남는다.</li>\n<li>남은 2는 두개의 1로 거슬러줄 수 있다.</li>\n</ol>\n<p>최종적으로 3개의 coin이 필요하다 (‘9’ 1개 + ‘1’ 2개).</p>\n<p>가장 적은 coin을 사용한 거스름돈이 맞나? 아니다 ❌.</p>\n<p>이 상황에서 가정 적게 필요한 동전의 수는 2이다 (5 + 6 = 11).</p>\n<h3 id=\"2️⃣-문제풀이2dp\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B42dp\" aria-label=\"2️⃣ 문제풀이2dp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ 문제풀이2(dp):</h3>\n<p>여러 문제 풀이를 찾아봤다. ‘다이나믹 프로그래밍’ 풀이가 가장 많았다. 코드 자체는 크게 어렵지 않았지만 해당 풀이을 도출하는 thought processing이 결코 쉽지않아 보인다.</p>\n<p>다이나믹 프로그래밍으로 문제를 접근할때 아래와 순서로 접근할 수 있다:</p>\n<ol>\n<li>recursive brute force solution</li>\n<li>recursive solution with memo</li>\n<li>recursive dynamic programming solution</li>\n</ol>\n<p>「다이나믹 프로그래밍」에가 가장 중요한 키워드는 검색(search)과 기억(memo)이다. “검색” 문제에 대해서는 “재귀 트리” 분석을 먼저 그려야 한다. (<a href=\"https://www.youtube.com/watch?v=H9bfqozjoqs\">참고영상</a>)</p>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/43e6fbaa-e28e-4504-900f-369196af9c5c/KakaoTalk_Photo_2022-03-28-16-40-47.jpeg\" alt=\"\"></p>\n<p>재귀 트리를 살펴보면 하이라이트로 처리한 부분처럼 반복적으로 발생하는 것을 알 수 있다. 이 반복되는 연산을 “momoizied search (메모화된 검색)” 또는 “dp table (dp 테이블)“로 처리한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">coin_change_dp</span><span class=\"token punctuation\">(</span>coins<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> amount<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 0부터 amount까지 포함하는 배열 초기화</span>\n    dp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"inf\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> amount <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>amount <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># 0원의 만들기 위해서 필요한 코인은 0개</span>\n    dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> coin <span class=\"token keyword\">in</span> coins<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> amount <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> coin <span class=\"token operator\">&lt;=</span> amount<span class=\"token punctuation\">:</span>\n                <span class=\"token comment\"># if amount = 186</span>\n                <span class=\"token comment\"># dp[amount] = 186  --> dp[186] --> 1</span>\n                <span class=\"token comment\"># min(infinity, dp[186 - coin(186) --> 0 +1 = 1]</span>\n                dp<span class=\"token punctuation\">[</span>amount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>amount<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>amount <span class=\"token operator\">-</span> coin<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>amount<span class=\"token punctuation\">]</span> <span class=\"token keyword\">if</span> dp<span class=\"token punctuation\">[</span>amount<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token builtin\">float</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"inf\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">else</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span></code></pre></div>\n<ol>\n<li>0부터 amount까지 최적의 solution(가장 적은 동전의 조합)을 추적하는 배열을 하나 생성한다.</li>\n<li>해당 배열을 원소들을 무한대로 초기화 한다.</li>\n<li>amount = 0를 위해서 필요한 코인은 0개이다. dp[0]을 0으로 초기화 한다.</li>\n<li>주어진 coin마다 amout에 필요한 coin을 계산한다.</li>\n<li>해당 결과 값이 dp 테이블에 있는지 체크하고, 있다면 min 값을 저장한다.</li>\n</ol>\n<p>dp 테이블을 사용하면서 흥미로운 점은 n(amount)에 대한 해답을 구하려고 할 때마다 n보다 작은 모든 값에 대한 해답을 이미 가지고 있다는 것이다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B41greedy\">1️⃣ 문제풀이1(greedy):</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#but\">BUT</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#but-1\">BUT</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#but-2\">BUT</a></p>\n</li>\n<li>\n<p><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B42dp\">2️⃣ 문제풀이2(dp):</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"March 28, 2022","title":"leetcode(322)- Coin change","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-322/"}},"prev":{"id":"390e96e0-3bd7-5724-a676-285b515886f7","html":"<h4 id=\"파이썬에서-01--02의-값은-얼마일까-\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-01--02%EC%9D%98-%EA%B0%92%EC%9D%80-%EC%96%BC%EB%A7%88%EC%9D%BC%EA%B9%8C-\" aria-label=\"파이썬에서 01  02의 값은 얼마일까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파이썬에서 0.1 + 0.2의 값은 얼마일까? 🤔</h4>\n<p>0.3이 나올 것 같지만 실제 계산 값은 0.30000000000000004가이 나온다. 파이썬은 실수를 부동 소수점 방식으로 표현하기 때문에 실수를 정확히 표현하는 것이 가능하지 않다. 만약 두 실수가 같은지 판단할 때 다음과 같이 0.1 + 0.2와 0.3은 같지 않다고 나온다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token number\">0.1</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0.3</span>\n\n<span class=\"token operator\">></span> <span class=\"token boolean\">False</span></code></pre></div>\n<p>이렇게 실수를 근삿값으로 표현하면서 발생하는 문제를 부동소수점 반올림 **오차(rounding error)**가 발생하기 때문에 실수를 비교할 때는 연산한 값과 비교할 값의 차이를 구한 뒤 특정 오차 범위 안에서 같은지 확인해야 한다. 파이썬 3.5이상부터는 두 실수가 같은지 판단할 때 math.isclose 함수를 사용 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> math\nmath<span class=\"token punctuation\">.</span>isclose<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span> <span class=\"token operator\">+</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.3</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">></span> <span class=\"token boolean\">True</span></code></pre></div>\n<p>❗️ 알고리즘 문제를 풀 때도 실수를 비교하는 조건 연산이 있다면 실수 계산을 피할 수 있는지 고려해보는 것이 좋다.</p>\n<h4 id=\"예시\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C\" aria-label=\"예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시:</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">find_index</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\tu <span class=\"token operator\">=</span> <span class=\"token builtin\">sum</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> n\n\tx <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n\t<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t\tdx <span class=\"token operator\">=</span> <span class=\"token builtin\">abs</span><span class=\"token punctuation\">(</span>u<span class=\"token operator\">-</span>data<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># i까지의 원소들 중 평균과의 최소거리</span>\n\t\tdi <span class=\"token operator\">=</span> <span class=\"token builtin\">abs</span><span class=\"token punctuation\">(</span>u<span class=\"token operator\">-</span>data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># 현재 원소와 평균과의 거리</span>\n\n\t\t<span class=\"token keyword\">if</span> di <span class=\"token operator\">&lt;</span> dx<span class=\"token punctuation\">:</span>\n\t\t\tx <span class=\"token operator\">=</span> i\n\n\t<span class=\"token keyword\">return</span> x</code></pre></div>\n<ol>\n<li>위 예시는 데이터는 -100,000 이상 100,000 이하의 정수를도 이루어진 배열이 주어진다.</li>\n<li>데이터 배열의 모든 원소들의 평균 값과 가장 가까운 원소를 찾고 해당 원소의 인덱스를 반환하는 함수이다.</li>\n<li>이때 평균과의 거리와 가작 가까운 즉, 평균과의 거리가 작은 원소는 아래와 같이 구할 수 있다.</li>\n</ol>\n<ul>\n<li>평균과의 거리 𝐷 = 𝑑𝑎𝑡𝑎[𝑖] − 𝜇 가 가장 작은 인덱스 𝑥 계산하기\n• 평균을 계산한 이후\n• 평균과 차이가 가장적은 i들 중 • 가장 작은(왼쪽에 있는) i</li>\n</ul>\n<p>이때 <strong>가능하다면 계산 과정에서 실수를 사용한 계산은 최소화하는 것이 좋다</strong>. 부동 소수점 의 오차로 인해 예상치 못한 오동작이 생길 수 도 있습니다. 대부분의 비교식은 조금 변환하면 정수의 계산으로 바꿀 수 있다.</p>\n<ul>\n<li>👉 <strong>𝐷=𝑑𝑎𝑡𝑎[𝑖]−𝜇 라면</strong>\n• 𝑛𝐷 = 𝑛×𝑑𝑎𝑡𝑎[𝑖]−𝑆 가 된다.S는 모든 원소의 합. 𝑖\n• n과 D모두 양수이므로 성립한다.\n• 모든 연산의 결과는 정수가 된다.</li>\n</ul>\n<p>❗️ 대소관계를 비교하는 경우, 대소관계만 유지 된다면 식을 변형해도 된다.</p>\n<blockquote>\n<p>|𝑑𝑎𝑡𝑎[𝑖]− 𝜇 &#x3C; 𝑑𝑎𝑡𝑎[𝑗]− 𝜇 ⟺ 𝑛×𝑑𝑎𝑡𝑎[𝑖]−𝑆 &#x3C; 𝑛×𝑑𝑎𝑡𝑎[𝑗]−𝑆|</p>\n</blockquote>\n<p>해당 계산을 기존 풀이에 적용하면 아래와 같이 비교 연산에 실수를 사용하지 않고 풀이가 가능하다.\n항상, 실수 계산은 최소화한 후 최종계산에서만 실수로 변환하는게 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">find_index</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\tS <span class=\"token operator\">=</span> <span class=\"token builtin\">sum</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n\tx <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n\t<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t\tdx <span class=\"token operator\">=</span> <span class=\"token builtin\">abs</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">*</span>data<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> S<span class=\"token punctuation\">)</span> <span class=\"token comment\"># i까지의 원소들 중 평균과의 최소거리</span>\n\t\tdi <span class=\"token operator\">=</span> <span class=\"token builtin\">abs</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">*</span>data<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> S<span class=\"token punctuation\">)</span> <span class=\"token comment\"># 현재 원소와 평균과의 거리</span>\n\n\t\t<span class=\"token keyword\">if</span> di <span class=\"token operator\">&lt;</span> dx<span class=\"token punctuation\">:</span>\n\t\t\tx <span class=\"token operator\">=</span> i\n\t<span class=\"token keyword\">return</span> x</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%97%90%EC%84%9C-01--02%EC%9D%98-%EA%B0%92%EC%9D%80-%EC%96%BC%EB%A7%88%EC%9D%BC%EA%B9%8C-\">파이썬에서 0.1 + 0.2의 값은 얼마일까? 🤔</a></li>\n<li><a href=\"#%EC%98%88%EC%8B%9C\">예시:</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 01, 2022","title":"Algorithm[실수 연산을 피하자]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/algo-avoid-float-number/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/algo-selection-sort/","nextSlug":"/leetcode-322/","prevSlug":"/algo-avoid-float-number/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}