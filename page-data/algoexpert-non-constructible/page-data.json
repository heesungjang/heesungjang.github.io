{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/algoexpert-non-constructible/",
    "result": {"data":{"cur":{"id":"5397f91a-ba80-55c1-b57b-b84378ced340","html":"<p>문제: Elements of Programming Interviews in python, page 189</p>\n<blockquote>\n<p>Given an array of positive integers (representing coins), find the smallest value that cannot be constructed from those integers.</p>\n</blockquote>\n<p>0이아닌 정수들로 이루어진 배열이 주어진다. 이때 배열 요소들의 합으로 구할 수 없는 수들 중 가장 작은 수를 반환해야 한다.</p>\n<h3 id=\"exmaple\" style=\"position:relative;\"><a href=\"#exmaple\" aria-label=\"exmaple permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exmaple</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Input<span class=\"token punctuation\">:</span> A <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\nExplanation<span class=\"token punctuation\">:</span> 배열 A의 요소들로 조합 가능한 정수들은 <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span> 이다<span class=\"token punctuation\">.</span>\n\n즉<span class=\"token punctuation\">,</span> 배열의 A의 요소들로 만들 수 없는 가장 작은 값은 <span class=\"token number\">8</span>이다<span class=\"token punctuation\">.</span></code></pre></div>\n<h3 id=\"1️⃣-문제풀이\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\" aria-label=\"1️⃣ 문제풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ 문제풀이:</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">non_constructible</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># sort the list of coins</span>\n    <span class=\"token comment\"># O(log n) time complexity</span>\n\n    curr_constructible <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> <span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> coin <span class=\"token operator\">></span> curr_constructible <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> curr_constructible <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n\n        curr_constructible <span class=\"token operator\">+=</span> num\n\n    <span class=\"token keyword\">return</span> curr_constructible <span class=\"token operator\">+</span> <span class=\"token number\">1</span></code></pre></div>\n<ol>\n<li>배열의 원소들을 오름차순으로 정렬하는것이 중요하다.</li>\n<li>오름차순으로 정렬된 정수들의 누적 합계를 구하면 특정 위치에서 구성 가능한 가장 높은 값을 알 수 있다.\n👉 예들들면)</li>\n</ol>\n<ul>\n<li>\n<p>sum of [1, 2 ] = <strong>3</strong> 이며 조합 가능한 수는 [1, 2, 3]이다.</p>\n</li>\n<li>\n<p>sum of [1, 2, 4] = <strong>7</strong> 이며 조합 가능한 수는 [1, 2, 3, 4, 5, 6, 7]이다.</p>\n</li>\n<li>\n<p>sum of [1, 2, 4, 5] = <strong>12</strong> 이며 조합 가능한 수는 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]이다.</p>\n</li>\n<li>\n<p>❗️ 즉, 특정 인덱스 위치에서 다음에 나오는 정수가 curr_constructible(해당 인덱스까지 모든 정수들의 합) + 1 보다 크면 curr_constructible + 1을 생성할 수 없다.</p>\n</li>\n</ul>\n<p>시간복잡도: O(n log n) 정렬, O(logn) 탐색</p>\n<p>공간복잡도: O(1)</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#exmaple\">Exmaple</a></li>\n<li><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\">1️⃣ 문제풀이:</a></li>\n</ul>\n</div>","excerpt":"문제: Elements of Programming Interviews in python, page 189 Given an array of positive integers (representing coins), find the smallest value that cannot be constructed from those integers. 0이아닌 정수들로 이루어진 배열이 주어진다. 이때 배열 요소들의 합으로 구할 수 없는 수들 중 가장 작은 수를 반환해야 한다. Exmaple 1️⃣ 문제풀이: 배열의 원소들을 오름차순으로 정렬하는것이 중요하다. 오름차순으로 정렬된 정수들의 누적 합계를 구하면 특정 위치에서 구성 가능한 가장 높은 값을 알 수 있다.\n👉 예들들면) sum of [1, 2 ] = 3 이며 조합 가능한 수는 [1, 2, 3]이다. sum of [1, 2, 4] = 7 이며 조합 가능한 수는 [1, 2, 3, 4, 5, 6, 7]이다. sum of [1, 2, 4, 5] = 1…","frontmatter":{"date":"March 24, 2021","title":"algoexpert-non-constructible-value","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/algoexpert-non-constructible/"}},"next":{"id":"8b82364b-2829-556f-8cd7-348af94b4575","html":"<p>문제: <a href=\"https://leetcode.com/problems/merge-sorted-array/submissions/\">leetcode - 88</a> (Merge sorted array)</p>\n<p>오름차순으로 정렬된 정수들로 이루어진 2개의 배열 nums1과 nums2가 입력값으로 주어진다. 그냥보면 병합정렬 문제이다. 특이한점이 있다면 return 값으로 병합된 배열을 반환하지 않고 초기에 주어진 nums1에 직접 병합을 해야한다.</p>\n<p>예시:</p>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/c6e18f9b-d91f-432b-a995-04f0203f050d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.44.45.png\" alt=\"\"></p>\n<h3 id=\"1️⃣-문제해설-1\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%95%B4%EC%84%A4-1\" aria-label=\"1️⃣ 문제해설 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ 문제해설 1:</h3>\n<p>처음에 지문을 읽고는 뭐지..?라는 생각이 들었다. 첫번째로 nums1을 보면 정렬된 정수들뒤로 nums2의 길이만큼 0으로 공간이 초기화되어 있고 배열 내 병합할 원소의 개수를 의미하는 m, n이 주어진다. 결론부터 말하면 sorting 없이 포인터를 지정해서 배열의 병합이 가능하다. 해당 문제풀이는 discussion에서 다른 사람의 코드를 가져왔다. 문제해설2에서 다루겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums1<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> nums2<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums2<span class=\"token punctuation\">:</span>\n        nums1<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> num\n        m <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n    nums1<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ol>\n<li>정렬을 신경쓰지 않고, nums2에 있는 모든 요소들을 nums1에 넣어준다.</li>\n<li>list.sort()로 오름차 정렬을 시켜준다.</li>\n</ol>\n<p>시간 복잡도: 파이썬의 sort() 함수가 O(n log n)의 연산 시간이 걸리므로 최종적으로 O(n log n)의 시간 복잡도를 가지는 풀이이다.</p>\n<h3 id=\"2️⃣-문제해설-2\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%95%B4%EC%84%A4-2\" aria-label=\"2️⃣ 문제해설 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ 문제해설 2:</h3>\n<p>위에서 언급했듯이 sorting이 필요없는 포인터를 이용한 풀이이다. nums1을 길이만큼 한번의 iteration을 실행하므로 O(n)의 시간 복잡도를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>nums1<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> nums2<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    last <span class=\"token operator\">=</span> m <span class=\"token operator\">+</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n\n    <span class=\"token comment\"># merge in reverse order</span>\n    <span class=\"token comment\"># nums2 elements to the end of nums1</span>\n    <span class=\"token keyword\">while</span> m <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token keyword\">and</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> nums1<span class=\"token punctuation\">[</span>m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums2<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            nums1<span class=\"token punctuation\">[</span>last<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums2<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            n <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            nums1<span class=\"token punctuation\">[</span>last<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums1<span class=\"token punctuation\">[</span>m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            m <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        last <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token comment\"># fill nums1 with leftover nums2 elements at the beginning</span>\n    <span class=\"token comment\"># this is because elements leftover in nums2 are smaller than any values in nums1</span>\n    <span class=\"token keyword\">while</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        nums1<span class=\"token punctuation\">[</span>last<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums2<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        n <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        last <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n</code></pre></div>\n<ol>\n<li>아래 그림과 같이 nums1에 마지막 인덱스, m과 n의 인덱스에 각각 포인터를 위치 시킨다.</li>\n</ol>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/14d190d5-1aed-45d7-8716-278f0e4b3e36/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.54.34.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>\n<p>m또는 n의 길이가 0이되기 전까지 즉, nums1과 nums2의 오른쪽 끝에서 왼쪽 끝으로 이동하면서 nums2의 값과 nums1의 값을 비교한다.</p>\n</li>\n<li>\n<p>만약 nums1[m] &#x3C; nums2[n]이라면 n의 마지막 요소는 nums1과 nums2의 모든 요소들중 가장 큰 정수일것이다(nums1과 nums2 모두 오름차도 정렬이 되어있음에).</p>\n</li>\n<li>\n<p>이제 nums2의 마지막 인덱스 값, 예제에서는 6의 nums1 배열의 끝에 넣어준다.\n<img src=\"https://images.velog.io/images/heesungj7/post/88cd2a67-8338-49d5-a13b-73931f5fae73/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.04.14.png\" alt=\"\">\n<img src=\"https://images.velog.io/images/heesungj7/post/89b9efa8-5c4f-4b36-84de-4b172c454cbe/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.06.02.png\" alt=\"\"></p>\n</li>\n<li>\n<p>만약 nums1[m]이 > nums2[n]라면 nums1[m]을 last 포인터 위치에 대입하고 m과 last의 포인터만 이동시킨다.</p>\n</li>\n</ol>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/8a04d0ae-94b3-4e81-9abe-8c1d03095c9e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.09.23.png\" alt=\"\"></p>\n<p>포인터의 이동을 파워 포인터로 그려고보려 했지만…깔끔에가 못그리겠다. 혹시나 미래에 이 풀이를 다시 찾아보는 나이거나 지나가다 풀이를 보려고 들어오신 분이라면 아래 유튜브 링크를 참조해주세요.</p>\n<p>👉 <a href=\"https://www.youtube.com/watch?v=C4oBXLr3zos&#x26;t=195s\">유튜브 링크</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%95%B4%EC%84%A4-1\">1️⃣ 문제해설 1:</a></li>\n<li><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%95%B4%EC%84%A4-2\">2️⃣ 문제해설 2:</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 23, 2021","title":"leetcode(88)- Merge sorted array","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-88/"}},"prev":{"id":"70b98f14-868a-5312-90ee-c447c191bd90","html":"<h1 id=\"1-문제\" style=\"position:relative;\"><a href=\"#1-%EB%AC%B8%EC%A0%9C\" aria-label=\"1 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 문제</h1>\n<p>0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자를 모두 0, 혹은 모두 1로 같게 만들어야 한다. 할 수 있는 행동은 연속된 하나의 숫자를 잡고 모두 뒤집는 것 이다. 뒤는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다. <strong>주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오.</strong></p>\n<h2 id=\"예제\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%A0%9C\" aria-label=\"예제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예제:</h2>\n<p>예를 들어 S=0001100 일 때,</p>\n<ol>\n<li>\n<p>전체를 뒤집으면 1110011이 된다.</p>\n</li>\n<li>\n<p>4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.</p>\n</li>\n<li>\n<p>하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.</p>\n</li>\n</ol>\n<h2 id=\"접근법\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC%EB%B2%95\" aria-label=\"접근법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근법:</h2>\n<blockquote>\n<ol>\n<li>00011000에서 연속된 하나의 숫자, 즉 연속된 문자열들을 하나의 집합으로 구분하여 생각하자.</li>\n<li>예를들어, 00011000은 000 11 000 이렇게 구간별로 나눌 수 있다.</li>\n<li>따라서 이 경우에 1이 나오는 구간의 문자열들을 뒤집어주면 최소 횟수로 모든 숫자를 같게 만들 수 있다.</li>\n</ol>\n</blockquote>\n<h2 id=\"풀이법\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EB%B2%95\" aria-label=\"풀이법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이법:</h2>\n<h4 id=\"그렇다면-어떻게-구간을-나누고-뒤집는-횟수를-카운트할-수-있을까\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%EA%B0%84%EC%9D%84-%EB%82%98%EB%88%84%EA%B3%A0-%EB%92%A4%EC%A7%91%EB%8A%94-%ED%9A%9F%EC%88%98%EB%A5%BC-%EC%B9%B4%EC%9A%B4%ED%8A%B8%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C\" aria-label=\"그렇다면 어떻게 구간을 나누고 뒤집는 횟수를 카운트할 수 있을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그렇다면 어떻게 구간을 나누고, 뒤집는 횟수를 카운트할 수 있을까?</h4>\n<blockquote>\n<ol>\n<li>for문으로 문자열 내의 원소를 앞뒤로 비교하고,</li>\n<li>현재 원소와 다음에 오는 원소의 값이 같이 않다면, 새로운 구간이 시작되는 부분이고 만약 새로 시작하는 구간의 문자열이 1이라면, <strong>전체 문자열을 0으로 변경하기 위해 뒤집어야 하는 구간</strong>이기 때문에 count_to_all_zero에 +1을 해준다.</li>\n<li>반대로 새로운 구간의 문자열이 0이라면 count_to_all_one에 1+을 해준다.</li>\n<li>마지막으로 둘의 카운트를 비교하여 최소값을 반환한다.</li>\n</ol>\n</blockquote>\n<h3 id=\"python-code\" style=\"position:relative;\"><a href=\"#python-code\" aria-label=\"python code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>python code:</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">find_count_to_turn_out_to_all_zero_or_all_one</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    count_to_all_zero <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    count_to_all_one <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">if</span> string<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">:</span>\n        count_to_all_one <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">elif</span> string<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">:</span>\n        count_to_all_zero <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>string<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n        <span class=\"token keyword\">if</span> string<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> string<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> string<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">:</span>\n                count_to_all_one <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">if</span> string<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">:</span>\n                count_to_all_zero <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>count_to_all_one<span class=\"token punctuation\">,</span> count_to_all_zero<span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"주의점\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%EC%A0%90\" aria-label=\"주의점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>*주의점:</h3>\n<blockquote>\n<p>문자열의 첫 문자는 이전 문자열의 원소와 비교하지 못하기 때문에 for문이 시작하기 전에 카운트를 해줘야 한다.</p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%98%88%EC%A0%9C\">예제:</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%91%EA%B7%BC%EB%B2%95\">접근법:</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%92%80%EC%9D%B4%EB%B2%95\">풀이법:</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%EA%B0%84%EC%9D%84-%EB%82%98%EB%88%84%EA%B3%A0-%EB%92%A4%EC%A7%91%EB%8A%94-%ED%9A%9F%EC%88%98%EB%A5%BC-%EC%B9%B4%EC%9A%B4%ED%8A%B8%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C\">그렇다면 어떻게 구간을 나누고, 뒤집는 횟수를 카운트할 수 있을까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#python-code\">python code:</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A3%BC%EC%9D%98%EC%A0%90\">*주의점:</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 14, 2021","title":"Algorithm[reverse-zeros-ones]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/algo-reverse-string/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/algoexpert-non-constructible/","nextSlug":"/leetcode-88/","prevSlug":"/algo-reverse-string/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}