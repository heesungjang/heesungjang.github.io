{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leetcode-316/",
    "result": {"data":{"cur":{"id":"9bce0b48-0595-5fc1-af50-a7953428ad3e","html":"<p>문제: <a href=\"https://leetcode.com/problems/remove-duplicate-letters/\">remove duplicate letters</a></p>\n<p>Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Input<span class=\"token punctuation\">:</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"bcabc\"</span>\n\n<span class=\"token operator\">>></span> Output<span class=\"token punctuation\">:</span> <span class=\"token string\">\"abc\"</span></code></pre></div>\n<p>코드 구현 자체는 어렵지 않지만, 문자열을 제거하고 순서에 맞게 나열하는 로직을 생각해 내는 건 쉽지 않아 보인다. 두고두고 충분히 습득될 때까지 여러 번 풀어봐야 할 문제이다.</p>\n<p>입력값 문자열에서 중복된 문자를 제거하고 **“the smallest in lexicographical order”**으로 중복 제거된 문자열을 반환해야 한다.</p>\n<h4 id=\"lexciographical-order란\" style=\"position:relative;\"><a href=\"#lexciographical-order%EB%9E%80\" aria-label=\"lexciographical order란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lexciographical order란?</h4>\n<p>lexicographical order에 대해 먼저 정확한 이해가 필요해 보인다.</p>\n<ul>\n<li>단순히 사전식 정렬, 사전식 오름차순 정렬과는 다르다.</li>\n<li>❗️문자 그대로 사전에서 가장 먼저 찾을 수 있는 순서를 말한다.</li>\n<li>예들들어, bcabc에서 중복을 제거한 경우의 문자에는 아래와 같이 여러가지 조합이 있다.\n<ul>\n<li>bca\n<ul>\n<li>bac</li>\n<li>cab</li>\n<li>abc</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>❗️ 이 중 <strong>사전에서 가장 먼저 찾을 수 있는 것</strong>은 abc이다.</li>\n</ul>\n<p>또 하나 주의해야 하는 부분은, 예제 입/출력에서 ebcabc가 입력값이라면 결과는 eabc가 되지만, ebcabce가 입력값이라면 결과는 abce가 된다.</p>\n<ul>\n<li>❗️ 해당 문자열에서 한 번만 등장하는 문자는 위치를 변경할 수 없다.</li>\n</ul>\n<h3 id=\"스택을-이용한-풀이\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%92%80%EC%9D%B4\" aria-label=\"스택을 이용한 풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택을 이용한 풀이:</h3>\n<ol>\n<li>스택에는 문자열에 속한 문자를 차례대로 쌓아 나가되, 다음과 같은 조건인 경우 해당 값을 pop한다.</li>\n</ol>\n<ul>\n<li>현재 문자 char가 스택에 쌓여 있는 문자인 경우(이전 문자보다 앞선 문자인 경우)</li>\n<li>뒤에 붙일 문자가 또 나올 문자인 경우</li>\n</ul>\n<p>뒤에 붙일 문자가 또 나올 문자인지 알기 위해서 collections.Counter()를 이용한다. 이 모듈은 문자별 개수를 자동으로 카운팅해 dict형태로 저장한다.</p>\n<ul>\n<li>문자열 s의 문자들을 차례로 돌면서 counter 값을 -1해주고</li>\n<li>stack에 이미 들어가 있는 문자가 있고</li>\n<li>현재 검사중인 문자가 스택에 가장 위 문자보다 앞선 문자이며</li>\n<li>stack에 가장 위에 있는 문자가 이후에 다시 나올 문자라면</li>\n<li>stack에서 pop() 연산을 한다.</li>\n</ul>\n<p>stack을 사용하기 때문에 스택 ADT에 정의된 연산만을 사용해 문제를 풀어준다. 파이썬 리스트를 스택으로 사용하기 때문에 이미 처리한 문자를 확인할때 in stack 으로 처리할 수 있지만 ADT에 정의된 연산만을 사용하기 위해서 seen이라는 set 자료구조를 별도로 만들어 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">remove_duplicate</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">:</span>\n    counter <span class=\"token operator\">=</span> collections<span class=\"token punctuation\">.</span>Counter<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n    stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    seen <span class=\"token operator\">=</span> <span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">for</span> char <span class=\"token keyword\">in</span> s<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> char <span class=\"token keyword\">in</span> seen<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 이미 처리된 문자, 즉 스택에서 제가할 수 없는 문자라면</span>\n            <span class=\"token comment\"># 스택에 넣지 않고 스킵</span>\n            <span class=\"token keyword\">continue</span>\n\n        <span class=\"token comment\"># 중복 문자 제거 부분</span>\n        <span class=\"token comment\"># 현재 문자열이 스택에 있는 문자보다 알파벳 순서로 작은데,</span>\n        <span class=\"token comment\"># 현재 스택에 있는 문자가 뒤에 더 있어서 스택에서 제거가 가능하다면</span>\n        <span class=\"token comment\"># 모두 제거</span>\n        <span class=\"token keyword\">while</span> stack <span class=\"token keyword\">and</span> char <span class=\"token operator\">&lt;</span> stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">and</span> counter<span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            seen<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n        stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span>\n        seen<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<ul>\n<li><a href=\"#lexciographical-order%EB%9E%80\">Lexciographical order란?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%83%9D%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%92%80%EC%9D%B4\">스택을 이용한 풀이:</a></p>\n</li>\n</ul>\n</div>","excerpt":"문제: remove duplicate letters Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. 코드 구현 자체는 어렵지 않지만, 문자열을 제거하고 순서에 맞게 나열하는 로직을 생각해 내는 건 쉽지 않아 보인다. 두고두고 충분히 습득될 때까지 여러 번 풀어봐야 할 문제이다. 입력값 문자열에서 중복된 문자를 제거하고 **“the smallest in lexicographical order”**으로 중복 제거된 문자열을 반환해야 한다. Lexciographical order란? lexicographical order에 대해 먼저 정확한 이해가 필요해 보인다. 단순히 사전식 정렬, 사전식 오름…","frontmatter":{"date":"April 19, 2022","title":"leetcode(316) - remove-duplicate-letters","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-316/"}},"next":{"id":"0a0b817b-b952-5bd9-ac39-518bed8080d8","html":"<p>문제: <a href=\"https://leetcode.com/problems/add-two-numbers/\">add-two-numbers</a></p>\n<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p>미디엄 문제이기는 하지만 풀이가 어렵지는 않은 문제다.</p>\n<p>두개의 정수가 역순으로 연결리스트로 주어진다. 역순으로 주어지기 때문에 덧셈 로직을 구현하기 쉽다. 연결 리스트에 역순으로 값이 들어있기 때문에 첫 head 노트부터 덧셈을 하면 우리가 두 수를 더할 때 일의 자리부터 더해서 자릿수를 올리며 더하는 방법과 동일하다.</p>\n<h3 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이:</h3>\n<p>리스트를 순서대로 타고 가면 일의 자리부터 접근할 수 있다. 따라서, 두 리스트를 단순하게 앞에서부터 접근하면서 더해주는 식으로 새로운 연결 리스트를 만들어주면 두 정수의 합을 표현한 역순 열결 리스트를 만들 수 있다.</p>\n<p>❗️중간에 올림 처리와 자릿수가 맞지 않을때, 예를들어 2342 + 387 일 때 비어있는 자리를 0으로 예외 처리만 해주면 쉽게 풀 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">addTwoNumbers</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  curr <span class=\"token operator\">=</span> dummy\n\n  carry <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n  <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">or</span> l2 <span class=\"token keyword\">or</span> carry<span class=\"token punctuation\">:</span>\n      v1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">if</span> l1 <span class=\"token keyword\">else</span> <span class=\"token number\">0</span>\n      v2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">if</span> l2 <span class=\"token keyword\">else</span> <span class=\"token number\">0</span>\n\n      val <span class=\"token operator\">=</span> v1 <span class=\"token operator\">+</span> v2 <span class=\"token operator\">+</span> carry\n\n      carry <span class=\"token operator\">=</span> val <span class=\"token operator\">//</span> <span class=\"token number\">10</span>\n      val  <span class=\"token operator\">=</span> val <span class=\"token operator\">%</span> <span class=\"token number\">10</span>\n\n      curr<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span>\n\n      l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token keyword\">if</span> l1 <span class=\"token keyword\">else</span> <span class=\"token boolean\">None</span>\n      l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token keyword\">if</span> l2 <span class=\"token keyword\">else</span> <span class=\"token boolean\">None</span>\n      curr <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n  <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>","frontmatter":{"date":"April 18, 2022","title":"leetcode(2) - add-two-number","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-2/"}},"prev":{"id":"5f63c36b-7378-5958-9ccb-cbf8312f08c7","html":"<p>문제: <a href=\"%22https://leetcode.com/problems/daily-temperatures/%22\">leetcode-739</a>(Daily temperatures)</p>\n<p>Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Input<span class=\"token punctuation\">:</span> temperatures <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">73</span><span class=\"token punctuation\">,</span><span class=\"token number\">74</span><span class=\"token punctuation\">,</span><span class=\"token number\">75</span><span class=\"token punctuation\">,</span><span class=\"token number\">71</span><span class=\"token punctuation\">,</span><span class=\"token number\">69</span><span class=\"token punctuation\">,</span><span class=\"token number\">72</span><span class=\"token punctuation\">,</span><span class=\"token number\">76</span><span class=\"token punctuation\">,</span><span class=\"token number\">73</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token operator\">>></span>Output<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>매일의 온도를 리스트 T로 입력받은 뒤 현재보다 더 따뜻한 날이 올 때까지 며칠이 걸리는지를 구하는 문제다.</p>\n<ol>\n<li>\n<p>enumerate를 이용해서 특정 날짜의 인덱스와 온도값을 기억한다</p>\n</li>\n<li>\n<p>T의 인덱스를 계속해서 스택에 쌓아두면서</p>\n<ol>\n<li>\n<p>현재 온도가 스택에 쌓아둔 마지막 날의 온도보다 높다면</p>\n</li>\n<li>\n<p>스택을 pop해주고</p>\n</li>\n<li>\n<p>정답에 i와 pop한 인덱스와의 차이를 저장한다</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/835229d3-cca8-4ed2-adea-f02e1ab27fb1/image.jpeg\" alt=\"\"></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">daily_temp</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    res<span class=\"token punctuation\">,</span> stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">for</span> i<span class=\"token punctuation\">,</span> curr <span class=\"token keyword\">in</span> <span class=\"token builtin\">enumerate</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n        <span class=\"token keyword\">while</span> stack <span class=\"token keyword\">and</span> curr <span class=\"token operator\">></span> T<span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            last <span class=\"token operator\">=</span> stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            res<span class=\"token punctuation\">[</span>last<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i <span class=\"token operator\">-</span> last\n        stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> res</code></pre></div>","frontmatter":{"date":"April 19, 2022","title":"leetcode(739)- Daily temperatures","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-739/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leetcode-316/","nextSlug":"/leetcode-2/","prevSlug":"/leetcode-739/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}