{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leecode-151/",
    "result": {"data":{"cur":{"id":"613d8fb0-b581-5f32-899d-e58f0f08d9f2","html":"<p>문제: <a href=\"https://leetcode.com/problems/fibonacci-number/\">leetcode - 151</a> (Reverse Words in a String)</p>\n<p>🎉 기분이 좋은 밤이다. 블로그에 현재까지 정리한 문제풀이는 지금 작성하고 있는 리트코드 151번 문제를 포함해서 3개밖에 되지 않지만 벌써 3주째 하루에 한 문제씩 알고리즘 문제를 풀고있다. 아직까지 Hard level의 문제는 시도조차 하지 않고 있고 easy 또는 Medium level의 문제 위주로 풀고있다.</p>\n<h3 id=\"1️⃣-문제풀이1\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B41\" aria-label=\"1️⃣ 문제풀이1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ 문제풀이1:</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">reverse_words</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">:</span>\n    words <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    temp_string <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n\n    <span class=\"token keyword\">for</span> char <span class=\"token keyword\">in</span> s<span class=\"token punctuation\">.</span>strip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>temp_string<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token keyword\">and</span> char <span class=\"token operator\">==</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n\n        <span class=\"token keyword\">if</span> char <span class=\"token operator\">!=</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">:</span>\n            temp_string <span class=\"token operator\">+=</span> char\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            words<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>temp_string<span class=\"token punctuation\">)</span>\n            temp_string <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n            <span class=\"token keyword\">continue</span>\n    words<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>temp_string<span class=\"token punctuation\">)</span>\n    words<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>words<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ol>\n<li>파이썬의 내장함수인 strip() 사용해서 좌우 여백을 제거한다..</li>\n<li>여백이 제거된 문자열을 반복문으로 이동하면서 공백이 나오기전까지 모든 문자들을 temp_string에 임시로 저장한다.</li>\n<li>공백이 나오면 새로운 단어가 시작되는 구간이기 때문에 현재 temp_string에 저장된 문자열을 words에 추가하고 temp_string을 다시 초기화 해준다.</li>\n<li>마지막 단어 다음에는 공백이 존재하지 않기 때문에 반복문이 끝나면 temp_string에 저장된 마지막 문자열을 words에 추가한다.</li>\n<li>words 배열을 reverse()와 join() 내장함수로 재정렬해서 최종 리턴 값을 반환한다.</li>\n</ol>\n<p>시간 복잡도: 문자열의 길이 n만큼 한번의 iteration을 하기 때문에 O(n)의 시간 복잡도를 가진다.</p>\n<p>공간 복잡도: O(n)의 공간 복잡도를 가진다.</p>\n<h3 id=\"2️⃣-문제풀이2\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B42\" aria-label=\"2️⃣ 문제풀이2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ 문제풀이2:</h3>\n<p>leetcode에 올라온 풀이중 갈끔한 풀이가있어 하나 가져왔다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">reverseWords</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\twords <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>strip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n\twords<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\twords <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>item <span class=\"token keyword\">for</span> item <span class=\"token keyword\">in</span> words <span class=\"token keyword\">if</span> item <span class=\"token operator\">!=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">]</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>words<span class=\"token punctuation\">)</span></code></pre></div>\n<p>**리스트 컴프리헨션(list comprehension)**을 활용한 풀이로 상당히 깔끔하다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B41\">1️⃣ 문제풀이1:</a></li>\n<li><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B42\">2️⃣ 문제풀이2:</a></li>\n</ul>\n</div>","excerpt":"문제: leetcode - 151 (Reverse Words in a String) 🎉 기분이 좋은 밤이다. 블로그에 현재까지 정리한 문제풀이는 지금 작성하고 있는 리트코드 151번 문제를 포함해서 3개밖에 되지 않지만 벌써 3주째 하루에 한 문제씩 알고리즘 문제를 풀고있다. 아직까지 Hard level의 문제는 시도조차 하지 않고 있고 easy 또는 Medium level의 문제 위주로 풀고있다. 1️⃣ 문제풀이1: 파이썬의 내장함수인 strip() 사용해서 좌우 여백을 제거한다.. 여백이 제거된 문자열을 반복문으로 이동하면서 공백이 나오기전까지 모든 문자들을 temp_string에 임시로 저장한다. 공백이 나오면 새로운 단어가 시작되는 구간이기 때문에 현재 temp_string에 저장된 문자열을 words에 추가하고 temp_string을 다시 초기화 해준다. 마지막 단어 다음에는 공백이 존재하지 않기 때문에 반복문이 끝나면 temp_string에 저장된 마지막 문자열을 words…","frontmatter":{"date":"March 22, 2021","title":"leetcode(151)- Reverse Words in a String","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leecode-151/"}},"next":{"id":"8c65d29f-84d9-56f2-8510-ab52304106e9","html":"<p>문제: <a href=\"https://leetcode.com/problems/fibonacci-number/\">leetcode - 509</a> (피보나치 수열)</p>\n<p>일반적으로 F(n)로 표기하며 피보나치 숫자는 피보나치 수열 이라고 불리는 수열를 형성하며, 각 숫자는 0과 1에서 시작하는 앞의 두 숫자의 합이된다. 즉, 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 <strong>F(n) = F(n-1) + F(n-2)</strong> 가 적용되는 수 이다.</p>\n<p>예시:</p>\n<ul>\n<li>F(2) = F(0) + F(1) = 0 + 1 = 1</li>\n<li>F(3) = F(1) + F(2) = 1 + 1 = 2</li>\n<li>F(4) = F(2) + F(3) = 1 + 2 = 3</li>\n<li>F(5) = F(3) + F(4) = 2 + 3 = 5</li>\n</ul>\n<p>n=5일경우 피보나치 수열을 나열해보면 [0, 1, 1, 2, 4, 5] 형태로 나열된다.</p>\n<p>사실 이 문제는 필요한 식을 제공하기 때문에 피보나치 수열을 알고있지 않더라도 풀이가 가능하다.</p>\n<hr/>\n<h3 id=\"1️⃣-문제풀이-1-recursion\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-1-recursion\" aria-label=\"1️⃣ 문제풀이 1 recursion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ 문제풀이 1 (recursion)</h3>\n<p>피보나치 수열 문제는 재귀함수를 소개하는 입문 영상에서 많이 다뤄지는 대표적인 문제이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">non_memo_fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">raise</span> ValueError<span class=\"token punctuation\">(</span><span class=\"token string\">\"n must be a positive integer\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">elif</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> non_memo_fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> non_memo_fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>우선, 재귀적으로 문제를 풀기 위해서 재귀 종료 조건이 되는 베이스 케이스를 생각해보자.</p>\n<p>2개의 베이스 케이스가 필요할 것이다. 첫번째로 nth 값이 0 인지, 다른 하나는 전달된 nth 번호가 1인지 여부이다. 피보나치 수열의 전제 조건이 <strong>F(0) = 0, F(1) = 1일 때</strong>, 1 이상의 n에 대하여 <strong>F(n) = F(n-1) + F(n-2)</strong> 가 성립되므로 n이 0일때 0을 리턴, n이 1이하일 때 1을 리턴하는 함수의 종료 지점(탈출 조건)이 생긴다.</p>\n<p>그 이외에는 리턴 값으로 Fibonacci(n-1) + Fibonacci(n-2)를 갖는다. 재귀적으로 자기 자신을 호출하며 종료 지점에 이르기까지 콜 스택에 호출된 함수가 쌓이게되고 종료 지점에 이르러 다시 오는 방식으로 작동한다.</p>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/5ee550c7-e37e-462e-89cc-89ffe6c88ae6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.04.58.png\" alt=\"\"></p>\n<p>이 문제는 재귀 함수를 사용하면 쉽고 직관적으로 풀이가 가능하지만 효율성이 떨어지는 연산이다.</p>\n<p>시간 복잡도를 살펴보자.</p>\n<p>2번씩 트리의 높이 n만큼 반복하여 함수를 호출하기 때문에 해당 풀이는 O(n^2)의 시간 복잡도를 가지며 콜 스택에 n만큼의 호출 함수가 쌓이기 때문에 O(n)의 공간 복잡도를 가진다 (❗️실행이 완료된 함수는 콜 스택에서 제거되기 때문에 n만큼만 쌓인다). 즉, 자기 자신을 2번씩 재호출하게 되므로, 흡사 binary tree 같은 형태를 가지며 입력 값이 증가함에 따라 함수 호출 횟수를 기하급수적으로 증식시키게 된다.</p>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/7ef1b34a-ff5f-46a4-b98f-c1f903c187a6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-21%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.15.34.png\" alt=\"\"></p>\n<p>재귀함수의 호출을 보여주는 recursion tree를 보면 이미 한번 계산된 함수가 여러번 반복해서 호출되는 것을 확인 할 수 있다. n=4일때 fib(2)는 총 2번, fib(1)은 3번 fib(0)은 총 2번 호출된다. 만약 n의 값이 4가 아니라 40이라고 한다면 훨씬 더 많은 비효율적인 반복 함수 호출이 발생할 것이다.</p>\n<p>이를 해결해주는 기법이 여러가지 존재하는데 memorization 기법으로 이미 연산이 끝난 함수의 반복 호출을 제거하면 O(n)의 시간 복잡도로 연산이 가능하다.</p>\n<h3 id=\"2️⃣-문제풀이-2-recursion-with-memorization\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-2-recursion-with-memorization\" aria-label=\"2️⃣ 문제풀이 2 recursion with memorization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ 문제풀이 2 (recursion with memorization)</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">memo_fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> memorization<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> memorization <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        memorization <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> n <span class=\"token keyword\">in</span> memorization<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;&lt;</span> ⭐️\n        <span class=\"token keyword\">return</span> memorization<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        memorization<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> memo_fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> memorization<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> memo_fib<span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> memorization<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> memorization<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>함수의 파라미터 값으로 memorization라는 파라미터가 하나 추가됬다. 이미 연산을 마친 함수와 해당 연산으로 나온 값을 저장하는 역할을 한다. ⭐️로 표시한 부분에서 호출된 함수의 연산 값이 저장소에 있는지 확인하고 이미 계산한값은 메모해둔곳에서 가져와서 (<strong>상수 시간의 연산</strong>) 사용한다. 메모를 위해서 O(n)만큼의 공간 복잡도를 추가해야 하지만, 이미 계산한 값을 또 재귀 호출로 계산할 필요가 없으므로 O(n) 의 시간복잡도 연산을 끝낼 수 있다.</p>\n<h3 id=\"3️⃣-문제풀이-3-iterative-approach\" style=\"position:relative;\"><a href=\"#3%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-3-iterative-approach\" aria-label=\"3️⃣ 문제풀이 3 iterative approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3️⃣ 문제풀이 3 (iterative approach)</h3>\n<p>재귀 함수로 풀이한 문제는 당연히 반복문으로 치환이 가능하다. 사실 대부분의 경우 반복문이 효율적인 측면에서 재귀함수 보다 더 좋고 선언적 프로그래밍에 익숙하지 않다면 몇줄에 코드가 더 늘어나도 명령형 프로그래밍의 반복문 작성이 보다 직관적이다. 실제로 재귀 함수는 코드만 봐서는 해당 로직이 반복되는지 알기 어렵다. 반면 for문 또는 while문 같이 명령형 프로그래밍의 반복문은 “나 지금 반복하고 있다”를 코드를 읽으면 바로 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"> <span class=\"token keyword\">def</span> <span class=\"token function\">liter_fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token keyword\">or</span> n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n\n    last_two <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    counter <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n\n    <span class=\"token keyword\">while</span> counter <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">:</span>\n        next_fib <span class=\"token operator\">=</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        last_two<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        last_two<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> next_fib\n        counter <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">return</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">if</span> n <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token keyword\">else</span> last_two<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>위 코드는 last_two라는 배열에 n-2와 n-1만 저장한다.</p>\n<p>last_two[0] = n - 2\nlast_two[1] = n - 1</p>\n<p>입력 값 n만큼 while문을 돌면서 (n - 2) + (n -1)의 값을 계산하고 새로운 n-1과 n-2를 업데이트한다. 반복문이 끝나면 마지만 연산 값인 last_two[1]를 반환한다. nth 값을 구하기 위해서 n의 길이 만큼만 반복하면 되기 때문에 O(n)의 시간 복잡도를 가지고 last_two라는 배열에 현재 계산중인 n-1, n-2 두개의 값만 저장하고 있으면 되기 때문에 O(1)의 공간 복잡도를 가진다. 재귀 풀이에 비해 모든 측면에서 훨씬 효율적이다. 또한 개인적으로 해당 코드가 보다 직관적이고 이해하기 쉽다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-1-recursion\">1️⃣ 문제풀이 1 (recursion)</a></li>\n<li><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-2-recursion-with-memorization\">2️⃣ 문제풀이 2 (recursion with memorization)</a></li>\n<li><a href=\"#3%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-3-iterative-approach\">3️⃣ 문제풀이 3 (iterative approach)</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 21, 2021","title":"leetcode(509)- Fibonacci number","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-509/"}},"prev":{"id":"8b82364b-2829-556f-8cd7-348af94b4575","html":"<p>문제: <a href=\"https://leetcode.com/problems/merge-sorted-array/submissions/\">leetcode - 88</a> (Merge sorted array)</p>\n<p>오름차순으로 정렬된 정수들로 이루어진 2개의 배열 nums1과 nums2가 입력값으로 주어진다. 그냥보면 병합정렬 문제이다. 특이한점이 있다면 return 값으로 병합된 배열을 반환하지 않고 초기에 주어진 nums1에 직접 병합을 해야한다.</p>\n<p>예시:</p>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/c6e18f9b-d91f-432b-a995-04f0203f050d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.44.45.png\" alt=\"\"></p>\n<h3 id=\"1️⃣-문제해설-1\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%95%B4%EC%84%A4-1\" aria-label=\"1️⃣ 문제해설 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ 문제해설 1:</h3>\n<p>처음에 지문을 읽고는 뭐지..?라는 생각이 들었다. 첫번째로 nums1을 보면 정렬된 정수들뒤로 nums2의 길이만큼 0으로 공간이 초기화되어 있고 배열 내 병합할 원소의 개수를 의미하는 m, n이 주어진다. 결론부터 말하면 sorting 없이 포인터를 지정해서 배열의 병합이 가능하다. 해당 문제풀이는 discussion에서 다른 사람의 코드를 가져왔다. 문제해설2에서 다루겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> nums1<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> nums2<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums2<span class=\"token punctuation\">:</span>\n        nums1<span class=\"token punctuation\">[</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> num\n        m <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n    nums1<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ol>\n<li>정렬을 신경쓰지 않고, nums2에 있는 모든 요소들을 nums1에 넣어준다.</li>\n<li>list.sort()로 오름차 정렬을 시켜준다.</li>\n</ol>\n<p>시간 복잡도: 파이썬의 sort() 함수가 O(n log n)의 연산 시간이 걸리므로 최종적으로 O(n log n)의 시간 복잡도를 가지는 풀이이다.</p>\n<h3 id=\"2️⃣-문제해설-2\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%95%B4%EC%84%A4-2\" aria-label=\"2️⃣ 문제해설 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ 문제해설 2:</h3>\n<p>위에서 언급했듯이 sorting이 필요없는 포인터를 이용한 풀이이다. nums1을 길이만큼 한번의 iteration을 실행하므로 O(n)의 시간 복잡도를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>nums1<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> nums2<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    last <span class=\"token operator\">=</span> m <span class=\"token operator\">+</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n\n    <span class=\"token comment\"># merge in reverse order</span>\n    <span class=\"token comment\"># nums2 elements to the end of nums1</span>\n    <span class=\"token keyword\">while</span> m <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token keyword\">and</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> nums1<span class=\"token punctuation\">[</span>m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> nums2<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            nums1<span class=\"token punctuation\">[</span>last<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums2<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            n <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            nums1<span class=\"token punctuation\">[</span>last<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums1<span class=\"token punctuation\">[</span>m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n            m <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        last <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token comment\"># fill nums1 with leftover nums2 elements at the beginning</span>\n    <span class=\"token comment\"># this is because elements leftover in nums2 are smaller than any values in nums1</span>\n    <span class=\"token keyword\">while</span> n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        nums1<span class=\"token punctuation\">[</span>last<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums2<span class=\"token punctuation\">[</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        n <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n        last <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n</code></pre></div>\n<ol>\n<li>아래 그림과 같이 nums1에 마지막 인덱스, m과 n의 인덱스에 각각 포인터를 위치 시킨다.</li>\n</ol>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/14d190d5-1aed-45d7-8716-278f0e4b3e36/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.54.34.png\" alt=\"\"></p>\n<ol start=\"2\">\n<li>\n<p>m또는 n의 길이가 0이되기 전까지 즉, nums1과 nums2의 오른쪽 끝에서 왼쪽 끝으로 이동하면서 nums2의 값과 nums1의 값을 비교한다.</p>\n</li>\n<li>\n<p>만약 nums1[m] &#x3C; nums2[n]이라면 n의 마지막 요소는 nums1과 nums2의 모든 요소들중 가장 큰 정수일것이다(nums1과 nums2 모두 오름차도 정렬이 되어있음에).</p>\n</li>\n<li>\n<p>이제 nums2의 마지막 인덱스 값, 예제에서는 6의 nums1 배열의 끝에 넣어준다.\n<img src=\"https://images.velog.io/images/heesungj7/post/88cd2a67-8338-49d5-a13b-73931f5fae73/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.04.14.png\" alt=\"\">\n<img src=\"https://images.velog.io/images/heesungj7/post/89b9efa8-5c4f-4b36-84de-4b172c454cbe/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.06.02.png\" alt=\"\"></p>\n</li>\n<li>\n<p>만약 nums1[m]이 > nums2[n]라면 nums1[m]을 last 포인터 위치에 대입하고 m과 last의 포인터만 이동시킨다.</p>\n</li>\n</ol>\n<p><img src=\"https://images.velog.io/images/heesungj7/post/8a04d0ae-94b3-4e81-9abe-8c1d03095c9e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-03-22%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.09.23.png\" alt=\"\"></p>\n<p>포인터의 이동을 파워 포인터로 그려고보려 했지만…깔끔에가 못그리겠다. 혹시나 미래에 이 풀이를 다시 찾아보는 나이거나 지나가다 풀이를 보려고 들어오신 분이라면 아래 유튜브 링크를 참조해주세요.</p>\n<p>👉 <a href=\"https://www.youtube.com/watch?v=C4oBXLr3zos&#x26;t=195s\">유튜브 링크</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%95%B4%EC%84%A4-1\">1️⃣ 문제해설 1:</a></li>\n<li><a href=\"#2%EF%B8%8F%E2%83%A3-%EB%AC%B8%EC%A0%9C%ED%95%B4%EC%84%A4-2\">2️⃣ 문제해설 2:</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 23, 2021","title":"leetcode(88)- Merge sorted array","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-88/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leecode-151/","nextSlug":"/leetcode-509/","prevSlug":"/leetcode-88/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}