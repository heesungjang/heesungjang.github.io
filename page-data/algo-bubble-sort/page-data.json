{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/algo-bubble-sort/",
    "result": {"data":{"cur":{"id":"2e023ceb-d13f-595e-884f-8ed4534cc0ac","html":"<h3 id=\"-버블-정렬-구현하기\" style=\"position:relative;\"><a href=\"#-%EB%B2%84%EB%B8%94-%EC%A0%95%EB%A0%AC-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\" 버블 정렬 구현하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛁 버블 정렬 구현하기</h3>\n<p>버블 정렬은 기본적으로 O(N^2)의 시간 복잡도를 가지는 알고리즘이다. 실제 코딩 테스트에서 O(N^2) 알고리즘을 사용하거나 구현할 일은 없겠지만 기본적인 정렬 알고리즘들을 정리하고 개념을 익혀 놓는게 좋을 것 같다. 알고리즘 구현 자체는 크게 어려운 부분이 없다.</p>\n<p>버블 정렬은 이름과 같이 물속에서 거품이 올라오는 모양과 비슷하다고 해서 버블 정렬이라고 한다.</p>\n<p>배열을 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽 방향으로 이동하면서 이웃한 앞뒤 원소의 값을 비교하고 앞 원소의 값이 더 크다면 두 원소의 자리를 교환(swap)하는 작업을 반복한다.</p>\n<p><img src=\"https://imagedelivery.net/v7-TZByhOiJbNM9RaUdzSA/4af29665-03ce-48e7-0f63-406754231100/public\" alt=\"\"></p>\n<h3 id=\"알고리즘\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘</h3>\n<p>데이터의 수를 N이라고 하자. 버블 정렬 알고리즘은 아래의 과정을 N번 반복할 것이다.</p>\n<ol>\n<li>배열의 0번 칸의 숫자가 1번칸의 숫자 보다 크다면 두 값의 위치를 교환한다.</li>\n<li>배열의 1번 칸의 숫자가 2번칸의 숫자 보다 크다면 두 값의 위치를 교환한다.</li>\n<li>…</li>\n<li>배열의 N-2번 칸의 숫자가 N-1 칸의 숫자 보다 크다면 두 값의 위치를 교환한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">bubble_sort</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t\t<span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t\t\t<span class=\"token keyword\">if</span> data<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> data<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n\t\t\t\tdata<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n\t<span class=\"token keyword\">return</span> data</code></pre></div>\n<h3 id=\"최적화\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"최적화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적화</h3>\n<p>이전 반복문 실행에서 앞뒤 자리 비교(swap)이 한 번도 일어나지 않았다면 정렬되지 않는 값이 하나도 없었다고 간주할 수 있다. 따라서 이럴 경우, 이후 반복문을 수행하지 않고 바로 for문을 break으로 나가준다.<img src=\"https://imagedelivery.net/v7-TZByhOiJbNM9RaUdzSA/62805b8b-e105-4598-f109-0b87e0100900/public\" alt=\"\"></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">bubble_sort</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t\tcount <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\t\t<span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t\t\t<span class=\"token keyword\">if</span> data<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> data<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n\t\t\t\tdata<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n\t\t\t\tcount <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\t\t<span class=\"token keyword\">if</span> count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        \t<span class=\"token comment\"># data[0] ~ data[n-i-1]칸까지 오름차순이 아닌 쌍이 없었다.</span>\n            <span class=\"token comment\"># data[0] ~ data[n-i-1]칸까지 모두 오름차순이다.</span>\n            <span class=\"token comment\"># data[n-1] ~ data[n-1]까지는 이미 정렬되어있다.</span>\n\t\t\t<span class=\"token keyword\">break</span>\n\t<span class=\"token keyword\">return</span> data</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EB%B2%84%EB%B8%94-%EC%A0%95%EB%A0%AC-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\">🛁 버블 정렬 구현하기</a></li>\n<li><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">알고리즘</a></li>\n<li><a href=\"#%EC%B5%9C%EC%A0%81%ED%99%94\">최적화</a></li>\n</ul>\n</div>","excerpt":"🛁 버블 정렬 구현하기 버블 정렬은 기본적으로 O(N^2)의 시간 복잡도를 가지는 알고리즘이다. 실제 코딩 테스트에서 O(N^2) 알고리즘을 사용하거나 구현할 일은 없겠지만 기본적인 정렬 알고리즘들을 정리하고 개념을 익혀 놓는게 좋을 것 같다. 알고리즘 구현 자체는 크게 어려운 부분이 없다. 버블 정렬은 이름과 같이 물속에서 거품이 올라오는 모양과 비슷하다고 해서 버블 정렬이라고 한다. 배열을 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽 방향으로 이동하면서 이웃한 앞뒤 원소의 값을 비교하고 앞 원소의 값이 더 크다면 두 원소의 자리를 교환(swap)하는 작업을 반복한다.  알고리즘 데이터의 수를 N이라고 하자. 버블 정렬 알고리즘은 아래의 과정을 N번 반복할 것이다. 배열의 0번 칸의 숫자가 1번칸의 숫자 보다 크다면 두 값의 위치를 교환한다. 배열의 1번 칸의 숫자가 2번칸의 숫자 보다 크다면 두 값의 위치를 교환한다. … 배열의 N-2번 칸의 숫자가 N-1 칸의 숫자 보다 크다면 두 …","frontmatter":{"date":"April 05, 2022","title":"Algorithm[버블정렬]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/algo-bubble-sort/"}},"next":{"id":"3ea323c0-1f6c-5f8e-aa01-aa2cee893b9a","html":"<p>보통 소수 찾기 문제에서 소수의 정의를 같이 제공하기 때문에 반복문으로 충분히 풀이가 가능하다. 그치만 약수가 가지는 특징을 이용하면 성능 개선이 가능하다.</p>\n<p>알고리즘 문제를 풀기 위해서 특정 문제에서만 사용되는 지엽적인 지식들은 모두 알고 있을 수 없지만 코딩 테스트에서 특정 자연수가 소수인지 판별하는 문제가 자주 출제되기 때문에 소수에 대한 성질은 짚고 넘어가고자 한다.</p>\n<h3 id=\"1️⃣-소수란\" style=\"position:relative;\"><a href=\"#1%EF%B8%8F%E2%83%A3-%EC%86%8C%EC%88%98%EB%9E%80\" aria-label=\"1️⃣ 소수란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1️⃣ 소수란:</h3>\n<ul>\n<li><strong>소수</strong>란 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로 나누어 떨어지지 않는 자연수이다.\ne.g) <strong>6</strong>은 1, 2, 3, 6으로 나누어 떨어지므로 소수가 아니다.\ne.g) <strong>7</strong>은 1과 7을 제외하고는 나누어 떨어지지 않으므로 소수이다.</li>\n</ul>\n<p>소수 정의에 주어진 조건만으로 반복문을 통해서 소수를 판별해보자.</p>\n<h4 id=\"기본-풀이\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%92%80%EC%9D%B4\" aria-label=\"기본 풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 풀이:</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">is_prime_number</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\n    <span class=\"token comment\"># 2부터 (n-1) 까지의 모든 수를 확인</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># n이 해당 수로 나누어 떨어지면</span>\n        <span class=\"token keyword\">if</span> n <span class=\"token operator\">%</span> i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>  <span class=\"token comment\"># 소수가 아님</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>  <span class=\"token comment\"># 소수임</span></code></pre></div>\n<p>소수 판별을 위한 연산량을 생각해보자. 주어진 자연수 n이 10억이라고 한다면 해당 자연수가 소수인지 판별하기 위해서 2부터 10억 - 1까지 반복문 안에 로직을 실행한다. 즉, 2부터 n-1의 모든 i가 n의 약수인지를 확인하기 때문에 o(n)의 시간 복잡도를 가진다. n의 최대값이 10억이라면 해당 문제를 1초~2초의 시간 조건을 통과하기 힘들기 때문에 타임아웃에 걸릴것이다.</p>\n<p>그렇다면 위 코드를 조금 더 개선할 수 있을까?</p>\n<blockquote>\n<p>짝수들은 2를 제외하고 모두 합성수라는 사실을 이용해 개선 할 수 있다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">is_prime_number</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 1은 소수가 아니다.</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n    <span class=\"token keyword\">elif</span> n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 2는 소수이다.</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n    <span class=\"token keyword\">elif</span> n <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        👉 <span class=\"token comment\"># 나머지 짝수는 소수가 아니다.</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token comment\"># 2부터 (n-1) 까지의 모든 수를 확인</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># n이 해당 수로 나누어 떨어지면</span>\n        <span class=\"token keyword\">if</span> n <span class=\"token operator\">%</span> i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>  <span class=\"token comment\"># 소수가 아님</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>  <span class=\"token comment\"># 소수임</span></code></pre></div>\n<p>위 코드에서는 짝수들은 2를 제외하고 모두 합성수라는 사실을 이용해 알고리즘의 성능을 개선했다. n이 짝수인 경우에 시간복잡도는 O(N)이다. 그렇지만 최악의 경우 즉, n의 값이 홀수라면 여전히 O(N)의 시간 복잡도가 걸린다.</p>\n<hr/>\n<h3 id=\"2️⃣-약수의-성질\" style=\"position:relative;\"><a href=\"#2%EF%B8%8F%E2%83%A3-%EC%95%BD%EC%88%98%EC%9D%98-%EC%84%B1%EC%A7%88\" aria-label=\"2️⃣ 약수의 성질 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2️⃣ 약수의 성질:</h3>\n<blockquote>\n<p>모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭을 이루는 것을 알 수 있다</p>\n</blockquote>\n<p>자연수N의 한 약수a를 생각해보자.N을a로 나눈 몫을b라고 하면 아래의 식이 성립한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">𝑁 = 𝑎𝑏 (단, 𝑎 ≤ 𝑏 )</code></pre></div>\n<p>즉,한 자연수N에 대해 서로 곱하여N이 되는 약수 쌍a,b가 <strong>항상</strong>❗️ 존재한다 (편의상a는 b이하인 경우만 고려하자).</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(𝑎≤𝑏)라는 조건 하에서 N에 대한 a의 최대 값은 𝑎≤ 𝑁이다.\n\n그러므로,N이 소수가 아니라면 2≤𝑎≤ 𝑁 범위에 약수a가 반드시 존재한다.\n\n대우명제>2≤𝑎≤ 𝑁 범위에 약수가 없다면N은 소수다.</code></pre></div>\n<p>해당 명제를 그림으로 보면 훨씬 이해하기 쉽다.</p>\n<p><img src=\"https://media.vlpt.us/images/heesungj7/post/fdc4ba75-7c1c-4ff5-8415-727943be6a3c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-04%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.02.09.png\" alt=\"\"></p>\n<p>위 그림에 16를 대입해보자.</p>\n<ul>\n<li>예들 들어 16의 약수는 1, 2, 4, 8, 16이다.</li>\n<li>이때 2 X 8 = 16은 8 X 2 = 16과 대칭이다.</li>\n<li>예를 들어 16이 2로 나누어떨어진다는 것은 8로도 나누어떨어진다는 것을 의미한다</li>\n</ul>\n<p><img src=\"https://media.vlpt.us/images/heesungj7/post/8d97df8b-62c4-4832-ae76-6d6481399d96/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-04-04%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%205.02.44.png\" alt=\"\"></p>\n<p>❗️ 따라서 우리는 특정한 자연수의 모든 약수를 찾을 때 가운데 <strong>약수(제곱근)까지만</strong> 확인하면 된다.</p>\n<h4 id=\"기본-풀이-1\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%92%80%EC%9D%B4-1\" aria-label=\"기본 풀이 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 풀이:</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">is_prime_number</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 1은 소수가 아니다.</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n    <span class=\"token keyword\">elif</span> n <span class=\"token operator\">==</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 2는 소수이다.</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n    <span class=\"token keyword\">elif</span> n <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 나머지 짝수는 소수가 아니다.</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token comment\"># 2부터 (n의 제곱근) 까지의 모든 수를 확인</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>math<span class=\"token punctuation\">.</span>sqrt<span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># x가 해당 수로 나누어 떨어진다면</span>\n        <span class=\"token keyword\">if</span> n <span class=\"token operator\">%</span> i <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 소수가 아님</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>  <span class=\"token comment\"># 소수임</span></code></pre></div>\n<p>개선된 코드의 시간 복잡도는 제곱근까지 즉 약수들의 절반 길이만큼만 반복문을 실행하기 때문에 O(n^1/2))이다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1%EF%B8%8F%E2%83%A3-%EC%86%8C%EC%88%98%EB%9E%80\">1️⃣ 소수란:</a></p>\n<ul>\n<li><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%92%80%EC%9D%B4\">기본 풀이:</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2%EF%B8%8F%E2%83%A3-%EC%95%BD%EC%88%98%EC%9D%98-%EC%84%B1%EC%A7%88\">2️⃣ 약수의 성질:</a></p>\n<ul>\n<li><a href=\"#%EA%B8%B0%EB%B3%B8-%ED%92%80%EC%9D%B4-1\">기본 풀이:</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 04, 2022","title":"Algorithm[소수]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/algo-prime-number/"}},"prev":{"id":"9c9d5e7a-135d-581e-b38e-dbfa4ba2b797","html":"<p>문제: <a href=\"https://leetcode.com/problems/most-common-word/\">leetcode - 819</a> (Most Common Word\n)</p>\n<p>코로나 격리중..뭐 할까 고민하다 항해에서 보내준 ‘파이썬 알고리즘 인터뷰’ 완독을 목표로 시작한 리트코드 문제풀기, 아직까지는 문제들이 쉬워서 그런지 재밌다 😅.</p>\n<p>이번 문제도 난이도가 높지않지만 파이썬 컴프리헨션과 Counter 클래스를 활용해 볼 수 있는 좋은 문제였다. 알고리즘 준비를 파이썬으로 하겠다고 마음먹고 파이썬 공부를 시작한지 얼마 지나지 않았지만 벌써 푹 빠져버렸다.</p>\n<h4 id=\"문제-해설\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EC%84%A4\" aria-label=\"문제 해설 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 해설:</h4>\n<p>Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.</p>\n<p>The words in paragraph are case-insensitive and the answer should be returned in lowercase.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">most_common_word</span><span class=\"token punctuation\">(</span>paragraph<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span> banned<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># replace := 문자열 치환후, 새로운 문자열 반환</span>\n    <span class=\"token comment\"># 정규식을 쓰기 싫어서 아래와 같이 필터링 했다.</span>\n    <span class=\"token keyword\">for</span> c <span class=\"token keyword\">in</span> <span class=\"token string\">\"!?',;.\"</span><span class=\"token punctuation\">:</span> paragraph <span class=\"token operator\">=</span> paragraph<span class=\"token punctuation\">.</span>replace<span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># 리스트 컨프리헨션 정말 좋다.</span>\n    words <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>word <span class=\"token keyword\">for</span> word <span class=\"token keyword\">in</span> paragraph<span class=\"token punctuation\">.</span>lower<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> word <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> banned<span class=\"token punctuation\">]</span>\n\n\n    counter <span class=\"token operator\">=</span> collections<span class=\"token punctuation\">.</span>Counter<span class=\"token punctuation\">(</span>words<span class=\"token punctuation\">)</span>\n\t<span class=\"token comment\"># Counter 클래스의 most_common() 함수는 튜플 리스트를 반환하기 때문에 주의하자.</span>\n    <span class=\"token comment\"># counter.most_common(1) == [(\"most common word\", #count)]</span>\n    <span class=\"token keyword\">return</span> counter<span class=\"token punctuation\">.</span>most_common<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EC%84%A4\">문제 해설:</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 07, 2022","title":"leetcode(819)- Most Common Word","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-819/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/algo-bubble-sort/","nextSlug":"/algo-prime-number/","prevSlug":"/leetcode-819/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}