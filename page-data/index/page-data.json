{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"24901e94-bbc5-5310-ba1f-c035cbdada67","excerpt":"1️⃣ 병합 정렬 (merge sort) 병합 정렬은 대표적인 분할 정복(Divide and Conquer) 알고리즘이다. 최선과 최악 모두 **O(n log n)**의 시간 복잡도를 가지는 알고리즘으로 대부분의 경우 퀵 정렬보다는 느리지만 일정한 실행 속도와 안정 **정렬(stable sort)**이기 때문에 여전히 상용 라이브러리에 많이 쓰이고 있다.  병합 정렬의 과정을 도식화한 표를 살펴보자. 분활 정복으로 일정하게 정렬이 이뤄지는 병합 정렬의 특징을 잘 파악할 수 있다. ➗ [38, 27, 43, 3, 9, 82, 10]인 입력값은 —> [38, 27, 43, 3]과 [9, 82, 10]로 두 부분으로 분활, —> 다시 [38, 27], [43, 3], [9, 82], [10] 네부분으로 분활 등의 방식으로 각가 더 이상 쪼갤 수 없을 때까지 계속해서 분활한 후, 분활이 끝나면 정렬하면서 정복해 나간다. 2️⃣ 예시 문제: 문제: leetcode - 912 (sort array)…","frontmatter":{"categories":"algorithm","title":"Algorithm[병합정렬]-[leet code 191]","date":"April 09, 2022"},"fields":{"slug":"/leetcode-912/"}}},{"node":{"id":"df4b3ca4-c53a-5a43-bd3d-de3ad2f3106a","excerpt":"문제: leetcode - 125 (Valid Palindrome) A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. 입력으로 주어지는 문자열이 팰린드롬인지 확인하고 True 또는 False를 반환하는 문제이다. 여러가지 방식으로 풀이를 작성하고 제출한 결과 투 포인터를 사용한 풀이가 가장 빠르게 나왔다. 1️⃣ 문제풀이(list): 가장 느림. pop(0)가 O(n)이라 결국 O(n^2)이기 때문에 …","frontmatter":{"categories":"algorithm","title":"leetcode(125)- valid palindrome","date":"April 09, 2022"},"fields":{"slug":"/leecode-125/"}}},{"node":{"id":"2e023ceb-d13f-595e-884f-8ed4534cc0ac","excerpt":"🛁 버블 정렬 구현하기 버블 정렬은 기본적으로 O(N^2)의 시간 복잡도를 가지는 알고리즘이다. 실제 코딩 테스트에서 O(N^2) 알고리즘을 사용하거나 구현할 일은 없겠지만 기본적인 정렬 알고리즘들을 정리하고 개념을 익혀 놓는게 좋을 것 같다. 알고리즘 구현 자체는 크게 어려운 부분이 없다. 버블 정렬은 이름과 같이 물속에서 거품이 올라오는 모양과 비슷하다고 해서 버블 정렬이라고 한다. 배열을 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽 방향으로 이동하면서 이웃한 앞뒤 원소의 값을 비교하고 앞 원소의 값이 더 크다면 두 원소의 자리를 교환(swap)하는 작업을 반복한다.  알고리즘 데이터의 수를 N이라고 하자. 버블 정렬 알고리즘은 아래의 과정을 N번 반복할 것이다. 배열의 0번 칸의 숫자가 1번칸의 숫자 보다 크다면 두 값의 위치를 교환한다. 배열의 1번 칸의 숫자가 2번칸의 숫자 보다 크다면 두 값의 위치를 교환한다. … 배열의 N-2번 칸의 숫자가 N-1 칸의 숫자 보다 크다면 두 …","frontmatter":{"categories":"algorithm","title":"Algorithm[버블정렬]","date":"April 05, 2022"},"fields":{"slug":"/algo-bubble-sort/"}}},{"node":{"id":"3ea323c0-1f6c-5f8e-aa01-aa2cee893b9a","excerpt":"보통 소수 찾기 문제에서 소수의 정의를 같이 제공하기 때문에 반복문으로 충분히 풀이가 가능하다. 그치만 약수가 가지는 특징을 이용하면 성능 개선이 가능하다. 알고리즘 문제를 풀기 위해서 특정 문제에서만 사용되는 지엽적인 지식들은 모두 알고 있을 수 없지만 코딩 테스트에서 특정 자연수가 소수인지 판별하는 문제가 자주 출제되기 때문에 소수에 대한 성질은 짚고 넘어가고자 한다. 1️⃣ 소수란: 소수란 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로 나누어 떨어지지 않는 자연수이다.\ne.g) 6은 1, 2, 3, 6으로 나누어 떨어지므로 소수가 아니다.\ne.g) 7은 1과 7을 제외하고는 나누어 떨어지지 않으므로 소수이다. 소수 정의에 주어진 조건만으로 반복문을 통해서 소수를 판별해보자. 기본 풀이: 소수 판별을 위한 연산량을 생각해보자. 주어진 자연수 n이 10억이라고 한다면 해당 자연수가 소수인지 판별하기 위해서 2부터 10억 - 1까지 반복문 안에 로직을 실행한다. 즉, 2부…","frontmatter":{"categories":"algorithm","title":"Algorithm[소수]","date":"April 04, 2022"},"fields":{"slug":"/algo-prime-number/"}}},{"node":{"id":"390e96e0-3bd7-5724-a676-285b515886f7","excerpt":"파이썬에서 0.1 + 0.2의 값은 얼마일까? 🤔 0.3이 나올 것 같지만 실제 계산 값은 0.30000000000000004가이 나온다. 파이썬은 실수를 부동 소수점 방식으로 표현하기 때문에 실수를 정확히 표현하는 것이 가능하지 않다. 만약 두 실수가 같은지 판단할 때 다음과 같이 0.1 + 0.2와 0.3은 같지 않다고 나온다. 이렇게 실수를 근삿값으로 표현하면서 발생하는 문제를 부동소수점 반올림 **오차(rounding error)**가 발생하기 때문에 실수를 비교할 때는 연산한 값과 비교할 값의 차이를 구한 뒤 특정 오차 범위 안에서 같은지 확인해야 한다. 파이썬 3.5이상부터는 두 실수가 같은지 판단할 때 math.isclose 함수를 사용 할 수 있다. ❗️ 알고리즘 문제를 풀 때도 실수를 비교하는 조건 연산이 있다면 실수 계산을 피할 수 있는지 고려해보는 것이 좋다. 예시: 위 예시는 데이터는 -100,000 이상 100,000 이하의 정수를도 이루어진 배열이 주어진다.…","frontmatter":{"categories":"algorithm","title":"Algorithm[실수 연산을 피하자]","date":"April 01, 2022"},"fields":{"slug":"/algo-avoid-float-number/"}}},{"node":{"id":"2b9832da-cb9c-5a82-a5a2-934fa732b495","excerpt":"문제: leetcode - 200 (Number of Islands) Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 섬의 개수 문제는 DFS 알고리즘의 기본 문제이다. 2x2 형태의 배열 맵이 주어진다. 시작점(루트노트)가 없고 (y,x) 위치에 한 노드는 “1”(섬) 또는 “0” 바다를 나타낸다. 1️⃣ 문제풀이: 특정 노드에 방문했을 때 해당 노드가 ‘1’이면 방문처리(visited)를 한다. 해당 노드의 …","frontmatter":{"categories":"algorithm","title":"leetcode(200)- Number of Islands","date":"March 31, 2022"},"fields":{"slug":"/leetcode-200/"}}},{"node":{"id":"be99792c-2788-5798-9815-55e4eb4ae781","excerpt":"👉 선택 정렬 구현하기 ♻️ 반복하는 과정: 주어진 범위에서 최소 값의 위치를 찾는다. 최소 값을 해당 범위의 가장 앞 숫자와 자리를 바꾼다. 이후, 해당 범위의 가장 앞 자리를 제외한 나머지 범위에 대해 위의 과정을 반복한다. 입력으로 주어진 원본 배열 A와 이를 오름차순으로 정렬한 배열 B가 있다고 하자. 원소의 순서가 다를 뿐 두 배열은 집합적으로는 같은 집합이다.  즉, 특정 인덱스 k에 대하여 배열 B의 원소 b[k]는 오름차순으로 (k+1)번째로 작은 값 이다.  위에 정렬 과정은 아래와 같이 집합으로 표현이 가능하다. 𝑏0=𝑀𝑖𝑛𝐴 =𝑀𝑖𝑛(𝐵)\n𝑏1 =𝑀𝑖𝑛 𝐴−{𝑏0} =𝑀𝑖𝑛(𝐵−{𝑏0})\n𝑏2 =𝑀𝑖𝑛 𝐴−{𝑏0,𝑏1} =𝑀𝑖𝑛(𝐵−{𝑏0,𝑏1}) b0의 값은 배열 A에서 가장 작은 값이된다. b1의 값은 b0을 뺀 배열 A에서 가장 작은 값이된다.\n… 이렇게 작은 숫자부터 차례로 나열하면, 오름차순으로 배열이 정렬된다. 예제 코드: 👉 선택 정렬 구현하기 예제 …","frontmatter":{"categories":"algorithm","title":"Algorithm[선택 정렬]","date":"March 29, 2022"},"fields":{"slug":"/algo-selection-sort/"}}},{"node":{"id":"4e0d5e1b-9044-5dc7-94ca-9650368e76dd","excerpt":"문제: leetcode - 322 (Binary Search) You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. 어느 파이썬 알고리즘 책에서는 해당 문제를 소개하면서 “거스름돈” 문제를 대표적인 그리디 알고리즘이라고 설명한다. 맞다. 그치만 반만 맞다. 그리디하게 해당 문제를 풀…","frontmatter":{"categories":"algorithm","title":"leetcode(322)- Coin change","date":"March 28, 2022"},"fields":{"slug":"/leetcode-322/"}}},{"node":{"id":"363d1ae1-fe29-5f0a-a2d6-0c8364927c01","excerpt":"문제: leetcode - 344 (Valid Palindrome) 주어지는 문자 배열을 리턴 없이 리스트 내부를 직접 조작하여 원소들을 뒤집는 문제이다. pythonic하게 문제를 푼다면 아래와 같이 한줄로 풀이가 가능하다. 투 포인터 방식도 제출해서 시간을 비교해봤지만 크게 차이는 없다.  1️⃣ 문제풀이: 2️⃣ 문제풀이:","frontmatter":{"categories":"algorithm","title":"leetcode(344)- reverse string","date":"March 28, 2022"},"fields":{"slug":"/leetcode-344/"}}},{"node":{"id":"42f94a9b-9d06-5a6a-8566-857441429a96","excerpt":"문제: leetcode - 704 (Binary Search) Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. 기본적인 이진탐색 문제이다. 정렬된 배열에 중간 값을 찾아서 찾고자 하는 값(target)과 비교한다. 중간 값보다 검색 값이 크다면 중간값 기준 배열의 오른쪽 구간을 대상으로 탐색한다. (mid < key) 중간 값보다 검색 값이 작다면 중간값 기준 배열의 왼쪽 구간을 대상으로 탐색한다. (mid > key) 1️⃣ 문제풀이1(반복문): 2️⃣ 문제풀이2(재귀)): 1️⃣ …","frontmatter":{"categories":"algorithm","title":"leetcode(704)- Binary search","date":"March 26, 2022"},"fields":{"slug":"/leetcode-704/"}}},{"node":{"id":"6d14107f-a50c-5014-8973-a77d2adaaced","excerpt":"개발자 커뮤니티에서 깃헙을 통해서 오픈소스에 기여하는 사람들을 보면서 “나도 나중에 한번 해보고싶다”라는 막연한 생각을 가지고 있었다. 생각만 가지고 있었다. 막상 시작하려고 하면 어디서부터 어떻게 시작해야 하는지 감이 잡히지 않았다. 요즘들어 취업 공고를 보면 신입 개발자 채용 공고에도 오픈소스에 기여한 경험이 있는 개발자를 우대한다는 글귀를 쉽게 찾아볼 수 있다. 그래서 이번에 정리해보려 한다. 내가 그럴 실력이 되는지 모르겠지만 일단 어떤식으로 시작해야 하는지 정리가 필요할 것 같다. 👉 오픈소스 참여로 얻는것 1️⃣ 소프트웨어 개선: 사용 중인 오픈소스의 버그를 직접 수정하거나 새로운 기능을 추가하면 소프트웨어가 개선될 뿐만 아니라 이 소프트웨어를 사용하는 모두에게 혜택을 제공할 수 있다. 특히 내가 사용하고 애정을 가지고 있는 라이브러리의 오픈소스 개발에 직접 참여하여 해당 프로젝트를 개선하고 더 좋은 방향으로 나아가는데 기여할 수 있다면 그보다 좋은 경험이 없을 것이다. 2️⃣…","frontmatter":{"categories":"etc","title":"오픈소스 시작하기","date":"March 26, 2022"},"fields":{"slug":"/etc-open-source/"}}},{"node":{"id":"2ee7b41e-a815-5c88-9f47-b2918012f09b","excerpt":"문제: leetcode - 83 (Remove Duplicates from Sorted List) Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 1️⃣ 문제풀이: 정렬된 단일연결리스트를 순회하며 중복(동일값) 여부를 확인하여 제거한다. 반복문과 포인터를 이용하여 LinkedList를 순회하면서 현재노드와 다음 노드의 값이 같은경우 현재노드의 다음노드를 다다음노드로 연결한다. 중복이 발생하는 마지막 노드까지 이동하여 해당 노드의 next 노드 즉, 중복이 아닌 새롭게 시작되는 값을 가진 노드를 현재 head 다음 노드로 연결해준다. 아닐 경우 포인터를 앞으로 한칸 이동시켜 head 노드를 이동시켜준다. 1️⃣ 문제풀이:","frontmatter":{"categories":"algorithm","title":"leetcode(83)- Remove Duplicates from Sorted List","date":"March 25, 2022"},"fields":{"slug":"/leetcode-83/"}}},{"node":{"id":"8b82364b-2829-556f-8cd7-348af94b4575","excerpt":"문제: leetcode - 88 (Merge sorted array) 오름차순으로 정렬된 정수들로 이루어진 2개의 배열 nums1과 nums2가 입력값으로 주어진다. 그냥보면 병합정렬 문제이다. 특이한점이 있다면 return 값으로 병합된 배열을 반환하지 않고 초기에 주어진 nums1에 직접 병합을 해야한다. 예시:  1️⃣ 문제해설 1: 처음에 지문을 읽고는 뭐지..?라는 생각이 들었다. 첫번째로 nums1을 보면 정렬된 정수들뒤로 nums2의 길이만큼 0으로 공간이 초기화되어 있고 배열 내 병합할 원소의 개수를 의미하는 m, n이 주어진다. 결론부터 말하면 sorting 없이 포인터를 지정해서 배열의 병합이 가능하다. 해당 문제풀이는 discussion에서 다른 사람의 코드를 가져왔다. 문제해설2에서 다루겠다. 정렬을 신경쓰지 않고, nums2에 있는 모든 요소들을 nums1에 넣어준다. list.sort()로 오름차 정렬을 시켜준다. 시간 복잡도: 파이썬의 sort() 함수가 O…","frontmatter":{"categories":"algorithm","title":"leetcode(88)- Merge sorted array","date":"March 23, 2022"},"fields":{"slug":"/leetcode-88/"}}},{"node":{"id":"613d8fb0-b581-5f32-899d-e58f0f08d9f2","excerpt":"문제: leetcode - 151 (Reverse Words in a String) 🎉 기분이 좋은 밤이다. 블로그에 현재까지 정리한 문제풀이는 지금 작성하고 있는 리트코드 151번 문제를 포함해서 3개밖에 되지 않지만 벌써 3주째 하루에 한 문제씩 알고리즘 문제를 풀고있다. 아직까지 Hard level의 문제는 시도조차 하지 않고 있고 easy 또는 Medium level의 문제 위주로 풀고있다. 1️⃣ 문제풀이1: 파이썬의 내장함수인 strip() 사용해서 좌우 여백을 제거한다.. 여백이 제거된 문자열을 반복문으로 이동하면서 공백이 나오기전까지 모든 문자들을 temp_string에 임시로 저장한다. 공백이 나오면 새로운 단어가 시작되는 구간이기 때문에 현재 temp_string에 저장된 문자열을 words에 추가하고 temp_string을 다시 초기화 해준다. 마지막 단어 다음에는 공백이 존재하지 않기 때문에 반복문이 끝나면 temp_string에 저장된 마지막 문자열을 words…","frontmatter":{"categories":"algorithm","title":"leetcode(151)- Reverse Words in a String","date":"March 22, 2022"},"fields":{"slug":"/leecode-151/"}}},{"node":{"id":"08fd98ab-1a03-5af1-a296-d4fc8d35a4c6","excerpt":"문제: leetcode -20 (valid parentheses) 이번 문제의 난이도는 easy이고 스택을 이용하는 대표적인 문제이다. 문제 풀이를 위해서 스택의 구현이 직접 필요하지 않으며 python 리스트로 충분히 구현이 가능하다. pop() 연산만이 필요하기 때문에 데크를 이용한 풀이와 시간적으로 차이가 없다. 입력 값으로 괄호로 구성된 문자열이 주어진다. 주어진 문자열을 검사해서 모든 괄호들이 올바르게 닫혀 있는지 확인하여 bool 타입의 결과 값을 리턴 해줘야 한다. 여기서 올바르게 닫혀있는 괄호란 (){}이나 ({}) 같이 닫는 괄호가 나올 때 제일 최근에 있는 여는 괄호와 매칭된 형태이다. ✅ 올바르게 닫힌 괄호 예시: () ({}) {{([])}} ❌ 올바르게 닫히지 않은 예시: (( ((]) ]] ({[)}) 문제풀이: 이 문제의 풀이는 간단하다. 첫번째로 주어진 문자열을 반복문으로 왼쪽에서부터 오른쪽으로 이동한다. 열린 괄호가 나오면 스택에 넣는다. 만약 닫힌 …","frontmatter":{"categories":"algorithm","title":"leetcode(20)- Valid parentheses","date":"March 21, 2022"},"fields":{"slug":"/leetcode-20/"}}},{"node":{"id":"8c65d29f-84d9-56f2-8510-ab52304106e9","excerpt":"문제: leetcode - 509 (피보나치 수열) 일반적으로 F(n)로 표기하며 피보나치 숫자는 피보나치 수열 이라고 불리는 수열를 형성하며, 각 숫자는 0과 1에서 시작하는 앞의 두 숫자의 합이된다. 즉, 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 이다. 예시: F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5 n=5일경우 피보나치 수열을 나열해보면 [0, 1, 1, 2, 4, 5] 형태로 나열된다. 사실 이 문제는 필요한 식을 제공하기 때문에 피보나치 수열을 알고있지 않더라도 풀이가 가능하다. 1️⃣ 문제풀이 1 (recursion) 피보나치 수열 문제는 재귀함수를 소개하는 입문 영상에서 많이 다뤄지는 대표적인 문제이다…","frontmatter":{"categories":"algorithm","title":"leetcode(509)- Fibonacci number","date":"March 21, 2022"},"fields":{"slug":"/leetcode-509/"}}},{"node":{"id":"b73e5d13-5030-5ce7-b1d2-5a706e1aae45","excerpt":"#️⃣ 해시 👨‍🏫 해쉬 테이블(Hash Table)은 “키” 와 “데이터”를 저장함으로써 즉각적으로 데이터를 받아오고 업데이트하고 싶을 때 사용하는 빠른 검색과 저장이 특징인 자료구조이다. 해시 테이블의 형태의 자료구조는 여러 언어에서 이미 우리가 많이 사용하고 있다. 자바스크립트의 오브젝트 또는 파이썬의 딕셔너리를 해시 테이블과 같다고 보면 된다 (사실 완저히 같다고 할 수는 없지만 현재로서는 이렇게 이해하는게 가장 좋을거 같다). “데이터를 빠르게 검색할 수 있다”라는 해시 테이블의 장점은 우리가 딕셔너리에서 또는 자바스크립트 오브젝트에서 index가 아닌 key 값으로 특정 데이터에 접근할 때를 생각하면 된다. 예를 들어서 위에 예시로 작성한 dict 오브젝트에 2개의 데이터 쌍이 아닌 100개의 key value 쌍의 데이터가 있다고 생각해보자. 아무리 많은 데이터가 있어도 key 값만 가지고 있다면 바로 원하는 데이터에 접근할 수 있고 따라서 해시테이블의 평균 시간복잡도는 O(…","frontmatter":{"categories":"DataStructure","title":"Hash table","date":"November 09, 2021"},"fields":{"slug":"/algo-hash-table/"}}},{"node":{"id":"5225a0a2-941e-53ab-975f-368d705f85f7","excerpt":"보초법 (sentinel method) 여러가지 배열 검색 방법들중 선형검색은 배열의 처음부터 마지막 또는 찾고자 하는 데이터가 나올때까지 순차적으로 모든 데이터를 비교하는 방법이다. 간단한 코드 예제 위 선형 검색은 루프가 반복할 때마다 2가지 종료 조건을 체크한다. 단순한 판단이지만 이 과정을 계속 반복하면 종류 조건을 검사하는 cost를 무시할 수 없다. 선형 검색의 종류 조건 i == len(l)가 성립하면 (실패) a[i] == value가 성립하면 (성공) 이과정을 줄여주는 것이 보초법(sentinel method)이다.  검색하고자 하는 키값을 배열의 맨 끝에 넣어준다. 이때 저정하는 값을 보초라고 한다. 위 그림에서 볼 수 있듯이, 기존 데이터에 찾고자하는 키 값이 존재하지 않아도, 보초를 통해 검색할 값을 찾았나?라는 질문에 True를 반환하게된다. 이렇게 if 조건을 하나 단축할 수 있으며, return에서 찾은 데이터의 인덱스가 배열의 길이와 같은지 검사만 해주…","frontmatter":{"categories":"algorithm","title":"Algorithm[sentinel-linear-search]","date":"June 21, 2021"},"fields":{"slug":"/algo-sentinel-search/"}}},{"node":{"id":"6caa77ca-b476-51ff-9633-b8ecf898d197","excerpt":"✏️ 스택 (stack) 스택은 후입선출 구조 (LIFO, Last In First Out) 구조라고 해서 한쪽 끝으로만 자료를 넣고 뺄 수 있는 자료 구조이다. 스택이 사용되는 예시 컴퓨터의 되돌리기(Ctrl + Z) 기능: 직전에 했던 행동을 되돌고 싶을 때 사용하는 기능으로, 이를 위해서는 내가 했던 행동들을 순서대로 기억해야 하므로 스택을 사용한다. 📌 특징 스택은 위의 사진처럼 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을수 있으며 데이터 접근 또한 데이터가 삽입된 top을 통해서만 접근이 가능하다. 스택의 가장 상위에 위치하는 자료는 가장 최근에 들어온 자료이며, 새로 삽입되는 자료는 top이 가리키는 자료의 위에 쌓이게 된다. 스택에서 자료를 삭제할 때도 top을 통해서만 가능하다. 스택에서 top을 통해 삽입하는 연산을 **‘push’ , top을 통한 삭제하는 연산을 ‘pop’**이라고 한다. 스택 자료구조의 기능들을 코드로 직접 구현해보자. 1. Push: 맨 …","frontmatter":{"categories":"DataStructure","title":"Stack & Queue","date":"June 20, 2021"},"fields":{"slug":"/algo-stack-queue/"}}},{"node":{"id":"b5bd90f1-3369-5815-9656-beaa957871a8","excerpt":"1. 이진 탐색 배열 구조의 자료에서 특정 값을 찾는 방법은 크게 두가지가 있을 수 있다. 순차 탐색 이진탐색 순차 탐색에서는 배열의 시작부터 순차적으로 이동하며 찾고자 하는 특정 값을 모든 배열의 원소들과 비교하며 값을 찾을 때까지 반복한다. 이진 탐색이란 데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘이다. 배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교한다. X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로, X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색한다. 출처(https://cjh5414.github.io/binary-search/) 순차 탐색과 이진탐색을 비교해보자. 순차 탐색 array 를 따라가면서 target 이 존재한다면 True 를 반환하고,\n끝까지 없다면 False 를 반환한다. 이진 탐색  1. 이진 탐색 출처(https://cjh5414.github.io/binary-search/) 순차 탐색…","frontmatter":{"categories":"algorithm","title":"Algorithm[이진탐색]","date":"June 16, 2021"},"fields":{"slug":"/algo-binary-search/"}}},{"node":{"id":"92358c06-06d0-5609-90b0-6e7f475873a3","excerpt":"링크드 리스트란?  링크드 리스트는 기존 배열 구조와 마찬가지로 선형 데이터 자료구조를 가진다. 배열에서는 담고있는 데이터 자체가 연속적으로 저장되어 있다면, 링크드리스트는 노드들이 포인터를 통해 연결 관계를 유지하는 리스트이며, 노드는 데이터를 저장하는 부분, 다음 노드를 가르키는 부분으로 구성되어있다. 링크리스트 장/단점: 장점 삽입과 삭제가 O(1)에 이루어진다. 삽입과 삭제를 할 때마다 동적으로 링크드 리스트의 크기가 결정되므로 전통적인 배열(Array)에 비해 처음부터 큰 공간을 할당할 필요가 없어진다. 메모리 관리가 용이하다. 단점 Random Access, 즉 배열처럼 index를 통해 탐색이 불가능하다. 탐색이 O(N)이 걸린다. (Head부터 Tail까지 모두 탐색 시) 사실상 삽입과 삭제가 왼쪽에서(Head에서) 이루어지지 않을 경우, 결국 탐색을 먼저 해야 하기 때문에 삽입과 삭제 모두 적게는 O(k)부터 최악의 경우 O(N)까지 걸릴 가능성이 있다. (출처: …","frontmatter":{"categories":"DataStructure","title":"Linked list","date":"June 15, 2021"},"fields":{"slug":"/algo-linked-list/"}}},{"node":{"id":"38302fb5-353b-571c-a9e5-ea8276f3a8d9","excerpt":"알고리즘 공부를 시작하면서 점점 작아지는 내 모습이 안쓰러울 정도이다…처음 개발 공부를 시작할때 들었던 막막함과는 또 다른 느낌이다. 마치 끝이 보이지 않는 어두캄캄한 길을 걸어가는 느낌..다른 사람들은 당연하다고 생각하는 소스코드도 왜이렇게 이해하기가 힘든지..여튼 쉽지않은 하루를 보내고있다. ✏️ 정렬 오늘은 정렬의 여러가지 방법들을 정리하면서 배운 내용들을 다시 한번 돌아보려고 한다. 1. bubble (버블정렬) - O(n²) 버블 정렬에서는 리스트의 원소들을 처음부터 순차적으로 이동하며 인접한 두 원소의 값을 검사하고 작은 값, 또는 큰 값의 위치를 교환하며 정렬해 나가는 방법이다. 1회차의 검사가 완료되면 가장큰 원소가 자료의 맨 마지막 위치로 이동하게 되므로 2회차 검사에서는 마지막 위치의 온소는 제외하고 반목문을 실행한다. 버블 정렬의 장/단점 코드 구현이 쉽다. 최악의 경우 첫번째 위치의 원소가 마지막 위치까지 이동하기 위해서는 배열을 모든 원소들과 검사하고 교환되어…","frontmatter":{"categories":"algorithm","title":"Algorithm[정렬기초]","date":"June 14, 2021"},"fields":{"slug":"/algo-sort/"}}},{"node":{"id":"70b98f14-868a-5312-90ee-c447c191bd90","excerpt":"1. 문제 0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자를 모두 0, 혹은 모두 1로 같게 만들어야 한다. 할 수 있는 행동은 연속된 하나의 숫자를 잡고 모두 뒤집는 것 이다. 뒤는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다. 주어진 문자열을 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오. 예제: 예를 들어 S=0001100 일 때, 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다. 접근법: 00011000에서 연속된 하나의 숫자, 즉 연속된 문자열들을 하나의 집합으로 구분하여 생각하자. 예를들어, 00011000은 000 11 000 이렇게 구간별로 나눌 수 있다. 따라서 이 경우에 1이 나오는 구간의 문자열들을…","frontmatter":{"categories":"algorithm","title":"Algorithm[reverse-zeros-ones]","date":"June 14, 2021"},"fields":{"slug":"/algo-reverse-string/"}}},{"node":{"id":"5397f91a-ba80-55c1-b57b-b84378ced340","excerpt":"문제: Elements of Programming Interviews in python, page 189 Given an array of positive integers (representing coins), find the smallest value that cannot be constructed from those integers. 0이아닌 정수들로 이루어진 배열이 주어진다. 이때 배열 요소들의 합으로 구할 수 없는 수들 중 가장 작은 수를 반환해야 한다. Exmaple 1️⃣ 문제풀이: 배열의 원소들을 오름차순으로 정렬하는것이 중요하다. 오름차순으로 정렬된 정수들의 누적 합계를 구하면 특정 위치에서 구성 가능한 가장 높은 값을 알 수 있다.\n👉 예들들면) sum of [1, 2 ] = 3 이며 조합 가능한 수는 [1, 2, 3]이다. sum of [1, 2, 4] = 7 이며 조합 가능한 수는 [1, 2, 3, 4, 5, 6, 7]이다. sum of [1, 2, 4, 5] = 1…","frontmatter":{"categories":"algorithm","title":"algoexpert-non-constructible-value","date":"March 24, 2021"},"fields":{"slug":"/algoexpert-non-constructible/"}}}]},"site":{"siteMetadata":{"language":"en","author":{"name":"Heesung Jang","bio":{"role":"developer","description":["who builds great things","who enjoys learning","who values people 💎"],"thumbnail":"sample.png"},"social":{"github":"https://github.com/heesungjang","linkedIn":"","email":"heesungj7@gmail.com"}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}