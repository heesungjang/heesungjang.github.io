{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leetcode-937/",
    "result": {"data":{"cur":{"id":"816ea2bf-180d-51a9-a63b-41dfbb2ea767","html":"<p>문제: <a href=\"https://leetcode.com/problems/reorder-data-in-log-files/submissions/\">leetcode - 937</a> (Reorder Data in Log Files)</p>\n<p>You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.</p>\n<p>There are two types of logs:</p>\n<ul>\n<li>Letter-logs: All words (except the identifier) consist of lowercase English - - letters.</li>\n<li>Digit-logs: All words (except the identifier) consist of digits.</li>\n</ul>\n<p>Reorder these logs so that:</p>\n<ul>\n<li>The letter-logs come before all digit-logs.</li>\n<li>The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.</li>\n<li>The digit-logs maintain their relative ordering.\nReturn the final order of the logs.</li>\n</ul>\n<h4 id=\"문제-해설\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EC%84%A4\" aria-label=\"문제 해설 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 해설:</h4>\n<p>배열의 원소들이 로그들을 주어진 조건에 따라 재정렬하는 문제이다.</p>\n<ol>\n<li>로그의 가장 앞 부분은 식별자이다.</li>\n</ol>\n<ul>\n<li>“digi1 8 1 5 1”에서 digi1이 로그의 특성 즉, 8151이 숫자 로그라는것을 알려주는 식별자이다. =</li>\n</ul>\n<ol start=\"2\">\n<li>문자로 구성된 로그가 숫자 로그보다 앞에오게 한다.</li>\n</ol>\n<ul>\n<li>[“let1 art can”. “digi1 8 1 5 1”]이 주어졌을때 —> [“digi1 8 1 5 1”, “let1 art can”]같이 문자 로그가 배열에 앞에 위치하게 재정렬한다.</li>\n</ul>\n<ol start=\"3\">\n<li>식별자는 순서에 영항을 끼치지 않지만, 문자가 동일할 경우에 식별자 순으로 재정렬한다.</li>\n<li>숫자 로그는 특별한 조건없이 입력 순으로 정렬한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">reorder_log_files</span><span class=\"token punctuation\">(</span>logs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 문자 로그와 숫자 로그를 담을 배열을 초기화</span>\n    letters<span class=\"token punctuation\">,</span> digits <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 문자 로그와 숫자 로그를 나눈다.</span>\n    <span class=\"token keyword\">for</span> log <span class=\"token keyword\">in</span> logs<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> log<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>isdigit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 숫자 로그 또한 문자열로 저장되어 있기에, isdigit으로 판별후 digits에 추가</span>\n            digits<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>log<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 문자 로그를 letters에 추가</span>\n            letters<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>log<span class=\"token punctuation\">)</span>\n\n\t<span class=\"token comment\"># 이 시점에는 모든 문자 로그와 숫자 로그가 나누어져 있음.</span>\n\n    <span class=\"token comment\"># 주어진 조건에 맞게 재정렬을 실행</span>\n    <span class=\"token comment\"># 1. 로그의 컨텐츠로 먼저 정렬을 하고</span>\n    <span class=\"token comment\"># 2. 같은 로그가 있다면 식별자로 한번 더 정렬한다.</span>\n\n    letters<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 이 시점에는 모든 문자 로그들이 조건에 맞게 정렬되어 있음.</span>\n    <span class=\"token comment\"># 문자 로그가 먼저 위치하기 때문에 letters에 digits를 확장해준다.=</span>\n    letters<span class=\"token punctuation\">.</span>extend<span class=\"token punctuation\">(</span>digits<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> letters</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EC%84%A4\">문제 해설:</a></li>\n</ul>\n</div>","excerpt":"문제: leetcode - 937 (Reorder Data in Log Files) You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier. There are two types of logs: Letter-logs: All words (except the identifier) consist of lowercase English - - letters. Digit-logs: All words (except the identifier) consist of digits. Reorder these logs so that: The letter-logs come before all digit-logs. The letter-logs are sorted lexicographically by their contents. If their conte…","frontmatter":{"date":"April 10, 2022","title":"leetcode(937)- Reorder Data in Log Files","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-937/"}},"next":{"id":"5d2e21b6-cee2-5699-ad27-e9d7d20ffe25","html":"<p>문제: <a href=\"https://leetcode.com/problems/group-anagrams/\">leetcode - 49</a> (Group Anagrams)</p>\n<p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p>\n<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Input<span class=\"token punctuation\">:</span> strs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"eat\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"tea\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"tan\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"ate\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"nat\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"bat\"</span><span class=\"token punctuation\">]</span>\n\nOutput<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"bat\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"nat\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"tan\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"ate\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"eat\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"tea\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span></code></pre></div>\n<blockquote>\n<p>아나그램이란?\n일종의 언어유희로 문자를 재배열하여 다른 뜻을 가진 단어로 바꾸는 것을 말한다. 우리말에도 애너그램을 찾아 볼 수 있다. 예로는 “문적박대”를 “대박전문”으로 바꿔 부르는 단어 등을 들 수 있다.</p>\n</blockquote>\n<p>입력 값으로 주어진 문자들을 정렬하여 비교하면 쉽게 풀이가 가능하다. 애너그램이라는 관계가 각은 알파벳들로 이루어저 있기 때문에 구성하고 있는 알파벳만 같다면 알파벳 구성 순서와는 상관없이 정렬후 같은 값을 갖게된다.</p>\n<p>👉 예시로, “nat”과 “tan”은 애너그램이기 때문에 알파벳 순으로 정렬하면 **두 단어 모두 “ant”**가된다.</p>\n<p>애너그램들은 결국 정렬후에 같은 값을 가지기 때문에 파이썬의 dictionary를 활용해서 정렬후 값을 키로 애너그램들을 그룹필 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">group_anagrams</span><span class=\"token punctuation\">(</span>strs<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">str</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># default dictionary 리스트 값으로 생성</span>\n    dic <span class=\"token operator\">=</span> collections<span class=\"token punctuation\">.</span>defaultdict<span class=\"token punctuation\">(</span><span class=\"token builtin\">list</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">for</span> word <span class=\"token keyword\">in</span> strs<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 각 단어를 알파벳 순서로 정렬</span>\n        sorted_word <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span><span class=\"token builtin\">sorted</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># 정렬된 단어를 키 값으로 애너그램을 그룹핑 한다.</span>\n        dic<span class=\"token punctuation\">[</span>sorted_word<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>dic<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span>dic<span class=\"token punctuation\">.</span>values<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>","frontmatter":{"date":"April 10, 2022","title":"leetcode(49) - Group Anagrams","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-49/"}},"prev":{"id":"2b33df80-e8f7-51e2-a78a-b4ca45ae9caa","html":"<p>문제: <a href=\"https://leetcode.com/problems/product-of-array-except-self/\">leetcode - 238</a> (Product of Array Except Self)</p>\n<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p>\n<p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p>\n<p>You must write an algorithm that runs in O(n) time and without using the division operation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]</code></pre></div>\n<p>이번 문제는 해설을 찾아보지 않았으면 풀이 방법을 생각해내지 못했을 것이다.</p>\n<p>O(n)의 시간 복잡도 제약이 있기 때문에 브루트포스 방식으로는 풀이가 불가능하며 나눗셈 operator를 사용하지 않고 풀어야 하기 때문에 구해야하는 값은 간단하지만 문제 난이도는 높은 편인 것 같다.</p>\n<p>👉 여러가지 풀이를 찾아보고 ‘파이썬 알고리즘 인터뷰’ 해설도 참고했지만 <a href=\"https://www.youtube.com/watch?v=bNvIQI2wAjk\">neetcode - 238</a> 채널 해설이 자세하고 이해하기 쉬웠다.</p>\n<p>해당 영상에서는 O(N) + O(N) + O(N)인 공간 복잡도 성능을 O(N) + O(N)로 개선하기 위해서 로직이 추가되는 부분이 있는데 결국 빅오 계산에서는 O(N)이기 때문에 해당 로직은 추가하지 않았다. 그 편이 코드도 간결하고 그래서 알고리즘을 이해하기 편했다.</p>\n<h4 id=\"풀이-접근-방식\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\" aria-label=\"풀이 접근 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이 접근 방식</h4>\n<p>일단 접근법은 아래와 같다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/2e34c455-1a99-42bd-9588-7053d21929ea/image.jpeg\" alt=\"\"></p>\n<p>👉 만약 1번 인덱스 즉, 배열에서 2가 위치한 자리에서 2를 제외한 나머지 값들의 곱은 <strong>2를 기준으로 왼쪽에 있는 원소들과 오른쪽에 위치한 원소들의 곱이다</strong>.</p>\n<ul>\n<li>2를 기준으로 왼쪽에는 1이 있고</li>\n<li>2를 기준으로 오른쪽에는 3, 4가 있다.</li>\n</ul>\n<p>👉 이번에는 2번 인덱스 위치 즉, 배열에서 3을 제외한 나머지 값들의 합을 구해보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/93566e35-27ae-4d2a-a47a-8457573a03ba/image.jpeg\" alt=\"\"></p>\n<ul>\n<li>3을 기준으로 왼쪽에 1,2가 있고</li>\n<li>3을 기준으로 오른쪽에 4가 있다.</li>\n</ul>\n<blockquote>\n<p>⭐️</p>\n</blockquote>\n<ol>\n<li>왼쪽 원소들의 곱과 오른쪽 원소들의 곱을 구해</li>\n<li>두 값을 곱하면 특정 인덱스 위치에서 해당 값을 제외한 모든 원소들을 곱한 값이 나온다는 걸 알 수 있다.</li>\n</ol>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/22778f23-8f3a-4f87-b7a0-4a23ff3dfc98/image.jpeg\" alt=\"\"></p>\n<h4 id=\"문제풀이\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\" aria-label=\"문제풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제풀이:</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">product_except_self</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token comment\"># 나중에 left와 right을 곱한 값을 넣어줄 리스트를 초기화</span>\n    products <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># prefix = left = 인덱스 위치 전에 나오는 원소들의 곱</span>\n    prefix <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># suffix = right = 인덱스 위치 후에 나오는 원소들의 곱</span>\n    suffix <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 반복문으로 각 인덱스마다 그 전 위치까지 모든 원소들의 곱을 구한다.</span>\n    curr_prefix_products <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        prefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> curr_prefix_products\n        curr_prefix_products <span class=\"token operator\">*=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 반복문으로 각 인덱스마다 해당 인덱스 위치 이후에 나오는 모든 원소들의 곱을 곱해서 구한다.</span>\n    curr_suffix_products <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">reversed</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>suffix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        suffix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> curr_suffix_products\n        curr_suffix_products <span class=\"token operator\">*=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># prefix와 suffix를 곱한 값을 products에 넣어준다.</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>products<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        products<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> prefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> suffix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">return</span> products\n</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\">풀이 접근 방식</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\">문제풀이:</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 11, 2022","title":"leetcode(238) - Product of Array Except Self","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leecode-238/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leetcode-937/","nextSlug":"/leetcode-49/","prevSlug":"/leecode-238/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}