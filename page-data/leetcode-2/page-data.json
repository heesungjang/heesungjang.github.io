{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leetcode-2/",
    "result": {"data":{"cur":{"id":"0a0b817b-b952-5bd9-ac39-518bed8080d8","html":"<p>문제: <a href=\"https://leetcode.com/problems/add-two-numbers/\">add-two-numbers</a></p>\n<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p>미디엄 문제이기는 하지만 풀이가 어렵지는 않은 문제다.</p>\n<p>두개의 정수가 역순으로 연결리스트로 주어진다. 역순으로 주어지기 때문에 덧셈 로직을 구현하기 쉽다. 연결 리스트에 역순으로 값이 들어있기 때문에 첫 head 노트부터 덧셈을 하면 우리가 두 수를 더할 때 일의 자리부터 더해서 자릿수를 올리며 더하는 방법과 동일하다.</p>\n<h3 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이:</h3>\n<p>리스트를 순서대로 타고 가면 일의 자리부터 접근할 수 있다. 따라서, 두 리스트를 단순하게 앞에서부터 접근하면서 더해주는 식으로 새로운 연결 리스트를 만들어주면 두 정수의 합을 표현한 역순 열결 리스트를 만들 수 있다.</p>\n<p>❗️중간에 올림 처리와 자릿수가 맞지 않을때, 예를들어 2342 + 387 일 때 비어있는 자리를 0으로 예외 처리만 해주면 쉽게 풀 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">addTwoNumbers</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  curr <span class=\"token operator\">=</span> dummy\n\n  carry <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n  <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">or</span> l2 <span class=\"token keyword\">or</span> carry<span class=\"token punctuation\">:</span>\n      v1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">if</span> l1 <span class=\"token keyword\">else</span> <span class=\"token number\">0</span>\n      v2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">if</span> l2 <span class=\"token keyword\">else</span> <span class=\"token number\">0</span>\n\n      val <span class=\"token operator\">=</span> v1 <span class=\"token operator\">+</span> v2 <span class=\"token operator\">+</span> carry\n\n      carry <span class=\"token operator\">=</span> val <span class=\"token operator\">//</span> <span class=\"token number\">10</span>\n      val  <span class=\"token operator\">=</span> val <span class=\"token operator\">%</span> <span class=\"token number\">10</span>\n\n      curr<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span>\n\n      l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token keyword\">if</span> l1 <span class=\"token keyword\">else</span> <span class=\"token boolean\">None</span>\n      l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token keyword\">if</span> l2 <span class=\"token keyword\">else</span> <span class=\"token boolean\">None</span>\n      curr <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n  <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>","excerpt":"문제: add-two-numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 미디엄 문제이기는 하지만 풀이가 어렵지는 않은 문제다. 두개의 정수가 역순으로 연결리스트로 주어진다. 역순으로 주어지기 때문에 덧셈 로직을 구현하기 쉽다. 연결 리스트에 역순으로 값이 들어있기 때문에 첫 head 노트부터 덧셈을 하면 우리가 두 수를 더할 때 일의 자리부터 더해서 자릿수…","frontmatter":{"date":"April 18, 2022","title":"leetcode(2) - add-two-number","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-2/"}},"next":{"id":"26bc00d2-bf96-5292-ae73-0d3993737640","html":"<p>문제: <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">Merge Two Sorted Lists</a></p>\n<p>You are given the heads of two sorted linked lists list1 and list2.</p>\n<p>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</p>\n<p>Return the head of the merged linked list.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Input<span class=\"token punctuation\">:</span> list1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> list2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>문제 요약: 각각 정렬되어 있는 리스트 노드 2개를 합쳐서 1개의 정렬된 리스트 노드 출력한다.</p>\n<p>유의 사항: 각 리스트 노드가 비어있을 수도 있다. 그러면 빈 리스트 노드를 출력한다.</p>\n<p>찾아보면 재귀적으로 list1과 list2의 값을 비교 연산하고 스왑하는 풀이도 있지만 (“파이썬 알고리즘 인터뷰”) 노드들이 스왑되는 과정이 직관적으로 와닿지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for singly-linked list.</span>\n<span class=\"token comment\"># class ListNode(object):</span>\n<span class=\"token comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.next = next</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n        <span class=\"token comment\"># make dummy node to store merged data</span>\n        dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># make reference named \"tail\" to add nodes</span>\n        tail <span class=\"token operator\">=</span> dummy\n\n        <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">and</span> l2<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n                tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1\n                l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l2\n                l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n            <span class=\"token comment\"># move tail to currently added node, to add further nodes to end</span>\n            tail <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n        tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1 <span class=\"token keyword\">or</span> l2\n\n\n        <span class=\"token comment\"># return dummy.next becuase dummy.next node is the head node for merged linked list</span>\n        <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<p>list1과 list2를 순차적으로 비교하면서 작은 노드순으로 dummy node에 추가하는 방식으로 풀었다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/14a8c81b-69d0-4fe6-a984-3093abe7930e/image.jpeg\" alt=\"\"></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># make dummy node to store merged data</span>\n  dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\"># make reference named \"tail\" to add nodes</span>\n  tail <span class=\"token operator\">=</span> dummy\n\n  <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">and</span> l2<span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">if</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n          tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1\n          l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n      <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n          tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l2\n          l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n      <span class=\"token comment\"># move tail to currently added node, to add further nodes to end</span>\n      tail <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n  tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1 <span class=\"token keyword\">or</span> l2\n\n\n  <span class=\"token comment\"># return dummy.next becuase dummy.next node is the head node for merged linked list</span>\n  <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<ol>\n<li>l1과 l2를 비교하고 작은 값을 dummy에 추가한다.</li>\n<li>하나의 노드 포인터가 마지막 None까지 이동하면 while문을 빠져 나온다.</li>\n<li>남아있는 연결 리스트가 있다면 tail 끝에 추가해준다.</li>\n</ol>","frontmatter":{"date":"April 16, 2022","title":"leetcode(21)- Merge Two Sorted Lists","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-21/"}},"prev":{"id":"9bce0b48-0595-5fc1-af50-a7953428ad3e","html":"<p>문제: <a href=\"https://leetcode.com/problems/remove-duplicate-letters/\">remove duplicate letters</a></p>\n<p>Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Input<span class=\"token punctuation\">:</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"bcabc\"</span>\n\n<span class=\"token operator\">>></span> Output<span class=\"token punctuation\">:</span> <span class=\"token string\">\"abc\"</span></code></pre></div>\n<p>코드 구현 자체는 어렵지 않지만, 문자열을 제거하고 순서에 맞게 나열하는 로직을 생각해 내는 건 쉽지 않아 보인다. 두고두고 충분히 습득될 때까지 여러 번 풀어봐야 할 문제이다.</p>\n<p>입력값 문자열에서 중복된 문자를 제거하고 **“the smallest in lexicographical order”**으로 중복 제거된 문자열을 반환해야 한다.</p>\n<h4 id=\"lexciographical-order란\" style=\"position:relative;\"><a href=\"#lexciographical-order%EB%9E%80\" aria-label=\"lexciographical order란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lexciographical order란?</h4>\n<p>lexicographical order에 대해 먼저 정확한 이해가 필요해 보인다.</p>\n<ul>\n<li>단순히 사전식 정렬, 사전식 오름차순 정렬과는 다르다.</li>\n<li>❗️문자 그대로 사전에서 가장 먼저 찾을 수 있는 순서를 말한다.</li>\n<li>예들들어, bcabc에서 중복을 제거한 경우의 문자에는 아래와 같이 여러가지 조합이 있다.\n<ul>\n<li>bca\n<ul>\n<li>bac</li>\n<li>cab</li>\n<li>abc</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>❗️ 이 중 <strong>사전에서 가장 먼저 찾을 수 있는 것</strong>은 abc이다.</li>\n</ul>\n<p>또 하나 주의해야 하는 부분은, 예제 입/출력에서 ebcabc가 입력값이라면 결과는 eabc가 되지만, ebcabce가 입력값이라면 결과는 abce가 된다.</p>\n<ul>\n<li>❗️ 해당 문자열에서 한 번만 등장하는 문자는 위치를 변경할 수 없다.</li>\n</ul>\n<h3 id=\"스택을-이용한-풀이\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%83%9D%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%92%80%EC%9D%B4\" aria-label=\"스택을 이용한 풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스택을 이용한 풀이:</h3>\n<ol>\n<li>스택에는 문자열에 속한 문자를 차례대로 쌓아 나가되, 다음과 같은 조건인 경우 해당 값을 pop한다.</li>\n</ol>\n<ul>\n<li>현재 문자 char가 스택에 쌓여 있는 문자인 경우(이전 문자보다 앞선 문자인 경우)</li>\n<li>뒤에 붙일 문자가 또 나올 문자인 경우</li>\n</ul>\n<p>뒤에 붙일 문자가 또 나올 문자인지 알기 위해서 collections.Counter()를 이용한다. 이 모듈은 문자별 개수를 자동으로 카운팅해 dict형태로 저장한다.</p>\n<ul>\n<li>문자열 s의 문자들을 차례로 돌면서 counter 값을 -1해주고</li>\n<li>stack에 이미 들어가 있는 문자가 있고</li>\n<li>현재 검사중인 문자가 스택에 가장 위 문자보다 앞선 문자이며</li>\n<li>stack에 가장 위에 있는 문자가 이후에 다시 나올 문자라면</li>\n<li>stack에서 pop() 연산을 한다.</li>\n</ul>\n<p>stack을 사용하기 때문에 스택 ADT에 정의된 연산만을 사용해 문제를 풀어준다. 파이썬 리스트를 스택으로 사용하기 때문에 이미 처리한 문자를 확인할때 in stack 으로 처리할 수 있지만 ADT에 정의된 연산만을 사용하기 위해서 seen이라는 set 자료구조를 별도로 만들어 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">remove_duplicate</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">:</span>\n    counter <span class=\"token operator\">=</span> collections<span class=\"token punctuation\">.</span>Counter<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n    stack <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    seen <span class=\"token operator\">=</span> <span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">for</span> char <span class=\"token keyword\">in</span> s<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> char <span class=\"token keyword\">in</span> seen<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 이미 처리된 문자, 즉 스택에서 제가할 수 없는 문자라면</span>\n            <span class=\"token comment\"># 스택에 넣지 않고 스킵</span>\n            <span class=\"token keyword\">continue</span>\n\n        <span class=\"token comment\"># 중복 문자 제거 부분</span>\n        <span class=\"token comment\"># 현재 문자열이 스택에 있는 문자보다 알파벳 순서로 작은데,</span>\n        <span class=\"token comment\"># 현재 스택에 있는 문자가 뒤에 더 있어서 스택에서 제거가 가능하다면</span>\n        <span class=\"token comment\"># 모두 제거</span>\n        <span class=\"token keyword\">while</span> stack <span class=\"token keyword\">and</span> char <span class=\"token operator\">&lt;</span> stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">and</span> counter<span class=\"token punctuation\">[</span>stack<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            seen<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n        stack<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span>\n        seen<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>char<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span>stack<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<ul>\n<li><a href=\"#lexciographical-order%EB%9E%80\">Lexciographical order란?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%83%9D%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%ED%92%80%EC%9D%B4\">스택을 이용한 풀이:</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"April 19, 2022","title":"leetcode(316) - remove-duplicate-letters","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-316/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leetcode-2/","nextSlug":"/leetcode-21/","prevSlug":"/leetcode-316/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}