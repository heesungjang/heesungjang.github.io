{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leetcode-2/",
    "result": {"data":{"cur":{"id":"0a0b817b-b952-5bd9-ac39-518bed8080d8","html":"<p>문제: <a href=\"https://leetcode.com/problems/add-two-numbers/\">add-two-numbers</a></p>\n<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n<p>미디엄 문제이기는 하지만 풀이가 어렵지는 않은 문제다.</p>\n<p>두개의 정수가 역순으로 연결리스트로 주어진다. 역순으로 주어지기 때문에 덧셈 로직을 구현하기 쉽다. 연결 리스트에 역순으로 값이 들어있기 때문에 첫 head 노트부터 덧셈을 하면 우리가 두 수를 더할 때 일의 자리부터 더해서 자릿수를 올리며 더하는 방법과 동일하다.</p>\n<h3 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이:</h3>\n<p>리스트를 순서대로 타고 가면 일의 자리부터 접근할 수 있다. 따라서, 두 리스트를 단순하게 앞에서부터 접근하면서 더해주는 식으로 새로운 연결 리스트를 만들어주면 두 정수의 합을 표현한 역순 열결 리스트를 만들 수 있다.</p>\n<p>❗️중간에 올림 처리와 자릿수가 맞지 않을때, 예를들어 2342 + 387 일 때 비어있는 자리를 0으로 예외 처리만 해주면 쉽게 풀 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">addTwoNumbers</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  curr <span class=\"token operator\">=</span> dummy\n\n  carry <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n  <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">or</span> l2 <span class=\"token keyword\">or</span> carry<span class=\"token punctuation\">:</span>\n      v1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">if</span> l1 <span class=\"token keyword\">else</span> <span class=\"token number\">0</span>\n      v2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span>val <span class=\"token keyword\">if</span> l2 <span class=\"token keyword\">else</span> <span class=\"token number\">0</span>\n\n      val <span class=\"token operator\">=</span> v1 <span class=\"token operator\">+</span> v2 <span class=\"token operator\">+</span> carry\n\n      carry <span class=\"token operator\">=</span> val <span class=\"token operator\">//</span> <span class=\"token number\">10</span>\n      val  <span class=\"token operator\">=</span> val <span class=\"token operator\">%</span> <span class=\"token number\">10</span>\n\n      curr<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span>\n\n      l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token keyword\">if</span> l1 <span class=\"token keyword\">else</span> <span class=\"token boolean\">None</span>\n      l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token keyword\">if</span> l2 <span class=\"token keyword\">else</span> <span class=\"token boolean\">None</span>\n      curr <span class=\"token operator\">=</span> curr<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n  <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>","excerpt":"문제: add-two-numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 미디엄 문제이기는 하지만 풀이가 어렵지는 않은 문제다. 두개의 정수가 역순으로 연결리스트로 주어진다. 역순으로 주어지기 때문에 덧셈 로직을 구현하기 쉽다. 연결 리스트에 역순으로 값이 들어있기 때문에 첫 head 노트부터 덧셈을 하면 우리가 두 수를 더할 때 일의 자리부터 더해서 자릿수…","frontmatter":{"date":"April 18, 2022","title":"leetcode(2) - add-two-number","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-2/"}},"next":{"id":"26bc00d2-bf96-5292-ae73-0d3993737640","html":"<p>문제: <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">Merge Two Sorted Lists</a></p>\n<p>You are given the heads of two sorted linked lists list1 and list2.</p>\n<p>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</p>\n<p>Return the head of the merged linked list.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Input<span class=\"token punctuation\">:</span> list1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> list2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>문제 요약: 각각 정렬되어 있는 리스트 노드 2개를 합쳐서 1개의 정렬된 리스트 노드 출력한다.</p>\n<p>유의 사항: 각 리스트 노드가 비어있을 수도 있다. 그러면 빈 리스트 노드를 출력한다.</p>\n<p>찾아보면 재귀적으로 list1과 list2의 값을 비교 연산하고 스왑하는 풀이도 있지만 (“파이썬 알고리즘 인터뷰”) 노드들이 스왑되는 과정이 직관적으로 와닿지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for singly-linked list.</span>\n<span class=\"token comment\"># class ListNode(object):</span>\n<span class=\"token comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.next = next</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n        <span class=\"token comment\"># make dummy node to store merged data</span>\n        dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># make reference named \"tail\" to add nodes</span>\n        tail <span class=\"token operator\">=</span> dummy\n\n        <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">and</span> l2<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n                tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1\n                l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l2\n                l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n            <span class=\"token comment\"># move tail to currently added node, to add further nodes to end</span>\n            tail <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n        tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1 <span class=\"token keyword\">or</span> l2\n\n\n        <span class=\"token comment\"># return dummy.next becuase dummy.next node is the head node for merged linked list</span>\n        <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<p>list1과 list2를 순차적으로 비교하면서 작은 노드순으로 dummy node에 추가하는 방식으로 풀었다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/14a8c81b-69d0-4fe6-a984-3093abe7930e/image.jpeg\" alt=\"\"></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># make dummy node to store merged data</span>\n  dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\"># make reference named \"tail\" to add nodes</span>\n  tail <span class=\"token operator\">=</span> dummy\n\n  <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">and</span> l2<span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">if</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n          tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1\n          l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n      <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n          tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l2\n          l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n      <span class=\"token comment\"># move tail to currently added node, to add further nodes to end</span>\n      tail <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n  tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1 <span class=\"token keyword\">or</span> l2\n\n\n  <span class=\"token comment\"># return dummy.next becuase dummy.next node is the head node for merged linked list</span>\n  <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<ol>\n<li>l1과 l2를 비교하고 작은 값을 dummy에 추가한다.</li>\n<li>하나의 노드 포인터가 마지막 None까지 이동하면 while문을 빠져 나온다.</li>\n<li>남아있는 연결 리스트가 있다면 tail 끝에 추가해준다.</li>\n</ol>","frontmatter":{"date":"April 16, 2022","title":"leetcode(21)- Merge Two Sorted Lists","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-21/"}},"prev":{"id":"61b41ba9-fb72-5c22-b074-c31fb247a465","html":"<p>문제:<a href=\"https://leetcode.com/problems/permutations/submissions/\">leetcode-46</a>[Permutation]</p>\n<p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: nums = [1,2,3]\n\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre></div>\n<p>정수로 이루어진 배열을 입력 값으로 받고 해당 정수를로 조합 가능한 모든 순열을 만드는 문제이다.\n<img src=\"https://velog.velcdn.com/images/heesungj7/post/206e43bc-0002-4baa-a151-699287a7c7c6/image.png\" alt=\"\">\n순열의 수를 추출하는 건 고등학교 수학 시간에 배웠으며 이산수학에도 등장하는 수식으로 어렵지 않게 계산할 수 있다. 이 예제값의 순열의 수 수식은 이 되고, 분모는 (3-3) !=1 이므로 분자의 팩토리얼factorial만 계산하면 순열의 수는 3!=3×2×1=6이 된다. 하지만 수학식에 대입해서 가능한 경우의 수를 계산하는게 아니라 가능한 모든 조합을 모두 출력하는건 쉽지 않다.</p>\n<p>이 문제는 그래프로 접근해야 한다. 위 그림처럼 순열이란 결국 모든 가능한 경우를 그래프 형태로 나열한 결과라고 할 수 있다.</p>\n<h3 id=\"문제풀이\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\" aria-label=\"문제풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제풀이:</h3>\n<p>위 그래프에서 리프 노드(leaf node) 즉, 마지막 노드의 값이 순열의 최종 결과이다. 이때 자식 노드의 개수를 살펴보면 root 노드는 3개 그 다음은 2개, 1개 순으로 작아지는 걸 볼 수 있다. 이는 위에서 풀이한 순열이 수식(3! = 3<em>2</em>1)과 동일하다. 예를 들어 입력값이 4개라면 root 부터 자식 노드의 개수는 4<em>3</em>2*1 로 순열의 경우의 수는 24개가 될 것이다.</p>\n<p>이제 위 그래프를 DFS 탐색 알고리즘으로 풀이해보면 for문을 돌며 이전 값을 하나씩 덧붙여 계속 재귀 호출을 진행하다 리프 노드에 도달한 경우 즉, elements 의 개수가 0이 된 지점에 결과에 추가한다.</p>\n<p>dfs 재귀에서는:</p>\n<ol>\n<li>목록에서 하나의 요소를 선택하고 사용 가능한 정수 목록에서 제거한다.</li>\n<li>나머지 목록에 대한 모든 순열을 생성하고 현재 조합중인 리스트(num_set)에 추가한다.</li>\n<li>dfs방식으로 리프 노드까지 탐색이 끝나면 결과(result)에 담고 pop() 하여 다음 노드를 탐색한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">permute</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 탐색이 끝나면 조합된 순열을 추가</span>\n    result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># 현재 탐색중인 순열 조합</span>\n    nums_set <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># 종료 케이스</span>\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 다름 dfs 탐색에서 같은 리스트를 사용하기 때문에 레프런스가 아닌 새로운 배열을 추가</span>\n            result<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>nums_set<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> elements<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 마찬가지로 elements는 다음 num에도 같은 같으로 사용되므로</span>\n            <span class=\"token comment\"># 새로운 리스트를 생성</span>\n            new_list <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n            <span class=\"token comment\"># 방문처리 := 현재 이미 사용한 숫자는 다음 dfs 탐색에서 제외</span>\n            new_list<span class=\"token punctuation\">.</span>remove<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\n\n            nums_set<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span>\n            dfs<span class=\"token punctuation\">(</span>new_list<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\"># 백트래킹 하면서 올라올때 num을 다시 pop해줘서 빈 배열로 다시 만들어줌</span>\n            nums_set<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># dfs 탐색 시작</span>\n    dfs<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\"># dfs 탐색이 끝나면 result 반환</span>\n    <span class=\"token keyword\">return</span> result</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\">문제풀이:</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 19, 2022","title":"leetcode(46) - permutation","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-46/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leetcode-2/","nextSlug":"/leetcode-21/","prevSlug":"/leetcode-46/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}