{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leetcode-234/",
    "result": {"data":{"cur":{"id":"0af9277d-8b5a-58b9-88f9-d56644b440df","html":"<p>문제:<a href=\"%22https://leetcode.com/problems/palindrome-linked-list/%22\">Palindrome Linked List</a></p>\n<p>입력값으로 들어오는 연결리스트가 팬인 그럼 구조인지 확인하는 문제이다. 어렵지 않은 문제이고 두 번째 풀어보는 문제이지만 <strong>slow/fast runner</strong> 구현이 정확히 기억나지 않아 일단 deque로 풀고 “파이선 알고리즘 인터뷰”의 runner 풀이를 다시 공부했다.</p>\n<p>deque를 이용한 문제 풀이는 간단하다. 연결 리스트를 순차적으로 deque에 넣고 popleft()와 pop() 연산을 반복하면서 양 끝에 값을 비교하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> head<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span>\n\n    nums <span class=\"token operator\">=</span> collections<span class=\"token punctuation\">.</span>deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">while</span> head<span class=\"token punctuation\">:</span>\n        nums<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">)</span>\n        head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n    <span class=\"token comment\"># [1, 2]</span>\n            <span class=\"token comment\"># [1, 2]</span>\n    <span class=\"token keyword\">while</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> nums<span class=\"token punctuation\">.</span>pop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">True</span></code></pre></div>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/d6c6313c-4f7c-4dce-b8ec-9e52947f6449/image.jpeg\" alt=\"\"></p>\n<p><strong>런너(runner)</strong> 기법을 활용하면 해당 연결 리스트 속성을 이용해서 풀 수 있다.</p>\n<p>위 그림처럼 slow와 fast 포인터를 시작 head에 위치 시키고 각각 한 칸, 두 칸씩 이동 시키면 빠른 런너가 끝에 다다들 때 느린 런너가 정확히 중간 지점에 도달하게 된다.</p>\n<p>❗️이때 느린 런너는 연결 리스트를 이동하면서 지나온 노드들의 값으로 역순 연결 리스트를 생성한다.</p>\n<p>이렇게 생성된 역순 연결 리스트는 만약 해당 연결 리스트가 팰린드롬이라면 앞으로 남은 연결 리스트들의 값과 같을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">isPalindrome</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> head<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 역순의 연결리스트를 만들 빈 노드가 필요하다</span>\n    rev <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    <span class=\"token comment\"># slow, fast 노드르 초기화한다.</span>\n    slow <span class=\"token operator\">=</span> fast <span class=\"token operator\">=</span> head\n\n    <span class=\"token keyword\">while</span> fast <span class=\"token keyword\">and</span> fast<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\n        fast <span class=\"token operator\">=</span> fast<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n        <span class=\"token comment\"># 슬로우는 역순을 만들면서 이동한다.</span>\n        rev<span class=\"token punctuation\">,</span> rev<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">,</span> slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">,</span> rev<span class=\"token punctuation\">,</span> slow<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n    <span class=\"token comment\"># fast가 남아있다면 링크드 리스트가 홀수이기 때문에 중앙 값에서 한 칸 이동해야한다.</span>\n    <span class=\"token keyword\">if</span> fast<span class=\"token punctuation\">:</span>\n        slow <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n    <span class=\"token keyword\">while</span> rev <span class=\"token keyword\">and</span> rev<span class=\"token punctuation\">.</span>val <span class=\"token operator\">==</span> slow<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n        slow<span class=\"token punctuation\">,</span> rev <span class=\"token operator\">=</span> slow<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">,</span> rev<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n    <span class=\"token comment\"># 링크드 리스트가 팰린드롬이라면 rev와 slow 모두 None 값이다.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">not</span> rev</code></pre></div>\n<p>좀 더 자세히 살펴보면, 역순 열결 리스트는 현재 값을 slow로 교체하고 rev.next는 rev가 된다. 즉 앞에 계속 새로운 노드가 추가되는 형태가 된다. 결국 이 연결 리스트는 slow의 역순 연결 리스트가 된다.</p>\n<p>주의해야 하는 부분이 있는데, 입력값이 홀수일 때와 짝수일 때 마지막 처리가 다르다. 홀수일 때 slow 런너가 한 칸 더 앞으로 이동하여 중앙의 값을 빗겨 나가야 한다.</p>","excerpt":"문제:Palindrome Linked List 입력값으로 들어오는 연결리스트가 팬인 그럼 구조인지 확인하는 문제이다. 어렵지 않은 문제이고 두 번째 풀어보는 문제이지만 slow/fast runner 구현이 정확히 기억나지 않아 일단 deque로 풀고 “파이선 알고리즘 인터뷰”의 runner 풀이를 다시 공부했다. deque를 이용한 문제 풀이는 간단하다. 연결 리스트를 순차적으로 deque에 넣고 popleft()와 pop() 연산을 반복하면서 양 끝에 값을 비교하면 된다.  런너(runner) 기법을 활용하면 해당 연결 리스트 속성을 이용해서 풀 수 있다. 위 그림처럼 slow와 fast 포인터를 시작 head에 위치 시키고 각각 한 칸, 두 칸씩 이동 시키면 빠른 런너가 끝에 다다들 때 느린 런너가 정확히 중간 지점에 도달하게 된다. ❗️이때 느린 런너는 연결 리스트를 이동하면서 지나온 노드들의 값으로 역순 연결 리스트를 생성한다. 이렇게 생성된 역순 연결 리스트는 만약 해당 연…","frontmatter":{"date":"April 15, 2022","title":"leetcode(234)- Palindrome Linked List","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-234/"}},"next":{"id":"903364a3-94cb-50b0-b846-a38e34810127","html":"<p>퀵 정렬은 병합 정렬과 마찬가지로 분할 정복 알고리즘이다. 병합 정렬과 다른점은 항상 배열의 중앙을 기준을 분활 정복을 하는것이 아닌 **pivot(피벗)**이라는 기준을 만들고 피벗보다 작으면 왼쪽, 크면 오른쪽과 같은 방식으로 <strong>partitioning(파티셔닝)</strong> 하면서 쪼개 나간다.</p>\n<p><img src=\"https://www.tutorialspoint.com/data_structures_algorithms/images/quick_sort_partition_animation.gif\" alt=\"\"></p>\n<p>피벗을 정하는 기준과 방법이 여럿 있지만 N.로무토가 구현한 파티션 계획에서 소개된 방법으로 <strong>항상 맨 오른쪽의 피벗</strong>을 택하는 단순한 방식이 가장 간결하고 이해하기 쉽다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> low <span class=\"token operator\">&lt;</span> high<span class=\"token punctuation\">:</span>\n    \t<span class=\"token comment\"># 파티션 함수</span>\n        pivot <span class=\"token operator\">=</span> partition<span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span>\n\n        quick_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        quick_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span></code></pre></div>\n<p>퀵 정렬의 메인 함수는 간단하다. 파티션 함수로 배열을 pivot 기준으로 나누고 재귀 호출하는 전형적인 분할 정복 구조이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">quick_sort</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 파티션 함수</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># pivot 설정 - 오른쪽 끝 마지막 인덱스 선택 (로무토 파티션 계획)</span>\n        pivot <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>high<span class=\"token punctuation\">]</span>\n        left <span class=\"token operator\">=</span> low\n        <span class=\"token keyword\">for</span> right <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">:</span>\n                nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span>\n                left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n        nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>high<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>high<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span>\n\n        <span class=\"token keyword\">return</span> left\n\n    <span class=\"token keyword\">if</span> low <span class=\"token operator\">&lt;</span> high<span class=\"token punctuation\">:</span>\n        pivot <span class=\"token operator\">=</span> partition<span class=\"token punctuation\">(</span>low<span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span>\n\n        quick_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> low<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        quick_sort<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> high<span class=\"token punctuation\">)</span></code></pre></div>\n<p>파티션 함수를 로무토 파티션 계획 방법으로 구현하면 위 코드와 같다. 맨 오른쪽 피벗으로 정하고, 피벗을 기준으로 정렬과 상관없이 단순히 피벗보다 작은 수와, 큰 수들로 배열을 나눈다.</p>\n<p>for문으로 파티션 함수에 들어온 배열을 순회하면서 right 포인터 값이 피벗보다 작다면 left 포인터 값과 스왑하는 형태이다. 이 부분은 코드나 설명을 읽기보다 아래와 같이 직접 포인터를 이동시켜보면 보다 쉽게 이해가 가능하다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/8949c50b-8955-4e5e-8573-af3a9c0d54d5/image.jpeg\" alt=\"\"></p>\n<p>그림에서 보듯이 오른쪽 right 포인터가 이동하면서 피벗의 값이 오른쪽 값보다 더 클 때, 왼쪽과 오른쪽의 스왑이 진행된다. 스왑 이후에는 왼쪽 left 포인터가 함께 이동 한다.</p>\n<p>퀵 정렬의 평균 시간 복잡도는 O(n log n)으 빠르다. 하지만 최악의 경우, 예들들어 이미 정렬된 배열이 입력값으로 들어온다면 O(n^2)이 된다. 항상 일정한 성능을 보이는 병합 정렬과 달리, 퀵 정렬은 이처럼 입력값에 따라 성능 편차가 심한 편이다.</p>","frontmatter":{"date":"April 15, 2022","title":"Algorithm[퀵 정렬]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/algo-quick-sort/"}},"prev":{"id":"26bc00d2-bf96-5292-ae73-0d3993737640","html":"<p>문제: <a href=\"%22https://leetcode.com/problems/merge-two-sorted-lists/%22\">Merge Two Sorted Lists</a></p>\n<p>You are given the heads of two sorted linked lists list1 and list2.</p>\n<p>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</p>\n<p>Return the head of the merged linked list.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Input<span class=\"token punctuation\">:</span> list1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> list2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\nOutput<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>문제 요약: 각각 정렬되어 있는 리스트 노드 2개를 합쳐서 1개의 정렬된 리스트 노드 출력한다.</p>\n<p>유의 사항: 각 리스트 노드가 비어있을 수도 있다. 그러면 빈 리스트 노드를 출력한다.</p>\n<p>찾아보면 재귀적으로 list1과 list2의 값을 비교 연산하고 스왑하는 풀이도 있지만 (“파이썬 알고리즘 인터뷰”) 노드들이 스왑되는 과정이 직관적으로 와닿지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Definition for singly-linked list.</span>\n<span class=\"token comment\"># class ListNode(object):</span>\n<span class=\"token comment\">#     def __init__(self, val=0, next=None):</span>\n<span class=\"token comment\">#         self.val = val</span>\n<span class=\"token comment\">#         self.next = next</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\n        <span class=\"token comment\"># make dummy node to store merged data</span>\n        dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># make reference named \"tail\" to add nodes</span>\n        tail <span class=\"token operator\">=</span> dummy\n\n        <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">and</span> l2<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n                tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1\n                l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n            <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n                tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l2\n                l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n            <span class=\"token comment\"># move tail to currently added node, to add further nodes to end</span>\n            tail <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n        tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1 <span class=\"token keyword\">or</span> l2\n\n\n        <span class=\"token comment\"># return dummy.next becuase dummy.next node is the head node for merged linked list</span>\n        <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<p>list1과 list2를 순차적으로 비교하면서 작은 노드순으로 dummy node에 추가하는 방식으로 풀었다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/14a8c81b-69d0-4fe6-a984-3093abe7930e/image.jpeg\" alt=\"\"></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">mergeTwoLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> l1<span class=\"token punctuation\">,</span> l2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># make dummy node to store merged data</span>\n  dummy <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\"># make reference named \"tail\" to add nodes</span>\n  tail <span class=\"token operator\">=</span> dummy\n\n  <span class=\"token keyword\">while</span> l1 <span class=\"token keyword\">and</span> l2<span class=\"token punctuation\">:</span>\n      <span class=\"token keyword\">if</span> l1<span class=\"token punctuation\">.</span>val <span class=\"token operator\">&lt;</span> l2<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\n          tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1\n          l1 <span class=\"token operator\">=</span> l1<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n      <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n          tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l2\n          l2 <span class=\"token operator\">=</span> l2<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n      <span class=\"token comment\"># move tail to currently added node, to add further nodes to end</span>\n      tail <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n  tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> l1 <span class=\"token keyword\">or</span> l2\n\n\n  <span class=\"token comment\"># return dummy.next becuase dummy.next node is the head node for merged linked list</span>\n  <span class=\"token keyword\">return</span> dummy<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<ol>\n<li>l1과 l2를 비교하고 작은 값을 dummy에 추가한다.</li>\n<li>하나의 노드 포인터가 마지막 None까지 이동하면 while문을 빠져 나온다.</li>\n<li>남아있는 연결 리스트가 있다면 tail 끝에 추가해준다.</li>\n</ol>","frontmatter":{"date":"April 16, 2022","title":"leetcode(21)- Merge Two Sorted Lists","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-21/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leetcode-234/","nextSlug":"/algo-quick-sort/","prevSlug":"/leetcode-21/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}