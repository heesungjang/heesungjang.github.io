{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/코어-자바스크립트-데이터-타입-2/",
    "result": {"data":{"cur":{"id":"f5a48f99-1ec2-5eae-89ad-897316f0de78","html":"<h3 id=\"-들어가며\" style=\"position:relative;\"><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\" 들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚪 들어가며</h3>\n<p>이전 <a href=\"https://heesungjang.github.io/%EC%BD%94%EC%96%B4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/\">데이터 타입 (1)</a>에서 자바스크립트의 기본형 데이터를 정리하면서 정말 많은 aha!를 경험했다. 가장 핵심이되는 개념은 기본형 데이터는 모두 <strong>불변값</strong>이라는 것이다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/8fae1237-810c-4a8d-94cf-3473697cf114/image.png\" alt=\"\"></p>\n<p><code class=\"language-text\">console.log()</code>를 반복하는 2개의 반복문이 있다. 첫 번째 for 문에서는 기본형 데이터 타입인 숫자 2를 두 번째 for 문에서는 {} 빈 객체를 출력한다. 언뜻 보면 비슷해 보이는 두 반복문의 다른 점은 무엇일까?</p>\n<h3 id=\"가변값\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B3%80%EA%B0%92\" aria-label=\"가변값 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변값</h3>\n<p>기본형 데이터의 불변성을 강조하다 보니 참조형 데이터는 모두 가변 값일 것 같은 느낌을 받을 수 있다. 실제 기본적인 성질은 가변 값인 경우가 많지만, 설정에 따라 변경 불가능한 경우도 있고, 아예 불변 값으로 활용하는 경우도 있다. 대표적인 예로 redux의 state 값을 변경할 때 불변성을 유치해주는 경우가 있다.</p>\n<p>참조형 데이터의 가변성을 이해하기 위해서 데이터가 할당되는 과정을 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> myInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">99</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>일단 참조형 데이터 타입의 경우에 기본형과 다르게 메모리 힙이라는 별도에 공간에 저장된다. 메모리 힙과 콜 스택 메모리의 차이는 별도에 블로그에서 정리할 예정이다. 기본형 데이터 타입과 마찬가지로 메모리에 저장하는 과정을 개략적으로 살펴보면서 기본 원리를 이해해보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/5c767015-3cdc-4ab2-9f77-9dbe11a56c92/image.png\" alt=\"\"></p>\n<p>위에서도 언급했지만, 기본형 데이터와의 차이는 “객체의 변수(프로퍼티) 영역”이 별도로 존재한다는 점이다(힙 메모리). 위 예시 코드를 처리하는 과정을 살펴보면,</p>\n<ol>\n<li>컴퓨터는 변수를 위한 공간(메모리) 1002를 확보하고, 그 주소의 식별자(이름)을 myInfo로 지정한다.</li>\n<li>객체의 프로퍼티들을 별도에 공간에 각각 저장하고 해당 데이터의 주소들을 5001에 저장한다.</li>\n<li>이때 myInfo의 값은 5001 주소를 참조하게 된다.</li>\n</ol>\n<p>기본형 데이터 타입과 마찬가지로 참조형 데이터 타입의 실제 값들, 위 예시에서는 99와 “heesung”은 모두 불변 값이다. 그러나 변수에 지정된 값인 5001은 변하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> myInfo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">99</span><span class=\"token punctuation\">,</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nmyInfo<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이번에 나이를 99에서 100살로 변경해보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/92d6f314-5477-43a0-b879-c811259e57fb/image.png\" alt=\"\"></p>\n<p>100은 숫자로 기본형 데이터 타입이다. 기본형 데이터 타입의 값은 하나만 존재 할 수 있다. 현재 99는 이미 메모리에 존재하고 다른 곳에서 number 99를 사용한다면 해당 메모리 위치를 참조 할 것이다.</p>\n<p>위 예시 코드에서 age 프로퍼티의 값을 100으로 변경했다. 컴퓨터는 데이터 영역에서 이미 100이 있는지 찾고 검색 결과가 없으므로 빈 공간인 5005에 저장하고 이 주소를 7103에 저장한다. ❗️ 여기서 주목해야 하는 부분은 바로 <strong>1002</strong>이다. 값의 변경이 일어났지만, 여전히 이전과 같은 <em>5001</em> 주소를 참조하고 있다. 즉, **‘새로운 객체”가 만들어진 것이 아니라 기존의 객체 내부의 값만 바뀐 것이다.</p>\n<p>바로 이 부분 때문에 흔히 참조형 데이터는 불편하지 않다 즉, ‘가변값’이라고 하는 것이다.</p>\n<h3 id=\"불변-객체\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4\" aria-label=\"불변 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변 객체</h3>\n<p>불변 객체는 최근 많이 사용되는 react와 같은 SPA 라이브러리나 프레임워크뿐 아니라 함수형 프로그래밍, 디자인 패턴 등에서도 중요한 기초가 되는 개념이다. 기본형 데이터와 마찬가지로 데이터 자체를 변경하고자 하면(새로운 데이터를 할당) 기존 데이터는 <strong>변하지 않는다</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> d <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> value<span class=\"token operator\">:</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">===</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">===</span> d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span></code></pre></div>\n<p>왜 a와 b는 같지만, c와 d는 다를까? 기본형 데이터는 하나만 존재한다. a에 들어있는 2와 b에 들어있는 2는 같은 메모리 주소를 바라본다. 2를 값으로 가지는 변수가 100개 있다고 해도 마찬가지다. 하지만 객체는 다르다. 우리가 객체 리터럴로 생성한 데이터는 <strong>항상 새로운 객체를 만든다</strong>. 이와 같은 성질을 이용해서 불변성을 확보할 수 있다.</p>\n<p>그럼 어떤 상황에서 불변 객체가 필요할까?</p>\n<p>간단한 예시를 먼저 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> user <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeNewUserWithNewName</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user<span class=\"token punctuation\">,</span> newName</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> newUser <span class=\"token operator\">=</span> user<span class=\"token punctuation\">;</span>\n\n  newUser<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> newName<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> newUser<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> newUser <span class=\"token operator\">=</span> <span class=\"token function\">makeNewUserWithNewName</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span> <span class=\"token string\">'minsoo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>user <span class=\"token operator\">===</span> newUser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"minsoo\"</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newUsern<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"minsoo\"</span></code></pre></div>\n<p><code class=\"language-text\">makeNewUserWithNewName</code>는 기존 유저 객체를 가지고 새로운 이름을 가진 유저를 만드는 함수이다. 만약 새로운 유저가 있다면 무언가를 하는 로직을 뒤에 작성했다면 문제가 될 수 있는 함수이다.</p>\n<p><code class=\"language-text\">var newUser = user</code>에서 newUser에 할당하는 값이 무엇인지 생각해보자. 유저 정보의 객체인가? 아니다 위에서 확인했듯이 user 객체를 담고 있는 메모리 주소를 값으로 가지고 있다. newUser는 해당 주소를 값으로 할당받고 결국 user와 newUser는 같은 프로프티들의 주소를 참조하게 된다.</p>\n<p>**‘객체 리터럴은 항상 새로운 객체를 생성한다’**는 원리를 이용해서 위 함수를 수정해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> user <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">makeNewUserWithNewName</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span> newName <span class=\"token operator\">=</span> <span class=\"token string\">'defaultName'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> newUser <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>user<span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> newName <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> newUser<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> newUser <span class=\"token operator\">=</span> <span class=\"token function\">makeNewUserWithNewName</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">,</span> <span class=\"token string\">'minsoo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>user <span class=\"token operator\">===</span> newUser<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"heesung\"</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>newUsern<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"minsoo\"</span></code></pre></div>\n<p>자 이렇게 하면 user와 newUser는 서로 다른 객체이므로 안전하게 변경 전과 후를 비교할 수 있다. 혹시 redux를 사용해봤다면 위 코드가 익숙할 것이다.</p>\n<h3 id=\"redux-불변성-유지\" style=\"position:relative;\"><a href=\"#redux-%EB%B6%88%EB%B3%80%EC%84%B1-%EC%9C%A0%EC%A7%80\" aria-label=\"redux 불변성 유지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>redux 불변성 유지</h3>\n<p>리덕스에서 상태를 업데이트해야 하는 경우에 불변성을 유지해줘야 한다는 것을 익히 들었을 것이다.</p>\n<p>왜? 불변성을 유지 해줘야 할까? 불변성을 유지한다는 것은 무엇을 의미할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> oldState <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"heesung\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span>\n  profession<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    title<span class=\"token operator\">:</span> <span class=\"token string\">\"frontend developer\"</span><span class=\"token punctuation\">,</span>\n    level<span class=\"token operator\">:</span> <span class=\"token string\">\"junior\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> newState <span class=\"token operator\">=</span> oldState<span class=\"token punctuation\">;</span> ❌\n\nnewState<span class=\"token punctuation\">.</span>profession<span class=\"token punctuation\">.</span>title <span class=\"token operator\">=</span> <span class=\"token string\">\"backend developer\"</span><span class=\"token punctuation\">;</span> ❌</code></pre></div>\n<p>리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경 되는 것을 감지하기 위하여 shallow equality 검사를 하기 때문이다. 보통 어플케이션의 상태 값들은, 특히 서버 데이터 같은 경우에 중첩 객체들이 깊게 중첩적인 구조를 가지고 있기 때문에 상태에 변화를 감지하기 위해서는 재귀적인 ‘deep comparison’이 필요하다.</p>\n<p>하지만 불변성을 유지하면 즉, 참조가 아닌 새로운 객체를 생성하면 이를 통하여 객체의 변화를 감지할 때 객체의 깊숙한 안쪽까지 비교하지 않아도 되기 때문에 보다 효율적인 성능을 유지할 수 있는 것이다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">🚪 들어가며</a></li>\n<li><a href=\"#%EA%B0%80%EB%B3%80%EA%B0%92\">가변값</a></li>\n<li><a href=\"#%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4\">불변 객체</a></li>\n<li><a href=\"#redux-%EB%B6%88%EB%B3%80%EC%84%B1-%EC%9C%A0%EC%A7%80\">redux 불변성 유지</a></li>\n</ul>\n</div>","excerpt":"🚪 들어가며 이전 데이터 타입 (1)에서 자바스크립트의 기본형 데이터를 정리하면서 정말 많은 aha!를 경험했다. 가장 핵심이되는 개념은 기본형 데이터는 모두 불변값이라는 것이다.  를 반복하는 2개의 반복문이 있다. 첫 번째 for 문에서는 기본형 데이터 타입인 숫자 2를 두 번째 for 문에서는 {} 빈 객체를 출력한다. 언뜻 보면 비슷해 보이는 두 반복문의 다른 점은 무엇일까? 가변값 기본형 데이터의 불변성을 강조하다 보니 참조형 데이터는 모두 가변 값일 것 같은 느낌을 받을 수 있다. 실제 기본적인 성질은 가변 값인 경우가 많지만, 설정에 따라 변경 불가능한 경우도 있고, 아예 불변 값으로 활용하는 경우도 있다. 대표적인 예로 redux의 state 값을 변경할 때 불변성을 유치해주는 경우가 있다. 참조형 데이터의 가변성을 이해하기 위해서 데이터가 할당되는 과정을 살펴보자. 일단 참조형 데이터 타입의 경우에 기본형과 다르게 메모리 힙이라는 별도에 공간에 저장된다. 메모리 힙…","frontmatter":{"date":"May 02, 2022","title":"Javascript - 데이터 타입 (2)","categories":"core","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/코어-자바스크립트-데이터-타입-2/"}},"next":{"id":"ee8431ba-c162-5e14-a9e9-7756f14f7413","html":"<h3 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚪들어가며</h3>\n<p>아래 코드의 출력 결과는 무엇일까?</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/327e7810-c3dc-456c-a076-97240fe57228/image.png\" alt=\"\"></p>\n<p>자바스크립트 **primitive type(기본형)**과 <strong>reference type(참조형)</strong> 데이터 타입의 동작과 원리를 살펴보고 평소에 애매모호하게 알고 있던 개념을 확실히 잡아보자.</p>\n<h3 id=\"자바스크립트-데이터-타입-종류\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85-%EC%A2%85%EB%A5%98\" aria-label=\"자바스크립트 데이터 타입 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트 데이터 타입 종류</h3>\n<p>자바스크립트 데이터 타입은 <strong>기본형</strong>과 <strong>참조형</strong> 크게 두가지가 있다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>기본형</strong></th>\n<th align=\"center\"><strong>참조형</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">number</td>\n<td align=\"center\">object</td>\n</tr>\n<tr>\n<td align=\"center\">string</td>\n<td align=\"center\">array</td>\n</tr>\n<tr>\n<td align=\"center\">boolean</td>\n<td align=\"center\">function</td>\n</tr>\n<tr>\n<td align=\"center\">null</td>\n<td align=\"center\">date</td>\n</tr>\n<tr>\n<td align=\"center\">symbol</td>\n<td align=\"center\">RegExp</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"primitive-type기본형\" style=\"position:relative;\"><a href=\"#primitive-type%EA%B8%B0%EB%B3%B8%ED%98%95\" aria-label=\"primitive type기본형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Primitive type(기본형)</h3>\n<p>자바스크립트의 기본형 데이터 타입은 <strong>불변성</strong>을 뛴다는 것을 어디선가 듣거나 읽었을 것이다. 처음 이 개념을 공부할 때는 “불변”이 아니라 “불편”했다.</p>\n<p>여기서 변하지 않는다는 것은 무엇을 의미할까?</p>\n<p>아래 코드를 보면 분명 변수에 할당한 값은 이후에 다시 새로운 값으로 변경할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> initialVariable <span class=\"token operator\">=</span> <span class=\"token string\">'1'</span><span class=\"token punctuation\">;</span>\n\ninitialVariable <span class=\"token operator\">=</span> <span class=\"token string\">'2'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>initialVariable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"2\"</span></code></pre></div>\n<p>리액트 코어 팀에 Dan abramov의 표현을 빌리자면 자바스크립트의 기본형 데이터 타입은 “하늘에 떠 있는 별”과 같다고 표한다. 컴퓨터 언어를 설명하면서 저런 표현이 가능하다니 멋있다.</p>\n<blockquote>\n<p>“They are a permanent part of our JavaScript universe. I can point to them, but I can’t create, destroy, or change them.”</p>\n</blockquote>\n<p>별과 같다니 무슨 뜻일까❓</p>\n<p>자바스크립트가 기본형 데이터 타입을 메모리에 저장하는 과정을 개략적으로 살펴보면 마치 우리가 하늘에 떠 있는 별을 손가락으로 가리키는 건 가능하지만 직접 가서 만질 수 없는 것처럼 작동한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> myName <span class=\"token operator\">=</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>우리가 위와 같이 코드를 작성해도 자바스크립트는 아래와 같이 코드를 읽는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> myName<span class=\"token punctuation\">;</span>\n\nmyName <span class=\"token operator\">=</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>“변수에 값을 할당한다”라는 말을 익히 들어봤을 것이다. 위 동작 원리를 이해하려면 <strong>변수</strong>와 <strong>변수명</strong> 그리고 해당 변수에 할당하는 <strong>값</strong>의 차이를 알아야 한다.</p>\n<p>프로그래밍에서는 <strong>변수</strong> “변할 수 있는 무언가”이며 무언가는 데이터가 된다. <strong>변수명</strong>은 어떤 특정 데이터를 식별하는 이름이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> myName<span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드를 풀어쓰면 <code class=\"language-text\">let myName;</code>은 “메모리에 변경 가능한 데이터를 담을 공간을 확보하고 해당 공간의 찾을때 사용할 식별자로 myName 변수명(이름)을 사용한다”가 된다. 이제 이렇게 확보한 공간에 문자열을 담았다가 숫자를 담는 등의 다양한 명령을 내릴 수 있게 된다. 우리에 예시 코드에서는 해당 공간에 문자열 “heesung”을 담은 것이다.</p>\n<h3 id=\"️-under-the-hood\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-under-the-hood\" aria-label=\"️ under the hood permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⚙️ Under the hood</h3>\n<p>이를 바탕으로 컴퓨터가 우리의 명령을 받아 메모리 영역에서 어떤 작업을 수행하는지 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> myName<span class=\"token punctuation\">;</span>\nmyName <span class=\"token operator\">=</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/d557a81a-f386-4736-b2f9-86f7026de8b8/image.png\" alt=\"\"></p>\n<p>위 코드가 실행되면 명령을받은 컴퓨터가 메모리에서 @1003 위치에 비어있는 메모리 공간 하나를 확보한다. 이 공간의 이름(식별자)을 myName이라고 지정한다. 여기까지가 <strong>변수 선언</strong> 과정이다. 이후에 우리가 myName에 접근하고자 하면 컴퓨터는 메모리에서 myName이라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환한다.</p>\n<p>이제 컴퓨터는 두번째 줄에 있는 <code class=\"language-text\">myName = \"heesung\"</code>이라는 명령을 받아 myName이라는 이름을 가진 주소를 검색해서 그곳에 “heesung”을 할당한다.</p>\n<p>❗️여기서 중요한 점이 해당 위치에 문자열 “heesung”을 직접 저장하지는 않는다. 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 “heesung”을 저장하고, 그 주소를 myName의 메모리 공간에 저장한다. 값을 저장하고 있는 위치는 point(가르키는)하는 것이다. 이를 보고 Dan abramov가 “마치 우리가 별을 손가락으로 가리키는 것과 같다”라고 한 것이지 않을까?</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/0a4c082c-e9e3-4b4b-b66d-b65afaea9cf4/image.png\" alt=\"\"></p>\n<blockquote>\n<p>여기서 왜 값을 직접 대입하지 않고 굳이 또 공간을 할당해서 값을 저장하고 주소를 대입하는 과정을 거치는지 의문이 들 수있다. 이는 데이터의 변환을 자유롭게 하고 메모리를 효율적으로 관리하기 위한 것이다. 자세한 설명은 “코어 자바스크립트” 또는 다른 자바스크립트 책이나 블로그를 찾아보길 바란다.</p>\n</blockquote>\n<p>이제 기존 이름만 가지고 있던 myName에 성을 추가해보고, 기본형이 “불변”이라는 뜻을 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> myName<span class=\"token punctuation\">;</span>\nmyName <span class=\"token operator\">=</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">;</span>\n\nmyName <span class=\"token operator\">+=</span> <span class=\"token string\">' jang'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>myName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"heesung jang\"</span></code></pre></div>\n<p>문자열 “heesung”에 “jang”을 추가하라고 명령하면 컴퓨터는 앞서 “heesung”이 저장된 공간에 “heesung jang”을 할당하는 대신 문자열을 새로 만들어 별도의 공간에 저장하고, 그 주소를 myName 변수 공간에 연결한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/379cbc48-cd8c-4d5a-b91a-89ee5c1bc902/image.png\" alt=\"\"></p>\n<p>❗️ 기존 문자열에 어떤 변화를 가하든 상관없이 무조건 새로 만들어 별도의 공간에 저장한다. 이는 해당 메모리에 문자열이 아니고 숫자가 담겨있다고 해도 같다. 결국 변경은 새로 만드는 동작을 통해서만 이루어지며, 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다. <strong>이것이 자바스크립트의 기본형 데이터 타입이 불편 값의 성질을 가진다는 의미다.</strong></p>\n<h3 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고:</h3>\n<ul>\n<li><a href=\"https://justjavascript.com/learn\">Just Javascript - Dan abramov</a></li>\n<li><a href=\"http://www.yes24.com/Product/Goods/78586788\">코어 자바스크립트</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\">🚪들어가며</a></li>\n<li><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85-%EC%A2%85%EB%A5%98\">자바스크립트 데이터 타입 종류</a></li>\n<li><a href=\"#primitive-type%EA%B8%B0%EB%B3%B8%ED%98%95\">Primitive type(기본형)</a></li>\n<li><a href=\"#%EF%B8%8F-under-the-hood\">⚙️ Under the hood</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고:</a></li>\n</ul>\n</div>","frontmatter":{"date":"May 01, 2022","title":"Javascript - 데이터 타입 (1)","categories":"core","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/코어-자바스크립트-데이터-타입/"}},"prev":{"id":"2c820914-b6a4-5937-b94b-f0dd72f9827b","html":"<p>개인적으로 실행 컨텍스트를 공부하면서 기존에 모호하게 알고 있던 자바스크립트의 다양한 동작 원리들이 보다 뚜렷해졌다. 실행 컨텍스트에서 나오는 개념들을 파악하고 있다면 호이스팅이 발생하는 이유부터 클로저, 태스크 큐, 비동기 처리까지 전반적인 자바스크립트 코어 동작 원리들을 이해할 수 있다.</p>\n<h3 id=\"1-실행-컨텍스트란-무엇인가\" style=\"position:relative;\"><a href=\"#1-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"1 실행 컨텍스트란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 실행 컨텍스트란 무엇인가❓</h3>\n<p>실행은 알겠는데 컨텍스트는 뭘까? 라는 생각을 할 수 있다. 컨텍스트를 굳이 번역해보자면 문맥 또는 환경으로 읽을 수 있다. 그렇다면 “실행 문맥”으로 번역하면 될까? 실행 컨텍스트의 큰 개념을 파악하는데 나름 괜찮은 번역이라고 생각한다.</p>\n<p>우리는 어떤 글을 읽을 때 흔히 ‘문맥’을 파악한다고 하고 이해되지 않거나 현재 내용과 상관없는 내용이 있을 때 ‘문맥’이 맞지 않는다고 말한다. 정확한 비유는 아니지만, 실행 컨텍스트란 자바스크립트 엔진이 ‘문맥’에 맞게 소스 코드를 평가하고 실행할 수 있도록 필요한 정보들을 제공해주는 객체이다.</p>\n<p>그렇다면 자바스크립트 엔진이 문맥에 맞게 코드를 실행하기 위해서 필요한 정보들은 어떤것들이 있을까? 아래 코드를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 전역 변수 선언</span>\n<span class=\"token number\">1.</span> <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token number\">2.</span> <span class=\"token keyword\">var</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 함수 정의</span>\n<span class=\"token number\">3.</span> <span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n <span class=\"token comment\">// 지역 변수 선언</span>\n\t <span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\t <span class=\"token keyword\">var</span> y <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\n <span class=\"token comment\">// 메서드 호출</span>\n\t console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 130</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 함수 호출</span>\n<span class=\"token number\">4.</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 메서드 호출</span>\n<span class=\"token number\">5.</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span></code></pre></div>\n<p>⚠️ 아직 실행 컨텍스트의 lexicalEnvironment에 대한 다루지 않았기 때문에 호이스팅과 스코프 개념을 잠시 베제하고 코드를 읽어보자.</p>\n<p>(1) 자바스크립트 엔진은 1번부터 코드를 읽어 내려가며 실행하게 되고,</p>\n<p>(2) 4번에서 foo(100) 함수가 호출하되며 5번인 console.log(x+y)를 실행하지 않고 3번에 정의된 foo() 함수에 내부로 진입해서 내부 코드를 이어 실행하게 된다.</p>\n<p>(3) foo() 함수의 정의된 실행 명령들이 모두 끝나면 자바스크립트 엔진은 foo() 함수를 빠져나와 전역 공간에서 코드 실행을 이어 나가고 5번에서 console.log(x+y)를 실행하며 모든 작업을 마치게 된다.</p>\n<p>👉 조금 더 자세히 살펴보면,</p>\n<ul>\n<li>\n<p>자바스크립트 엔진은 foo() 함수 내에서 <code class=\"language-text\">console.log(a + x + y)</code> 실행할 때 x, y 값으로 전역 공간에 선언된 x, y가 아니라 현재 foo() 함수 내부에 있는 x, y 값을 구분하여 사용할 줄 알아야 하며</p>\n</li>\n<li>\n<p>함수 호출이 종료되면 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다.</p>\n</li>\n</ul>\n<p><strong>이러첨 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의</strong> 정보들이 필요하며 실행할 코드에 제공할 환경 정보들을 모아놓은 객체가 바로 <strong>“실행 콘텍스트이다”</strong>.</p>\n<p>식별자와 스코프는 실행 컨텍스트의 <strong>렉시컬 환경</strong>으로 관리하고 코드 실행 순서는 <strong>실행 컨텍스트 스택</strong>으로 관리한다.</p>\n<h3 id=\"2-실행-컨텍스트-스택--콜-스택\" style=\"position:relative;\"><a href=\"#2-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%83%9D--%EC%BD%9C-%EC%8A%A4%ED%83%9D\" aria-label=\"2 실행 컨텍스트 스택  콜 스택 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 실행 컨텍스트 스택 / 콜 스택</h3>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// -------------------------- (1)</span>\n<span class=\"token keyword\">const</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> z <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> y <span class=\"token operator\">+</span> z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// -------------------------- (2)</span>\n  <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// -------------------------- (3)</span>\n<span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 6</span></code></pre></div>\n<p>위 예제는 소스코드의 타입으로 분류할 때 전역 코드와 함수 코드로 이루어져 있다. 자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성하고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다. 이렇게 자바스크립트는 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고, 이를 <strong>실행 컨텍스트 스택 (execution context)</strong> 또는 **콜 스택 (call stack)**에 쌓아 올렸다가, 가장 위에 샇여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/cc5fd635-022d-4941-832a-4131151995ed/image.png\" alt=\"\"></p>\n<p>1️⃣ 처음 자바스크립트 코드가 실행되면서 전역 컨텍스트가 콜 스택에 쌓인다. 전역 컨텍스라는 개념은 일반적인 실행 컨텍스트와 특별히 다들 것이 없다. 함수는 컨텍스트가 생성되기 위해서 <code class=\"language-text\">a()</code>와 같이 반드시 해당 함수의 호출이 어디선가 필요하면 전역 컨텍스트느 별도의 실행 명령이 없어도 자바스크립트 파일이 열리는 순간 브라우저에서 자동으로 전역 컨텍스트를 활성화 한다.</p>\n<p>함수 a가 호출되기 전까지 콜 스택에는 전역 컨텍스트만 있기 때문에 전역 컨텍스트와 관련된 코드들을 순차적으로 진행한다. 3️⃣에서 a 함수가 호출되고 자바스크립트 엔진은 a에 대한 환경 정보를 수집해서 a 실행 컨텍스트를 생성한 후 콜 스택에 담는다. 이제 콜 스택 가장 위에는 a 컨텍스트가 위치하게되며 전역 컨텍스트와 관련된 코드의 실행은 일시중단하고 a 실행 컨텍스와 관련된 코드, 즉 a 함수 내부의 코드들을 순차적을 실행한다.</p>\n<p>다시 2️⃣에서 b 함수가 실행되고 콜 스택 가장 위에 b 컨텍스트가 쌓이게 된다. 마찬가지로 a 함수와 관련된 코드들의 실행은 잠시 중단되고 b 함수 내부의 코드를 순서대로 실행한다. 현재 실행중인 함수의 모든 명령들이 끝나게되면 콜 스택에서 해당 컨텍스트는 지워지고 스택 아래 쌓여있던 컨텍스트와 관련된 코드들이 이어서 실행된다. 모든 함수 호출이 종료되고 최종적으로 콜 스택에서 전역 컨텍스트가 제거되며, 콜 스택에 아무것도 남지 않은 상태로 종료된다.</p>\n<h3 id=\"3-렉시컬-환경-lexical-environment\" style=\"position:relative;\"><a href=\"#3-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD-lexical-environment\" aria-label=\"3 렉시컬 환경 lexical environment permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 렉시컬 환경 (lexical environment)</h3>\n<p>함수가 호출되거나 자바스크립트 파일이 실행되면서 생성되는 컨텍스트가 콜 스택에 쌓이면서 어떤 코드의 실행 시점이 정해지는것을 이제 알았다. 그렇다면 앞에서 언급된 코드 실행에 필요한 환경 정보라고 불리는 정보들은 무엇이며 언제 어디에 만들어지는 걸까?</p>\n<p>실행 컨텍스트는 객체이며 객체를 구성하는 컴포넌트로는 lexicalEnvironment와 variableEnvironment가 있다. 그렇다면 실행 컨텍스르를 정확하지만 않지만 개념만 표현하자면 아래와 같은 객체라고 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">ExecutionContext <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  LexicalEnvironment<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  VariableEnvironment<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// this binding은 여기서는 잠시 생략</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<blockquote>\n<p>대부분에 책이나 블로그에서 둘은 초기화 과정 중에는 사실상 완전히 동일하고 이후 strict mode, eval, try/catch문과 같은 특수한 상황을 제외하고는 편의상 두 컴포넌트를 구분하지 않고 렉시컬 환경으로만 설명한다. 두 컴포넌트의 정확한 차이는 따로 정리하는 시간을 가지겠다.</p>\n</blockquote>\n<p>콜 스택이 코드의 실행 순서에 관여한다면 렉시컬 환경은 스코프와 식별자를 관리한다. 렉시컬 환경은 식별자와 식별자에 바인딩된 값과 상위 스코프에 대한 참조를 기록하는 객체로 <strong>키와 값을 갖는 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다</strong>.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/9d6c85d6-197e-43b0-a2e1-c76047344701/image.gif\" alt=\"\"></p>\n<p>무슨말일까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">LexicalEnvironment<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      environmentRecrd<span class=\"token operator\">:</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n      outerEnviromentReference<span class=\"token operator\">:</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>렉시컬 환경의 내부는 <strong>environmentRecord</strong>와 <strong>outerEnvironmentReference</strong>로 구성돼어 있다. environmentRecor에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. 컨텍스트를 구성한느 함수에 지정된 매개변수 식별자와, 선언한 함수가 있을 경우 그 함수 자채, var로 선언된 변수의 식별자 등이 저장되어 있다. 해당 정보들은 컨텍스트가 생성되면 자바스크립트 엔진이 해당 컨텍스트 내부 전체를 한번 훑어나가며 순서대로 수집된다.</p>\n<h4 id=\"-호이스팅\" style=\"position:relative;\"><a href=\"#-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85\" aria-label=\" 호이스팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👉 호이스팅</h4>\n<p>❗️자바스크립트 엔진이 식별자들과 함수 선은들을 수집한다? 해당 컨텍스트내에 코드들이 실행되기 전에 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 식별자 즉, 변수명들과 함수들에 대해 모두 알고있다는 말이다. 우리가 알고있는 그것과 너무나도 비슷하다. 맞다! “호이스팅”이라는 개념은 여기서 나온것이다. 호이스팅의 뜻은 “끌어 올리다”이다. 실행 컨텍스를 공부하기 이전까지는 실제 자바스크립트가 var로 선언된 변수들과 함수들을 뒤에서 끌어 올리고 있다고 생각했다. 그렇게 읽었다 어디선가… 하지만 호이스팅은 실제 environmentRecord에 식별자들과 함수 선언들이 수집되는 과정을 쉽게 이해하기 위해서 만들어진 가상의 개념이다.</p>\n<p>예제 코드를 통해 호이스팅 동작 원리를 살펴보자</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n\n<span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'heesung'</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"heesung\"</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">printName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n  <span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'zion'</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"zion\"</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">printName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"heesung\"</span></code></pre></div>\n<ol>\n<li>\n<p>자바스크립트 파일이 실행되면서 전역 컨텍스트가 생성된다.</p>\n</li>\n<li>\n<p>전역 컨텍스트 객체의 environmentRecord에 전역에 공간에 선언된 변수들의 식별자와 함수들이 수집된다.</p>\n</li>\n<li>\n<p>첫번째 console.log(name)에서 전역 컨텍스트 environmentRecord에 name이라는 식별자가 선언되어 undefined 값을 default로 할당 받았기 때문에 undefiend가 출력된다.</p>\n</li>\n<li>\n<p>name에 “heesung”이 할당되고 다음 console.log() 호출에 “heesung”이 출력된다.</p>\n</li>\n<li>\n<p>printName() 함수가 호출되면서 새로운 함수 실행 컨텍스트가 콜 스택에 쌓인다.</p>\n</li>\n<li>\n<p>컨텍스트가 열리면서 printName 컨텍스트 environmentRecord에 해당 함수 컨텍스트 내에 선언된 식별자와 함수들이 수집된다.</p>\n</li>\n<li>\n<p>name이 이미 수집되어 undefined로 초기화되어 있기 때문에 에러가 발생하지 않고 undefined가 출력된다.</p>\n</li>\n<li>\n<p>name에 “zion”이 할당되고 다음 console.log()에서 “zion”이 출력된다.</p>\n</li>\n<li>\n<p>printName 실행 컨텍스트가 콜 스택에서 제거되고 전역 컨텍스트의 마지막 console.log()가 실행되며 모든 컨텍스트가 콜 스택에서 제거된다.</p>\n</li>\n</ol>\n<h4 id=\"-스코프-스코프-체인-outerenvironmentreference\" style=\"position:relative;\"><a href=\"#-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8-outerenvironmentreference\" aria-label=\" 스코프 스코프 체인 outerenvironmentreference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👉 스코프, 스코프 체인, outerEnvironmentReference</h4>\n<p>스코프(scope)란 식별자(변수)에 대한 유효범위이다. 그리고 ‘식별자의 유효범위’를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인(scope chain)이라고 하며 이것을 가능하게 하는 것이 LexicalEnvironment의 두 번째 컴포넌트인 <strong>outerEnvironmentReference</strong> 이다.</p>\n<p>❗️ 가장 핵심이되는 개념은 <strong>outerEnvironmentReference는 콜스택에서 하위 lexicalEnvironment의 environmentRecord를 참조한다</strong>. 즉, 모든 렉시컬 환경의 [[OuterEnv]] 객체의 필드는 null이거나 하위 environmentRecord를 대한 참조이다. 자식 함수가 자신의 함수내에 선언되지 않은 식별자에 접근하려고 할 때 부모 함수 스코프(변수의 유효 범위)로 범위를 넓혀 식별자를 찾는것이 바로 outerEnvironmentReference 때문에 가능한 동작이다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">1. 실행 컨텍스트란 무엇인가❓</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%83%9D--%EC%BD%9C-%EC%8A%A4%ED%83%9D\">2. 실행 컨텍스트 스택 / 콜 스택</a></p>\n</li>\n<li>\n<p><a href=\"#3-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD-lexical-environment\">3. 렉시컬 환경 (lexical environment)</a></p>\n<ul>\n<li><a href=\"#-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85\">👉 호이스팅</a></li>\n<li><a href=\"#-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B8-outerenvironmentreference\">👉 스코프, 스코프 체인, outerEnvironmentReference</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"May 09, 2022","title":"javascript - 실행 컨텍스트 (feat.호이스팅)","categories":"core","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/코어-자바스크립트-실행-컨텍스트/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/코어-자바스크립트-데이터-타입-2/","nextSlug":"/코어-자바스크립트-데이터-타입/","prevSlug":"/코어-자바스크립트-실행-컨텍스트/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}