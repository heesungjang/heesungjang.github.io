{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leecode-238/",
    "result": {"data":{"cur":{"id":"2b33df80-e8f7-51e2-a78a-b4ca45ae9caa","html":"<p>문제: <a href=\"https://leetcode.com/problems/product-of-array-except-self/\">leetcode - 238</a> (Product of Array Except Self)</p>\n<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p>\n<p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p>\n<p>You must write an algorithm that runs in O(n) time and without using the division operation.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]</code></pre></div>\n<p>이번 문제는 해설을 찾아보지 않았으면 풀이 방법을 생각해내지 못했을 것이다.</p>\n<p>O(n)의 시간 복잡도 제약이 있기 때문에 브루트포스 방식으로는 풀이가 불가능하며 나눗셈 operator를 사용하지 않고 풀어야 하기 때문에 구해야하는 값은 간단하지만 문제 난이도는 높은 편인 것 같다.</p>\n<p>👉 여러가지 풀이를 찾아보고 ‘파이썬 알고리즘 인터뷰’ 해설도 참고했지만 <a href=\"https://www.youtube.com/watch?v=bNvIQI2wAjk\">neetcode - 238</a> 채널 해설이 자세하고 이해하기 쉬웠다.</p>\n<p>해당 영상에서는 O(N) + O(N) + O(N)인 공간 복잡도 성능을 O(N) + O(N)로 개선하기 위해서 로직이 추가되는 부분이 있는데 결국 빅오 계산에서는 O(N)이기 때문에 해당 로직은 추가하지 않았다. 그 편이 코드도 간결하고 그래서 알고리즘을 이해하기 편했다.</p>\n<h4 id=\"풀이-접근-방식\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\" aria-label=\"풀이 접근 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이 접근 방식</h4>\n<p>일단 접근법은 아래와 같다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/2e34c455-1a99-42bd-9588-7053d21929ea/image.jpeg\" alt=\"\"></p>\n<p>👉 만약 1번 인덱스 즉, 배열에서 2가 위치한 자리에서 2를 제외한 나머지 값들의 곱은 <strong>2를 기준으로 왼쪽에 있는 원소들과 오른쪽에 위치한 원소들의 곱이다</strong>.</p>\n<ul>\n<li>2를 기준으로 왼쪽에는 1이 있고</li>\n<li>2를 기준으로 오른쪽에는 3, 4가 있다.</li>\n</ul>\n<p>👉 이번에는 2번 인덱스 위치 즉, 배열에서 3을 제외한 나머지 값들의 합을 구해보자.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/93566e35-27ae-4d2a-a47a-8457573a03ba/image.jpeg\" alt=\"\"></p>\n<ul>\n<li>3을 기준으로 왼쪽에 1,2가 있고</li>\n<li>3을 기준으로 오른쪽에 4가 있다.</li>\n</ul>\n<blockquote>\n<p>⭐️</p>\n</blockquote>\n<ol>\n<li>왼쪽 원소들의 곱과 오른쪽 원소들의 곱을 구해</li>\n<li>두 값을 곱하면 특정 인덱스 위치에서 해당 값을 제외한 모든 원소들을 곱한 값이 나온다는 걸 알 수 있다.</li>\n</ol>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/22778f23-8f3a-4f87-b7a0-4a23ff3dfc98/image.jpeg\" alt=\"\"></p>\n<h4 id=\"문제풀이\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\" aria-label=\"문제풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제풀이:</h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">product_except_self</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token comment\"># 나중에 left와 right을 곱한 값을 넣어줄 리스트를 초기화</span>\n    products <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># prefix = left = 인덱스 위치 전에 나오는 원소들의 곱</span>\n    prefix <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token comment\"># suffix = right = 인덱스 위치 후에 나오는 원소들의 곱</span>\n    suffix <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 반복문으로 각 인덱스마다 그 전 위치까지 모든 원소들의 곱을 구한다.</span>\n    curr_prefix_products <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        prefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> curr_prefix_products\n        curr_prefix_products <span class=\"token operator\">*=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 반복문으로 각 인덱스마다 해당 인덱스 위치 이후에 나오는 모든 원소들의 곱을 곱해서 구한다.</span>\n    curr_suffix_products <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">reversed</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>suffix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        suffix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> curr_suffix_products\n        curr_suffix_products <span class=\"token operator\">*=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># prefix와 suffix를 곱한 값을 products에 넣어준다.</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>products<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        products<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> prefix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> suffix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">return</span> products\n</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%ED%92%80%EC%9D%B4-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\">풀이 접근 방식</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4\">문제풀이:</a></li>\n</ul>\n</div>","excerpt":"문제: leetcode - 238 (Product of Array Except Self) Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. 이번 문제는 해설을 찾아보지 않았으면 풀이 방법을 생각해내지 못했을 것이다. O(n)의 시간 복잡도 제약이 있기 때문에 브루트포스 방식으로는 풀이가 불가능하며 나눗셈 operator를 사용하지 않고 풀어야 하기 때문에 구해야하는 값은…","frontmatter":{"date":"April 11, 2022","title":"leetcode(238) - Product of Array Except Self","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leecode-238/"}},"next":{"id":"a23481e9-33f4-5e36-b83f-24b95b874ebf","html":"<p>문제: <a href=\"https://leetcode.com/problems/3sum/\">leetcode - 15</a> (3sum)</p>\n<p>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.</p>\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n<p>배열을 입력받아 합으로 0을 만들 수 있는 3개의 배열 원소를 찾아 반환하는 문제이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">예시:\n\nInput: nums = [-1,0,1,2,-1,-4]\n\nOutput: [[-1,-1,2],[-1,0,1]]</code></pre></div>\n<p>3개의 원소를 찾아야 하고 브루트 포스로 방식으로 풀이했을 경우 시간 복잡도가 O(n^3)로 당연히 시간 초과가 날 것이다.</p>\n<p><a href=\"https://leetcode.com/problems/two-sum/\">two sum</a> 또는 <a href=\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\">two sum2</a>에 사용했던 투 포인터 기법을 응용하면 이 문제도 나름 쉽게 풀이가 가능하다.</p>\n<p>n개의 숫자리스트가 주어졌을 때 세 수의 합이 0이 되는 세 수를 구해야 한다.</p>\n<ol>\n<li>\n<p>투 포인터 기법을 사용할 것이기 때문에 입력 받은 배열을 오름차 순으로 정렬한다.</p>\n</li>\n<li>\n<p>반복문의 인덱스를 i로 두었을 때, i+1 즉, i를 재외한 나머지 배열의 첫번째 인덱스에 포인터를 하나 위치하고 len(n)-1인 배열의 마지막 인덱스 위치에 포인터를 하나 위치한다. 그림으로 보면 이해가 쉽다.\n<img src=\"https://velog.velcdn.com/images/heesungj7/post/2019a970-8bea-424b-9106-05a70de4e5b3/image.jpeg\" alt=\"\"></p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">three_sum</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token comment\"># 포인터 기법을 사용하기 위해서 배열을 먼저 정렬 한다.</span>\n    nums<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token comment\"># 찾은 pair들을 sums에 저장하기 위해 배열을 하나 초기화 해준다.</span>\n    sums <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 반복문을 설정한다. 최소 3개의 원소가 필요하기 때문에 반복문의 길이는 len()-2로 설정한다.</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># i가 0보다 큰데 즉, 두번째 index 부터 이전에 같은 값이 이미 나온 중복 값인지 체크를 한다.</span>\n        <span class=\"token keyword\">if</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token keyword\">and</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        \t<span class=\"token comment\"># 3. 왼쪽 포인터를 left, 오른쪽 포인터를 right로 설정한다.</span>\n\t\t\t<span class=\"token comment\"># left은 i보다 한 칸 오른쪽에 있고, right은 가장 마지막 칸에 있다 (위 그림 참조).</span>\n            left <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            right <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n\n            <span class=\"token comment\"># left가 right보다 커질 때까지 세 수의 합이 0이 되는 케이스를 찾는다</span>\n            <span class=\"token keyword\">while</span> left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">:</span>\n                curr_sum <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span>\n                <span class=\"token keyword\">if</span> curr_sum <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                    sums<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                    right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n                    <span class=\"token comment\"># 세 수의 합이 0이 되는 경우 answer에 추가해준다.</span>\n                    <span class=\"token comment\"># 중복된 숫자가 존재하면 두 번 탐색하지 않도록 포인터를 한 칸 더 이동시킨다</span>\n                    <span class=\"token keyword\">while</span> left <span class=\"token operator\">&lt;</span> right <span class=\"token keyword\">and</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>left <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                        left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                <span class=\"token keyword\">elif</span> curr_sum <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                    left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                <span class=\"token keyword\">elif</span> curr_sum <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                    right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token keyword\">return</span> sums\n</code></pre></div>","frontmatter":{"date":"April 11, 2022","title":"leetcode(15) - 3 sum","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-15/"}},"prev":{"id":"99b34f9a-06f5-56e1-9c08-5ebafac7db0e","html":"<p><a href=\"https://leetcode.com/problems/maximum-subarray/\">문제:Maximum Subarray</a></p>\n<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>\n<p>A subarray is a contiguous part of an array.</p>\n<p>브루트포스로 O(n^2)을 풀이가 가능한 문제이지만 최대 부분 합을 구하는 유명한 카데인 Kadane’s 알고리즘 풀이가 있다. O(n)에 풀이가 가능하다.</p>\n<h4 id=\"카데인-알고리즘이란\" style=\"position:relative;\"><a href=\"#%EC%B9%B4%EB%8D%B0%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\" aria-label=\"카데인 알고리즘이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>카데인 알고리즘이란?</h4>\n<p>[ 1, -3, -1, 2] 와 같은 수의 나열 “수열”이 주어졌을 때 각 수들을 더했을때 가장 큰 합을 가지는 연속적인 서브 배열을 찾는 알고리즘이다.</p>\n<p>카데인 알고리즘은 “이미 구했던 값은 다시 재사용”하는 접근법을 이용하며, Brute Force의 A[0]~A[N-1]의 접근 방법이 아닌 A[N-1]~A[0] 접근 아이디어를 사용한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/heesungj7/post/3f2f1778-4683-4eda-a147-7ddb622b3d7e/image.png\" alt=\"\"></p>\n<p>위 그림을 보면 A[5]의 curr_max 구하려면, A[4]의 curr_max + A[5]를 해주면 되는걸 확인할 수 있다.</p>\n<blockquote>\n<p>각 A[4] Sum 배열 값에 A[5]를 더해주면 A[5] Sum에 대한 값들이 나온다.</p>\n</blockquote>\n<p>이러한 방법은 A[5]의 모든 부분 합을 처음부터 다시 계산하지 않더라고 A[5]에 부분 합을 구할 수 있음을 뜻한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">curr_max[i] = max(A[i] + curr_max[i-1], A[i])</code></pre></div>\n<ul>\n<li>위 공식은 부분 집합의 최대 합을 구하는 목적이기 때문에,</li>\n<li>A[i]+curr_max[i-1]과 A[i] 중 무엇이 더 큰지 비교합니다. (A[i]가 더 크다면 이 전에 구했던 부분 집합은 필요 없기 때문)</li>\n<li>이렇게 구한 curr_max 배열에서 가장 큰 값을 구하면 Maximum Subarray Problem의 최대 부분 배열 합을 구할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">max_sub_array</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n    curr_sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    max_sum <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token keyword\">for</span> num <span class=\"token keyword\">in</span> nums<span class=\"token punctuation\">:</span>\n        curr_sum <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">,</span> curr_sum <span class=\"token operator\">+</span> num<span class=\"token punctuation\">)</span>\n        max_sum <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>curr_sum<span class=\"token punctuation\">,</span> max_sum<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> max_sum</code></pre></div>","frontmatter":{"date":"April 12, 2022","title":"leetcode(53)- maximum sub-array[카데안 알고리즘]","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-53/"}},"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leecode-238/","nextSlug":"/leetcode-15/","prevSlug":"/leetcode-53/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}