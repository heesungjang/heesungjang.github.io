{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/leetcode-15/",
    "result": {"data":{"cur":{"id":"a23481e9-33f4-5e36-b83f-24b95b874ebf","html":"<p>문제: <a href=\"https://leetcode.com/problems/3sum/\">leetcode - 15</a> (3sum)</p>\n<p>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.</p>\n<p>Notice that the solution set must not contain duplicate triplets.</p>\n<p>배열을 입력받아 합으로 0을 만들 수 있는 3개의 배열 원소를 찾아 반환하는 문제이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">예시:\n\nInput: nums = [-1,0,1,2,-1,-4]\n\nOutput: [[-1,-1,2],[-1,0,1]]</code></pre></div>\n<p>3개의 원소를 찾아야 하고 브루트 포스로 방식으로 풀이했을 경우 시간 복잡도가 O(n^3)로 당연히 시간 초과가 날 것이다.</p>\n<p><a href=\"https://leetcode.com/problems/two-sum/\">two sum</a> 또는 <a href=\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\">two sum2</a>에 사용했던 투 포인터 기법을 응용하면 이 문제도 나름 쉽게 풀이가 가능하다.</p>\n<p>n개의 숫자리스트가 주어졌을 때 세 수의 합이 0이 되는 세 수를 구해야 한다.</p>\n<ol>\n<li>\n<p>투 포인터 기법을 사용할 것이기 때문에 입력 받은 배열을 오름차 순으로 정렬한다.</p>\n</li>\n<li>\n<p>반복문의 인덱스를 i로 두었을 때, i+1 즉, i를 재외한 나머지 배열의 첫번째 인덱스에 포인터를 하나 위치하고 len(n)-1인 배열의 마지막 인덱스 위치에 포인터를 하나 위치한다. 그림으로 보면 이해가 쉽다.\n<img src=\"https://velog.velcdn.com/images/heesungj7/post/2019a970-8bea-424b-9106-05a70de4e5b3/image.jpeg\" alt=\"\"></p>\n</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">three_sum</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> List<span class=\"token punctuation\">[</span>List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n\t<span class=\"token comment\"># 포인터 기법을 사용하기 위해서 배열을 먼저 정렬 한다.</span>\n    nums<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token comment\"># 찾은 pair들을 sums에 저장하기 위해 배열을 하나 초기화 해준다.</span>\n    sums <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 반복문을 설정한다. 최소 3개의 원소가 필요하기 때문에 반복문의 길이는 len()-2로 설정한다.</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\"># i가 0보다 큰데 즉, 두번째 index 부터 이전에 같은 값이 이미 나온 중복 값인지 체크를 한다.</span>\n        <span class=\"token keyword\">if</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token keyword\">and</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">continue</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        \t<span class=\"token comment\"># 3. 왼쪽 포인터를 left, 오른쪽 포인터를 right로 설정한다.</span>\n\t\t\t<span class=\"token comment\"># left은 i보다 한 칸 오른쪽에 있고, right은 가장 마지막 칸에 있다 (위 그림 참조).</span>\n            left <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            right <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span>\n\n            <span class=\"token comment\"># left가 right보다 커질 때까지 세 수의 합이 0이 되는 케이스를 찾는다</span>\n            <span class=\"token keyword\">while</span> left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">:</span>\n                curr_sum <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span>\n                <span class=\"token keyword\">if</span> curr_sum <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                    sums<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n                    left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                    right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n                    <span class=\"token comment\"># 세 수의 합이 0이 되는 경우 answer에 추가해준다.</span>\n                    <span class=\"token comment\"># 중복된 숫자가 존재하면 두 번 탐색하지 않도록 포인터를 한 칸 더 이동시킨다</span>\n                    <span class=\"token keyword\">while</span> left <span class=\"token operator\">&lt;</span> right <span class=\"token keyword\">and</span> nums<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> nums<span class=\"token punctuation\">[</span>left <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n                        left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                <span class=\"token keyword\">elif</span> curr_sum <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                    left <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n                <span class=\"token keyword\">elif</span> curr_sum <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n                    right <span class=\"token operator\">-=</span> <span class=\"token number\">1</span>\n\n    <span class=\"token keyword\">return</span> sums\n</code></pre></div>","excerpt":"문제: leetcode - 15 (3sum) Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. 배열을 입력받아 합으로 0을 만들 수 있는 3개의 배열 원소를 찾아 반환하는 문제이다. 3개의 원소를 찾아야 하고 브루트 포스로 방식으로 풀이했을 경우 시간 복잡도가 O(n^3)로 당연히 시간 초과가 날 것이다. two sum 또는 two sum2에 사용했던 투 포인터 기법을 응용하면 이 문제도 나름 쉽게 풀이가 가능하다. n개의 숫자리스트가 주어졌을 때 세 수의 합이 0이 되는 세 수를 구해야 한다. 투 포인터 기법을 사용할 것이기 때문에 입력…","frontmatter":{"date":"April 11, 2022","title":"leetcode(15) - 3 sum","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-15/"}},"next":{"id":"816ea2bf-180d-51a9-a63b-41dfbb2ea767","html":"<p>문제: <a href=\"https://leetcode.com/problems/reorder-data-in-log-files/submissions/\">leetcode - 937</a> (Reorder Data in Log Files)</p>\n<p>You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.</p>\n<p>There are two types of logs:</p>\n<ul>\n<li>Letter-logs: All words (except the identifier) consist of lowercase English - - letters.</li>\n<li>Digit-logs: All words (except the identifier) consist of digits.</li>\n</ul>\n<p>Reorder these logs so that:</p>\n<ul>\n<li>The letter-logs come before all digit-logs.</li>\n<li>The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.</li>\n<li>The digit-logs maintain their relative ordering.\nReturn the final order of the logs.</li>\n</ul>\n<h4 id=\"문제-해설\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EC%84%A4\" aria-label=\"문제 해설 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 해설:</h4>\n<p>배열의 원소들이 로그들을 주어진 조건에 따라 재정렬하는 문제이다.</p>\n<ol>\n<li>로그의 가장 앞 부분은 식별자이다.</li>\n</ol>\n<ul>\n<li>“digi1 8 1 5 1”에서 digi1이 로그의 특성 즉, 8151이 숫자 로그라는것을 알려주는 식별자이다. =</li>\n</ul>\n<ol start=\"2\">\n<li>문자로 구성된 로그가 숫자 로그보다 앞에오게 한다.</li>\n</ol>\n<ul>\n<li>[“let1 art can”. “digi1 8 1 5 1”]이 주어졌을때 —> [“digi1 8 1 5 1”, “let1 art can”]같이 문자 로그가 배열에 앞에 위치하게 재정렬한다.</li>\n</ul>\n<ol start=\"3\">\n<li>식별자는 순서에 영항을 끼치지 않지만, 문자가 동일할 경우에 식별자 순으로 재정렬한다.</li>\n<li>숫자 로그는 특별한 조건없이 입력 순으로 정렬한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">reorder_log_files</span><span class=\"token punctuation\">(</span>logs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># 문자 로그와 숫자 로그를 담을 배열을 초기화</span>\n    letters<span class=\"token punctuation\">,</span> digits <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n\t<span class=\"token comment\"># 문자 로그와 숫자 로그를 나눈다.</span>\n    <span class=\"token keyword\">for</span> log <span class=\"token keyword\">in</span> logs<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> log<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>isdigit<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 숫자 로그 또한 문자열로 저장되어 있기에, isdigit으로 판별후 digits에 추가</span>\n            digits<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>log<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># 문자 로그를 letters에 추가</span>\n            letters<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>log<span class=\"token punctuation\">)</span>\n\n\t<span class=\"token comment\"># 이 시점에는 모든 문자 로그와 숫자 로그가 나누어져 있음.</span>\n\n    <span class=\"token comment\"># 주어진 조건에 맞게 재정렬을 실행</span>\n    <span class=\"token comment\"># 1. 로그의 컨텐츠로 먼저 정렬을 하고</span>\n    <span class=\"token comment\"># 2. 같은 로그가 있다면 식별자로 한번 더 정렬한다.</span>\n\n    letters<span class=\"token punctuation\">.</span>sort<span class=\"token punctuation\">(</span>key<span class=\"token operator\">=</span><span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># 이 시점에는 모든 문자 로그들이 조건에 맞게 정렬되어 있음.</span>\n    <span class=\"token comment\"># 문자 로그가 먼저 위치하기 때문에 letters에 digits를 확장해준다.=</span>\n    letters<span class=\"token punctuation\">.</span>extend<span class=\"token punctuation\">(</span>digits<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> letters</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EC%84%A4\">문제 해설:</a></li>\n</ul>\n</div>","frontmatter":{"date":"April 10, 2022","title":"leetcode(937)- Reorder Data in Log Files","categories":"algorithm","author":"heesung jang","emoji":"✏️"},"fields":{"slug":"/leetcode-937/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://heesungjang.github.io","comments":{"utterances":{"repo":"heesungjang/heesungjang.github.io"}}}}},"pageContext":{"slug":"/leetcode-15/","nextSlug":"/leetcode-937/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}